<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>内部排序 &amp; 完结撒花</title>
    <link href="/2023/03/02/%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F-%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1/"/>
    <url>/2023/03/02/%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F-%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1/</url>
    
    <content type="html"><![CDATA[<p>数据结构课程笔记 ep9</p><span id="more"></span><h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 - 概述"></a>1 - 概述</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ol><li>假设一个含有 n 个记录的序列 {R1, R2, …, Rn}，其相应关键字序列为 {K1, K2, …, Kn}，这些关键字可以相互比较，即存在关系：$$K_{p1}≤K_{p2}≤…≤K_{pn}$$；按照此关系将序列重新排列为 {Rp1, Rp2, …, Rpn} 的操作称为<strong>排序</strong></li><li>如果待排序序列中存在多个具有相同关键字的记录，若经过排序这些记录的相对次序保持不变，则称这种排序算法是<strong>稳定</strong>的，否则称这种排序算法是<strong>不稳定</strong>的</li><li>在内存（RAM）中进行的排序过程称为<strong>内部排序</strong>；若待排序序列中记录量大以至于内存不能一次性容纳全部记录，则在排序过程中需访问外存，该排序过程称为<strong>外部排序</strong>；以下“排序”特指内部排序</li></ol><h4 id="待排序序列的存储表示"><a href="#待排序序列的存储表示" class="headerlink" title="待排序序列的存储表示"></a>待排序序列的存储表示</h4><p>待排序序列采用顺序存储，其数据类型定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-comment">// 其它数据项</span><br>&#125; RcdType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    RcdType R[MAXSIZE+<span class="hljs-number">1</span>]; <span class="hljs-comment">// R[0]闲置</span><br>    <span class="hljs-type">int</span> length;<br>&#125; SqList;<br></code></pre></td></tr></table></figure><h4 id="评价排序算法的主要标准"><a href="#评价排序算法的主要标准" class="headerlink" title="评价排序算法的主要标准"></a>评价排序算法的主要标准</h4><ol><li>时间性能<ul><li>取决于两个基本操作的次数<ul><li>比较关键字</li><li>移动记录</li></ul></li><li>具体表现与记录序列实例有关<ul><li>最好</li><li>最坏</li><li>平均</li></ul></li></ul></li><li>空间性能<ul><li>取决于所需的辅助空间</li></ul></li></ol><h3 id="2-插入类排序"><a href="#2-插入类排序" class="headerlink" title="2 - 插入类排序"></a>2 - 插入类排序</h3><p>将序列划分为已排序部分和未排序部分，即在插入第 i 个记录 Ri 时，{R1, R2, …, Ri-1} 是已排序部分，{Ri, Ri+1, …, Rn} 是未排序部分，此时：</p><ol><li>在已排序部分中<strong>查找</strong> Ri 的插入位置：R[1…j].key ≤ R[i].key &lt; R[j+1…i-1].key（保持稳定性）</li><li>将 {Rj+1, …, Ri-1} 中的所有记录均<strong>后移</strong>一位</li><li>将 Ri <strong>插入</strong>到 Rj+1 的位置上</li></ol><h4 id="基于顺序查找的插入排序"><a href="#基于顺序查找的插入排序" class="headerlink" title="基于顺序查找的插入排序"></a>基于顺序查找的插入排序</h4><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertionSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=L.length;++i) &#123;<br>        L.R[<span class="hljs-number">0</span>]=L.R[i]; <span class="hljs-comment">// 设置监视哨</span><br>        <span class="hljs-type">int</span> j;<br>        <span class="hljs-keyword">for</span> (j=i<span class="hljs-number">-1</span>;L.R[<span class="hljs-number">0</span>].key&lt;L.R[j].key;--j) <span class="hljs-comment">// 查找</span><br>            L.R[j+<span class="hljs-number">1</span>]=L.R[j]; <span class="hljs-comment">// 后移</span><br>        L.R[j+<span class="hljs-number">1</span>]=L.R[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 插入</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法评价"><a href="#算法评价" class="headerlink" title="算法评价"></a>算法评价</h5><ol><li><p>时间性能</p><ul><li><p>最好：序列中记录按关键字递增有序</p><p>比较次数：$$\sum_{i&#x3D;2}^n1&#x3D;n-1$$</p><p>移动次数：$$\sum_{i&#x3D;2}^n2&#x3D;2n-2$$</p><p>时间复杂度：$$O(n)$$</p></li><li><p>最坏：序列中记录按关键字递减有序</p><p>比较次数：$$\sum_{i&#x3D;2}^ni&#x3D;\frac{(n+2)(n-1)}2$$</p><p>移动次数：$$\sum_{i&#x3D;2}^n(i+1)&#x3D;\frac{(n+4)(n-1)}2$$</p><p>时间复杂度：$$O(n^2)$$</p></li><li><p>平均：序列中记录随机排列</p><p>比较次数：取最好情况和最坏情况的平均值，约为 $$\frac{n^2}4$$</p><p>移动次数：取最好情况和最坏情况的平均值，约为 $$\frac{n^2}4$$</p><p>时间复杂度：$$O(n^2)$$</p></li></ul></li><li><p>空间性能</p><ul><li>空间复杂度：$$O(1)$$</li></ul></li></ol><p>适用于序列中记录数量很小的情况</p><p><strong>稳定性</strong>：稳定</p><h4 id="基于二分查找的插入排序"><a href="#基于二分查找的插入排序" class="headerlink" title="基于二分查找的插入排序"></a>基于二分查找的插入排序</h4><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BiInsertionSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=L.length;++i) &#123;<br>        L.R[<span class="hljs-number">0</span>]=L.R[i]; <span class="hljs-comment">// 将L.R[i]暂存到L.R[0]</span><br>        <span class="hljs-type">int</span> low=<span class="hljs-number">1</span>,high=i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (low&lt;=high) &#123; <span class="hljs-comment">// 查找</span><br>            <span class="hljs-type">int</span> mid=(low+high)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (L.R[<span class="hljs-number">0</span>].key&lt;L.R[mid].key)<br>                high=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                low=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 此时，low=high+1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=low;--j) <span class="hljs-comment">// 后移</span><br>            L.R[j+<span class="hljs-number">1</span>]=L.R[j];<br>        L.R[low]=L.R[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 插入</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法评价-1"><a href="#算法评价-1" class="headerlink" title="算法评价"></a>算法评价</h5><ol><li>平均时间复杂度：$$O(n^2)$$</li><li>空间复杂度：$$O(1)$$</li></ol><p>当序列中记录数量很大时，可大幅降低关键字的比较次数</p><p><strong>稳定性</strong>：稳定</p><h4 id="希尔排序（缩小增量排序）"><a href="#希尔排序（缩小增量排序）" class="headerlink" title="希尔排序（缩小增量排序）"></a>希尔排序（缩小增量排序）</h4><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><ol><li><p>将含有 n 个记录的待排序序列分成 d 个子序列：（d 称为<strong>增量</strong>）</p><p>{R[1], R[d+1], R[2d+1], …, R[kd+1]}</p><p>{R[2], R[d+2], R[2d+2], …, R[kd+2]}</p><p>…</p><p>{R[d], R[2d], R[3d], …, R[(k+1)d]}</p></li><li><p>分别对 d 个子序列进行 d 次插入排序，保持子序列之间的相对位置不变</p></li><li><p>增量 d 在排序过程中从大到小逐渐缩小，直至最后一趟排序减为 1</p></li></ol><p>增量的取法：一般公认，增量没有公因子，最后一趟为 1</p><p>示例：</p><p>待排序序列关键字：{49, 38, 65, 97, 76, 13, 27, <em><strong>49</strong></em>, 55, 04}</p><ul><li><p>第一趟排序：d &#x3D; 5</p><p>子序列：</p><p>{49,                         13                        }，排序后：{13,                         49                        }</p><p>{      38,                         27                  }，排序后：{      27,                         38                  }</p><p>{            65,                         <em><strong>49</strong></em>            }，排序后：{            <em><strong>49</strong></em>,                         65            }</p><p>{                  97,                         55      }，排序后：{                  55,                         97      }</p><p>{                        76,                         04}，排序后：{                        04,                         76}</p><p>整个序列排序后：{13, 27, <em><strong>49</strong></em>, 55, 04, 49, 38, 65, 97, 76}</p></li><li><p>第二趟排序：d &#x3D; 3</p><p>子序列：</p><p>{13,             55,             38,             76}，排序后：{13,             38,             55,             76}</p><p>{      27,             04,             65            }，排序后：{      04,             27,             65            }</p><p>{            <em><strong>49</strong></em>,             49,             97      }，排序后：{            <em><strong>49</strong></em>,             49,             97      }</p><p>整个序列排序后：{13, 04, <em><strong>49</strong></em>, 38, 27, 49, 55, 65, 97, 76}</p></li><li><p>第三趟排序：d &#x3D; 1</p><p>整个序列排序后：{04, 13, 27, 38, <em><strong>49</strong></em>, 49, 55, 65, 76, 97}</p></li></ul><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一趟排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellInsertionSort</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> d)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=d+<span class="hljs-number">1</span>;i&lt;=L.length;++i) &#123;<br>        L.R[<span class="hljs-number">0</span>]=L.R[i];<br>        <span class="hljs-type">int</span> j;<br>        <span class="hljs-keyword">for</span> (j=i-d;L.R[<span class="hljs-number">0</span>].key&lt;L.R[j].key&amp;&amp;j&gt;<span class="hljs-number">0</span>;j-=d)<br>            L.R[j+d]=L.R[j];<br>        L.R[j+d]=L.R[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> d[],<span class="hljs-type">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t;++i)<br>        <span class="hljs-built_in">ShellInsertionSort</span>(L,d[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法评价-2"><a href="#算法评价-2" class="headerlink" title="算法评价"></a>算法评价</h5><p>希尔排序将相隔某个增量的记录组成一个子序列，关键字较小的记录跳跃式地往前移，在进行最后一趟增量为 1 的排序时，序列已基本有序，只需作少量的关键字比较和记录移动即可完成排序</p><p>希尔排序的平均时间复杂度为 $$O(n^{1.3-2})$$，空间复杂度为 $$O(1)$$；它没有时间复杂度为 $$O(nlogn)$$ 的快速排序算法快，因此对中等规模的序列表现良好，但对大规模的序列不是最优选择，总之比时间复杂度为 $$O(n^2)$$ 的普通插入排序快得多</p><p><strong>稳定性</strong>：不稳定</p><h3 id="3-交换类排序"><a href="#3-交换类排序" class="headerlink" title="3 - 交换类排序"></a>3 - 交换类排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><ol><li>从 R[1] 开始，两两比较 R[i] 和 R[i+1] <strong>(i &#x3D; 1, 2, …, n-1)</strong> 的关键字大小，若 R[i].key &gt; R[i+1].key，则交换 R[i] 和 R[i+1] 的位置，第一趟完成后 <strong>R[n]</strong> 是序列中关键字<strong>最大</strong>的记录</li><li>从 R[1] 开始，两两比较 R[i] 和 R[i+1] <strong>(i &#x3D; 1, 2, …, n-2)</strong> 的关键字大小，若 R[i].key &gt; R[i+1].key，则交换 R[i] 和 R[i+1] 的位置，第二趟完成后 <strong>R[n-1]</strong> 是序列中关键字<strong>次大</strong>的记录</li><li>反复进行 n-1 趟上述过程</li></ol><p>示例：</p><p>待排序序列关键字：{65, 97, 76, 13, 27, 49, 58}</p><ul><li>第一趟结果：{65, 76, 13, 27, 49, 58, <em><strong>97</strong></em>}</li><li>第二趟结果：{65, 13, 27, 49, 58, <em><strong>76</strong></em>, <em><strong>97</strong></em>}</li><li>第三趟结果：{13, 27, 49, 58, <em><strong>65</strong></em>, <em><strong>76</strong></em>, <em><strong>97</strong></em>}</li><li>第四趟结果：{13, 27, 49, <em><strong>58</strong></em>, <em><strong>65</strong></em>, <em><strong>76</strong></em>, <em><strong>97</strong></em>}</li><li>第五趟结果：{13, 27, <em><strong>49</strong></em>, <em><strong>58</strong></em>, <em><strong>65</strong></em>, <em><strong>76</strong></em>, <em><strong>97</strong></em>}</li><li>第六趟结果：{13, <em><strong>27</strong></em>, <em><strong>49</strong></em>, <em><strong>58</strong></em>, <em><strong>65</strong></em>, <em><strong>76</strong></em>, <em><strong>97</strong></em>}</li></ul><h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L.length<span class="hljs-number">-1</span>;++i) <span class="hljs-comment">// i记趟数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=L.length-i<span class="hljs-number">-1</span>;++j)<br>            <span class="hljs-keyword">if</span> (L.R[j].key&gt;L.R[j+<span class="hljs-number">1</span>].key)<br>                <span class="hljs-built_in">swap</span>(L.R[j],L.R[j+<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h5><p>对于示例，第三趟完成后序列已经有序，后面三趟没有发生交换，浪费时间</p><p>改进：标记每趟是否有发生交换，若没有发生交换，则表示序列已经有序，结束排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 改进的冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;i&lt;L.length<span class="hljs-number">-1</span>&amp;&amp;flag;++i) &#123; <span class="hljs-comment">// i记趟数，flag=1表示有发生交换</span><br>        flag=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=L.length-i<span class="hljs-number">-1</span>;++j)<br>            <span class="hljs-keyword">if</span> (L.R[j].key&gt;L.R[j+<span class="hljs-number">1</span>].key) &#123;<br>                <span class="hljs-built_in">swap</span>(L.R[j],L.R[j+<span class="hljs-number">1</span>]);<br>                flag=<span class="hljs-number">1</span>;<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>某一趟完成后序列不一定整体有序，但其无序部分末尾却有可能已经有序</p><p>进一步改进：下一趟的比较到本趟最后一次发生交换的位置之前为止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 进一步改进的冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=L.length;i&gt;<span class="hljs-number">1</span>;) &#123;<br>        <span class="hljs-type">int</span> lastidx=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j)<br>            <span class="hljs-keyword">if</span> (L.R[j].key&gt;L.R[j+<span class="hljs-number">1</span>].key) &#123;<br>                <span class="hljs-built_in">swap</span>(L.R[j],L.R[j+<span class="hljs-number">1</span>]);<br>                lastidx=j;<br>            &#125;<br>        i=lastidx;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法评价（对进一步改进的冒泡排序）"><a href="#算法评价（对进一步改进的冒泡排序）" class="headerlink" title="算法评价（对进一步改进的冒泡排序）"></a>算法评价（对进一步改进的冒泡排序）</h5><ol><li><p>时间性能</p><ul><li><p>最好：序列中记录按关键字递增有序，只需一趟冒泡</p><p>比较次数：n-1</p><p>移动次数：0</p><p>时间复杂度：$$O(n)$$</p></li><li><p>最坏：序列中记录按关键字递减有序，需要 n-1 趟冒泡</p><p>比较次数：$$\sum_{i&#x3D;n}^2(i-1)&#x3D;\frac{n(n-1)}2$$</p><p>移动次数：$$3\sum_{i&#x3D;n}^2(i-1)&#x3D;\frac{3n(n-1)}2$$</p><p>时间复杂度：$$O(n^2)$$</p></li><li><p>平均：序列中记录随机排列</p><p>时间复杂度：$$O(n^2)$$</p></li></ul></li><li><p>空间性能</p><ul><li>空间复杂度：$$O(1)$$</li></ul></li></ol><p><strong>稳定性</strong>：稳定</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是基于分治的排序算法，既是受二叉搜索树启发，也是冒泡排序的改进，被评为 20 世纪十大算法之一</p><h5 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h5><ol><li>选定一个记录并以其关键字为<strong>枢轴（Pivot）</strong>，凡关键字小于枢轴的记录均移动至该记录之前，凡关键字大于枢轴的记录均移动至该记录之后；使得序列被划分成两部分：枢轴前的序列记录的关键字小于等于枢轴，枢轴后的序列记录的关键字大于等于枢轴，枢轴对应记录已经在合适的位置上</li><li>分别对划分所得两部分子序列“递归”进行快速排序，直至序列只有一个记录</li></ol><p>“凡关键字小于枢轴的记录均移动至该记录之前，凡关键字大于枢轴的记录均移动至该记录之后”用<strong>双指针</strong>实现：</p><ol><li><p>设置 low 指针和 high 指针初始化为序列最小索引和序列最大索引</p></li><li><p>选定枢轴并将其对应记录复制到 R[0]，然后将其对应记录与 R[low] 交换或直接选定 R[low].key 为枢轴，先处理 R[high]（或：将其对应记录与 R[high] 交换或直接选定 R[high].key 为枢轴，先处理 R[low]）</p></li><li><p>处理 R[high]：若 R[high].key ≥ R[0].key，则 high 前移一位，继续处理 R[high]；否则将 R[high] 复制到 R[low]，处理 R[low]</p><p>处理 R[low]：若 R[low].key ≤ R[0].key，则 low 后移一位，继续处理 R[low]；否则将 R[low] 复制到 R[high]，处理 R[high]</p></li><li><p>重复执行 3，直至 low &#x3D; high，此时将 R[0] 复制到 R[low]</p></li></ol><h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot=L.R[low].key; <span class="hljs-comment">// 直接选定R[low].key为枢轴</span><br>    L.R[<span class="hljs-number">0</span>]=L.R[low];<br>    <span class="hljs-keyword">while</span> (low&lt;high) &#123;<br>        <span class="hljs-comment">// 先处理R[high]</span><br>        <span class="hljs-keyword">while</span> (low&lt;high&amp;&amp;L.R[high].key&gt;=pivot)<br>            --high;<br>        L.R[low]=L.R[high];<br>        <span class="hljs-keyword">while</span> (low&lt;high&amp;&amp;L.R[low].key&lt;=pivot)<br>            ++low;<br>        L.R[high]=L.R[low];<br>    &#125;<br>    L.R[low]=L.R[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s&lt;t) &#123;<br>        <span class="hljs-type">int</span> pivotloc=<span class="hljs-built_in">Partition</span>(L,s,t);<br>        <span class="hljs-built_in">QuickSort</span>(L,s,pivotloc<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">QuickSort</span>(L,pivotloc+<span class="hljs-number">1</span>,t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法评价-3"><a href="#算法评价-3" class="headerlink" title="算法评价"></a>算法评价</h5><p>快速排序涉及递归，需要使用栈保存函数状态，所以其空间复杂度取决于递归至最深处栈中元素数，而其时间复杂度取决于 Partition 函数的时间复杂度 $$O(n)$$ 与执行该函数的次数（与递归至最深处栈中元素数数量级相同）之积，因此 $$O_T(n)&#x3D;n*O_S(n)$$</p><ul><li><p>最好：每次划分后，枢轴恰好将序列<strong>均分</strong>成两部分，枢轴位置在中间</p><p>空间复杂度：$$O(logn)$$</p><p>时间复杂度：$$O(nlogn)$$</p></li><li><p>最坏：每次划分后，其他所有记录恰好都在枢轴对应记录的<strong>一侧</strong>，快速排序退化为冒泡排序（与二叉搜索树退化为链表类似）</p><p>空间复杂度：$$O(n)$$</p><p>时间复杂度：$$O(n^2)$$</p></li><li><p>平均：序列中记录按关键字随机分布</p><p>结论：</p><p>空间复杂度：$$O(logn)$$</p><p>时间复杂度：$$O(nlogn)$$</p></li></ul><p>尽可能远离最坏情况、接近最好情况的方法：</p><ol><li><p>选定合适的枢轴</p><p>随机选定枢轴，或随机选取三个关键字并选定居中者为枢轴，一般选定 R[low].key, R[high].key, R[(low+high)&#x2F;2].key 中居中者为枢轴（“中值快排法”）</p></li><li><p>与插入排序、堆排序结合使用</p><img src="https://pic1.zhimg.com/80/v2-8fa032e195365f77fb6b980a4ed71958_1440w.webp" alt="img"  /><p>具体参考：<a href="https://zhuanlan.zhihu.com/p/36274119">C++一道深坑面试题：STL里sort算法用的是什么排序算法？ - 知乎</a></p></li></ol><p>其他优化：三路快速排序</p><p><strong>稳定性</strong>：不稳定</p><h3 id="4-选择类排序"><a href="#4-选择类排序" class="headerlink" title="4 - 选择类排序"></a>4 - 选择类排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><h5 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h5><p>令 i 从 1 至 n-1，反复进行 n-1 趟以下过程：通过 n-i 次关键字间的比较，从 n-i+1 个记录中选择关键字最小的记录并与第 i 个记录交换</p><h5 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=L.length<span class="hljs-number">-1</span>;++i) &#123;<br>        <span class="hljs-type">int</span> minidx=i,min=L.R[i].key;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=L.length;++j)<br>            <span class="hljs-keyword">if</span> (L.R[j].key&lt;min) &#123;<br>                minidx=j;<br>                min=L.R[j].key;<br>            &#125;<br>        <span class="hljs-keyword">if</span> (minidx!=i)<br>            <span class="hljs-built_in">swap</span>(L.R[minidx],L.R[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法评价-4"><a href="#算法评价-4" class="headerlink" title="算法评价"></a>算法评价</h5><ol><li><p>时间性能</p><ul><li><p>比较次数：$$\sum_{i&#x3D;1}^{n-1}(n-1)&#x3D;\frac{n(n-1)}2$$</p><p>移动次数：最好情况为 0，最坏情况为 3(n-1)</p><p>最好、最坏、平均时间复杂度：$$O(n^2)$$（时间性能与记录序列实例无关）</p></li></ul></li><li><p>空间性能</p><ul><li>空间复杂度：$$O(1)$$</li></ul></li></ol><p><strong>稳定性</strong>：不稳定</p><h4 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h4><h5 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h5><p>模拟锦标赛进行选择排序：（结合示例理解）</p><ol><li>先对 n 个记录的关键字进行两两比较得到 ⌈n&#x2F;2⌉ 个较小者，再对 ⌈n&#x2F;2⌉ 个较小者进行两两比较得到 ⌈⌈n&#x2F;2⌉&#x2F;2⌉ 个更小者，如此重复直至选出最小者，得到关键字最小的记录</li><li>将所得记录在序列中的对应记录的关键字改为 ∞，并根据 1 中原则更新该记录的产生路径上的关键字值，得到此时关键字最小的记录</li><li>重复执行 2，直至得到 n 个记录</li></ol><p>示例：</p><p>待排序序列关键字：{49, 38, 65, 97, 76, 13, 27, 49}</p><p><img src="/..%5Cimg%5Cep9%5Cimage-20230203202943465.png" alt="image-20230203202943465"></p><h5 id="算法评价-5"><a href="#算法评价-5" class="headerlink" title="算法评价"></a>算法评价</h5><ol><li>平均时间复杂度：$$O(nlogn)$$（除关键字最小的记录外，每得到一个记录需进行 $$⌈log_2n⌉$$ 次比较）</li><li>空间复杂度：$$O(n)$$</li></ol><p><strong>稳定性</strong>：稳定</p><p>树形选择排序虽然有 $$O(nlogn)$$ 的时间复杂度，但是排序过程中频繁与 ∞ 进行多余的比较，且开辟的辅助空间较多，堆排序可以弥补这些缺点</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>数列 {$$r_1$$, $$r_2$$, …, $$r_n$$}：</p><ul><li>若满足 $$r_i≤r_{2i}$$ 且 $$r_i≤r_{2i+1}$$，则称为<strong>小顶堆（Max heap）</strong></li><li>若满足 $$r_i≥r_{2i}$$ 且 $$r_i≥r_{2i+1}$$，则称为<strong>大顶堆（Min heap）</strong></li></ul><p>通常将堆写成完全二叉树的形式，$$r_{2i}$$ 是 $$r_i$$ 的左孩子，$$r_{2i+1}$$ 是 $$r_i$$ 的右孩子</p><p>示例：</p><p>大顶堆 {98, 81, 49, 73, 36, 27, 40, 55, 64, 12} 可以写成：</p><img src="..\img\ep9\image-20230204144219110.png" alt="image-20230204144219110" style="zoom:25%;" /><h5 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h5><p>堆排序利用堆的特性对序列进行排序</p><p><strong>需要解决两个问题</strong>：</p><ol><li><p>如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</p><p>在输出堆顶元素之后，以堆中最后一个元素替代之，此时，对应二叉树中根结点的左右子树均为堆，仅需对根结点自上至下进行调整，使剩余元素成为一个新的堆</p><p>示例输出 98 后，将 12 提至堆顶，接着“对根结点自上至下进行调整”的过程如下：</p><img src="..\img\ep9\image-20230204195659231.png" alt="image-20230204195659231" style="zoom:25%;" /></li><li><p>如何由一个无序序列建堆？</p><p>对应二叉树中叶子结点均满足堆的定义，需从高度为 2 的非叶子结点到根结点，对以之为根的子树根据 1 中原则进行调整，使所有子树也均满足堆的定义</p><p>由无序序列 {40, 55, 49, 73, 12, 27, 98, 81, 64, 36} 建立示例中的大顶堆的过程如下：</p><img src="..\img\ep9\image-20230204211827144.png" alt="image-20230204211827144" style="zoom: 50%;" /></li></ol><p><strong>具体过程与树形选择排序类似</strong>：</p><ol><li>按关键字建大顶堆，得到关键字最大的记录</li><li><strong>将所得记录与此时堆中最后一个记录交换</strong>（无需辅助空间，降低空间复杂度），调整剩余记录成为一个新的堆，得到此时关键字最大的记录</li><li>重复执行 n-1 次 2</li></ol><h5 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 已知&#123;L.R[s],...,L.R[m]&#125;中，记录的关键字除L.R[s]外均满足大顶堆的特性，HeapAdjust函数对L.R[s]自上至下进行调整，使&#123;L.R[s],...,L.R[m]&#125;成为一个大顶堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>*s;j&lt;=m;j*=<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (j&lt;m&amp;&amp;L.R[j].key&lt;L.R[j+<span class="hljs-number">1</span>].key)<br>            ++j;<br>        <span class="hljs-keyword">if</span> (L.R[s].key&gt;=L.R[j].key)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">swap</span>(L.R[s],L.R[j]);<br>        s=j;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=L.length/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;--i)<br>        <span class="hljs-built_in">HeapAdjust</span>(L,i,L.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=L.length;i&gt;<span class="hljs-number">1</span>;--i) &#123;<br>        <span class="hljs-built_in">swap</span>(L.R[<span class="hljs-number">1</span>],L.R[i]);<br>        <span class="hljs-built_in">HeapAdjust</span>(L,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法评价-6"><a href="#算法评价-6" class="headerlink" title="算法评价"></a>算法评价</h5><ol><li><p>时间性能</p><ul><li><p>建堆比较次数：结论为 $$O(n)$$</p><p>调整比较次数：至多 $$2(⌊log_2(n-1)⌋+⌊log_2(n-2)⌋+…+⌊log_21⌋)&lt;2n⌊log_2n⌋$$</p><p>（对深度为 h 的堆，HeapAdjust 比较次数至多 2(h-1)；具有 n 个结点的完全二叉树的深度为 $$⌊log_2n⌋+1$$）</p><p>最好、最坏、平均时间复杂度：$$O(nlogn)$$（时间性能与记录序列实例无关）</p></li></ul></li><li><p>空间性能</p><ul><li>空间复杂度：$$O(1)$$</li></ul></li></ol><p>适用于在记录数量较大的序列中，求关键字最大或最小的几个记录</p><p><strong>稳定性</strong>：不稳定</p><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5 - 归并排序"></a>5 - 归并排序</h3><h5 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h5><p>基本思想：递归地将两个或两个以上有序子序列合并为一个有序序列，通常采用二路归并排序</p><p>示例：</p><p>待排序序列关键字：{25, 57, 48, 37, 12, 92, 86}</p><ul><li>第一趟结果：{[25, 57], [37, 48], [12, 92], [86]}</li><li>第二趟结果：{[25, 37, 48, 57], [12, 86, 92]}</li><li>第三趟结果：{[12, 25, 37, 48, 57, 86, 92]}</li></ul><h5 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// source: https://github.com/imxtx/algorithms</span><br><br><span class="hljs-comment">// 将位置相邻的有序子序列arr[left...mid]和arr[mid+1...right]合并为一个有序序列tempArr[left...right]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(RcdType arr[],RcdType tempArr[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">// 标记左半区第一个未排序的元素</span><br>    <span class="hljs-type">int</span> l_pos=left;<br>    <span class="hljs-comment">// 标记右半区第一个未排序的元素</span><br>    <span class="hljs-type">int</span> r_pos=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 临时数组元素的下标</span><br>    <span class="hljs-type">int</span> pos=left;<br><br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-keyword">while</span> (l_pos&lt;=mid&amp;&amp;r_pos&lt;=right) &#123;<br>        <span class="hljs-keyword">if</span> (arr[l_pos].key&lt;=arr[r_pos].key) <span class="hljs-comment">// 左半区第一个剩余元素更小</span><br>            tempArr[pos++]=arr[l_pos++];<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 右半区第一个剩余元素更小</span><br>            tempArr[pos++]=arr[r_pos++];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并左半区剩余的元素</span><br>    <span class="hljs-keyword">while</span> (l_pos&lt;=mid)<br>        tempArr[pos++]=arr[l_pos++];<br>    <span class="hljs-comment">// 合并右半区剩余的元素</span><br>    <span class="hljs-keyword">while</span> (r_pos&lt;=right)<br>        tempArr[pos++]=arr[r_pos++];<br><br>    <span class="hljs-comment">// 把临时数组中合并后的元素复制回原来的数组</span><br>    <span class="hljs-keyword">while</span> (left&lt;=right) &#123;<br>        arr[left]=tempArr[left];<br>        ++left;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 归并排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">msort</span><span class="hljs-params">(RcdType arr[],RcdType tempArr[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果只有一个元素，那么不需要继续划分</span><br>    <span class="hljs-comment">// 只有一个元素的区域，本身就是有序的，只需要被合并即可</span><br>    <span class="hljs-keyword">if</span> (left&lt;right) &#123;<br>        <span class="hljs-comment">// 找中间点</span><br>        <span class="hljs-type">int</span> mid=(left+right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 递归划分左半区</span><br>        <span class="hljs-built_in">msort</span>(arr,tempArr,left,mid);<br>        <span class="hljs-comment">// 递归划分右半区</span><br>        <span class="hljs-built_in">msort</span>(arr,tempArr,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-comment">// 合并已经排序的部分</span><br>        <span class="hljs-built_in">merge</span>(arr,tempArr,left,mid,right);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 归并排序入口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-comment">// 分配一个辅助数组</span><br>    RcdType tempArr[N];<br>    <span class="hljs-comment">// 调用实际的归并排序</span><br>    <span class="hljs-built_in">msort</span>(L.R,tempArr,<span class="hljs-number">1</span>,L.length);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法评价-7"><a href="#算法评价-7" class="headerlink" title="算法评价"></a>算法评价</h5><ol><li><p>时间性能</p><ul><li><p>每一趟归并的时间复杂度为 $$O(n)$$，共进行 $$⌈log_2n⌉$$ 趟</p><p>最好、最坏、平均时间复杂度：$$O(nlogn)$$（时间性能与记录序列实例无关）</p></li></ul></li><li><p>空间性能</p><ul><li>辅助数组：$$O(n)$$</li><li>递归栈：$$O(logn)$$</li><li>空间复杂度：$$O(n+logn)&#x3D;O(n)$$</li></ul></li></ol><p><strong>稳定性</strong>：稳定</p><h3 id="6-基数排序"><a href="#6-基数排序" class="headerlink" title="6 - 基数排序"></a>6 - 基数排序</h3><h4 id="多关键字记录的排序"><a href="#多关键字记录的排序" class="headerlink" title="多关键字记录的排序"></a>多关键字记录的排序</h4><p>记录序列对多关键字有序是指：序列中任意两个记录都满足<strong>字典有序</strong></p><h5 id="方法一：最高位优先（Most-Significant-Digit-first）"><a href="#方法一：最高位优先（Most-Significant-Digit-first）" class="headerlink" title="方法一：最高位优先（Most Significant Digit first）"></a>方法一：最高位优先（Most Significant Digit first）</h5><p><strong>具体示例</strong>：</p><p>对打乱的扑克牌进行排序，排序后扑克牌对以下两个关键字有序：</p><ul><li>花色：♣ &lt; ♦ &lt; ♥ &lt; ♠</li><li>面值：2 &lt; 3 &lt; … &lt; A</li><li>花色地位高于面值</li></ul><p>方法：先对所有扑克牌按花色进行排序，再分别对每批花色相同的扑克牌按面值进行排序</p><p><strong>抽象描述</strong>：</p><ol><li>先对所有记录，按地位最高的关键字进行排序</li><li>再分别对每批地位最高关键字相同的记录，按地位次高的关键字进行排序</li><li>再分别对每批地位最高关键字和地位次高关键字都相同的记录，按地位第三高的关键字进行排序</li><li>以此类推，直至按地位最低的关键字排序完毕</li></ol><h5 id="方法二：最低位优先（Last-Significant-Digit-first）"><a href="#方法二：最低位优先（Last-Significant-Digit-first）" class="headerlink" title="方法二：最低位优先（Last Significant Digit first）"></a>方法二：最低位优先（Last Significant Digit first）</h5><p><strong>具体示例</strong>：</p><p>对打乱的学生记录进行排序，排序后学生记录对以下三个关键字有序：</p><ul><li>系别：1 &lt; 2 &lt; 3 &lt; …</li><li>班别：1 &lt; 2 &lt; 3 &lt; …</li><li>学号：1 &lt; 2 &lt; 3 &lt; …</li><li>系别地位高于班别，班别地位高于学号</li></ul><p>方法：先对所有学生记录按学号进行排序，再对所有学生记录按班别进行<strong>稳定</strong>的排序，再对所有学生记录按系别进行<strong>稳定</strong>的排序</p><table><thead><tr><th align="center">学生记录</th><th align="center">3, 2, 30</th><th align="center">1, 2, 15</th><th align="center">3, 1, 20</th><th align="center">2, 3, 18</th><th align="center">2, 1, 20</th></tr></thead><tbody><tr><td align="center">按学号排序后的学生记录</td><td align="center">1, 2, 15</td><td align="center">2, 3, 18</td><td align="center">3, 1, 20</td><td align="center">2, 1, 20</td><td align="center">3, 2, 30</td></tr><tr><td align="center">按班别排序后的学生记录</td><td align="center">3, 1, 20</td><td align="center">2, 1, 20</td><td align="center">1, 2, 15</td><td align="center">3, 2, 30</td><td align="center">2, 3, 18</td></tr><tr><td align="center">按系别排序后的学生记录</td><td align="center">1, 2, 15</td><td align="center">2, 1, 20</td><td align="center">2, 3, 18</td><td align="center">3, 1, 20</td><td align="center">3, 2, 30</td></tr></tbody></table><p><strong>抽象描述</strong>：</p><ol><li>先对所有记录，按地位最低的关键字进行排序</li><li>再对所有记录，按地位次低的关键字进行<strong>稳定</strong>的排序</li><li>再对所有记录，按地位第三低的关键字进行<strong>稳定</strong>的排序</li><li>以此类推，直至按地位最高的关键字排序完毕</li></ol><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><h5 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h5><p>计数排序采用<strong>“桶”</strong>的思想，不需要比较关键字</p><p>示例：</p><p>待排序序列关键字：{2, 4, 1, 2, 5, 3, 4, 8, 7}</p><p>预处理 1：遍历待排序序列，构建桶数组</p><img src="..\img\ep9\image-20230226144250291.png" alt="image-20230226144250291" style="zoom:25%;" /><p>预处理 2：从小到大遍历桶数组，计算累计值数组</p><img src="..\img\ep9\image-20230226144348677.png" alt="image-20230226144348677" style="zoom:25%;" /><p><strong>从大到小</strong>遍历待排序序列（保持稳定性），借助累计值数组将记录放到结果数组对应位置，过程如下：</p><img src="..\img\ep9\image-20230227220224862.png" alt="image-20230227220224862" style="zoom: 50%;" /><h5 id="算法评价-8"><a href="#算法评价-8" class="headerlink" title="算法评价"></a>算法评价</h5><p>设待排序序列记录数为 n，桶数为 m</p><ol><li>时间复杂度：$$O(n+m)$$</li><li>空间复杂度：$$O(n+m)$$</li></ol><p>适用于关键字范围较小且已知的序列</p><p><strong>稳定性</strong>：稳定</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><h5 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h5><p>基数排序是用<strong>“多关键字记录的排序”</strong>和<strong>“计数排序”</strong>的思想实现“单关键字记录排序”的排序算法：</p><ul><li>数字型或字符串型的单关键字可以看作由多个数位或多个字符构成的多关键字→可以采用“多关键字记录的排序”中最低位优先的方法</li><li>其中每组关键字序列都范围较小且已知，且使用相同的桶数组（这些“桶”称为<strong>基数</strong>）→可以采用“计数排序”作为最低位优先方法中所需的稳定排序算法</li></ul><p>示例：</p><p>待排序序列关键字：{477, 241, 467, 005, 363, 081, 005}</p><p>设置基数为 0~9，先按关键字个位数进行计数排序，再按关键字十位数进行计数排序，最后按关键字百位数进行计数排序</p><h5 id="算法改进（采用链式存储结构减少辅助空间）"><a href="#算法改进（采用链式存储结构减少辅助空间）" class="headerlink" title="算法改进（采用链式存储结构减少辅助空间）"></a>算法改进（采用链式存储结构减少辅助空间）</h5><ol><li>待排序记录指针相连构成单链表</li><li>分配：按当前“关键字位”的值，将记录分配到代表各基数的链队列中</li><li>收集：按基数从小到大，将各队列首尾相连构成按当前“关键字位”有序的单链表</li><li>按“关键字位”从低到高，重复 2 和 3</li></ol><p>示例：</p><p>待排序序列关键字：{477, 241, 467, 005, 363, 081, <em><strong>005</strong></em>}</p><ul><li><p>个位：</p><img src="..\img\ep9\image-20230228235742495.png" alt="image-20230228235742495" style="zoom:25%;" /></li><li><p>十位：</p><img src="..\img\ep9\image-20230228235812314.png" alt="image-20230228235812314" style="zoom:25%;" /></li><li><p>百位：</p><img src="..\img\ep9\image-20230228235833655.png" alt="image-20230228235833655" style="zoom:25%;" /></li></ul><h5 id="算法评价（对改进的基数排序）"><a href="#算法评价（对改进的基数排序）" class="headerlink" title="算法评价（对改进的基数排序）"></a>算法评价（对改进的基数排序）</h5><p>设待排序序列记录数为 n，基数个数为 rd，分配收集趟数为 d</p><ol><li><p>时间复杂度：$$O(d(n+rd))$$（时间性能与记录序列实例无关）</p><p>其中，分配为 $$O(n)$$，收集为 $$O(rd)$$</p></li><li><p>空间复杂度：$$O(rd)$$</p></li></ol><p><strong>稳定性</strong>：稳定</p><h3 id="7-五类排序算法比较"><a href="#7-五类排序算法比较" class="headerlink" title="7 - 五类排序算法比较"></a>7 - 五类排序算法比较</h3><p><img src="/..%5Cimg%5Cep9%5Cimage-20230301151810289.png" alt="image-20230301151810289"></p><h4 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h4><ol><li>平均时间复杂度<ul><li>$$O(nlogn)$$：快速排序、堆排序、归并排序</li><li>$$O(n^2)$$：基于顺序查找的插入排序、冒泡排序、简单选择排序</li><li>特殊：希尔排序 $$O(n^{1.3-2})$$、基数排序 $$O(d(n+rd))$$</li></ul></li><li>时间性能与记录序列实例无关的排序算法：简单选择排序、堆排序、归并排序、基数排序</li><li>当待排序序列按关键字有序时，基于顺序查找的插入排序和冒泡排序的时间复杂度能达到 $$O(n)$$，快速排序的时间复杂度退化为 $$O(n^2)$$</li></ol><h4 id="空间性能"><a href="#空间性能" class="headerlink" title="空间性能"></a>空间性能</h4><ol><li>$$O(1)$$：基于顺序查找的插入排序、希尔排序、冒泡排序、简单选择排序、堆排序</li><li>基数排序 $$O(rd)$$</li><li>快速排序 $$O(logn)$$</li><li>归并排序 $$O(n)$$（空间性能最差）</li></ol><h2 id="完结撒花ヾ-´∀-ˋ-ﾉ"><a href="#完结撒花ヾ-´∀-ˋ-ﾉ" class="headerlink" title="完结撒花ヾ(*´∀ ˋ*)ﾉ"></a>完结撒花ヾ(*´∀ ˋ*)ﾉ</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找</title>
    <link href="/2023/03/02/%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/02/%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>数据结构课程笔记 ep8</p><span id="more"></span><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 - 概述"></a>1 - 概述</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ol><li><strong>查找表</strong>是由同一类型的记录构成的集合（松散）</li><li><strong>关键字</strong>是用来标识一个记录的某个数据项的值</li><li>若此关键字可唯一地标识一个记录，则称此关键字为<strong>主关键字</strong></li><li><strong>查找</strong>是指根据给定值，在查找表中确定一个其关键字等于给定值的记录</li></ol><h4 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h4><ol><li><strong>查询</strong>某个特定记录是否在查找表中</li><li><strong>检索</strong>某个特定记录的各种属性</li><li>向查找表中<strong>插入</strong>一个数据元素</li><li>从查找表中<strong>删除</strong>某个数据元素</li></ol><p>根据上述操作，查找表可分为：</p><ul><li><strong>静态查找表</strong>：仅作查询和检索操作</li><li><strong>动态查找表</strong>：表结构在查找过程中动态生成（若查询结果为在查找表中，则成功返回，否则插入该记录）</li></ul><p>由于查找表中的记录之间是较松散的集合关系，因此不便于查找。所以，为了提高查找效率，需要在查找表中的数据元素之间人为地附加某种确定的关系。</p><h3 id="2-静态查找表"><a href="#2-静态查找表" class="headerlink" title="2 - 静态查找表"></a>2 - 静态查找表</h3><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss">ADT StaticSearchTable &#123;<br>数据对象：<br>D是由同一类型的数据元素构成的集合，每个数据元素含有类型相同的关键字，可唯一标识该数据元素。<br>数据关系：<br>数据元素同属一个集合。<br>基本操作：<br><span class="hljs-built_in">Create</span>(&amp;ST,n)        <span class="hljs-comment">// 构造静态查找表ST（含有n个数据元素）</span><br><span class="hljs-built_in">Destroy</span>(&amp;ST)         <span class="hljs-comment">// 销毁静态查找表ST</span><br><span class="hljs-built_in">Search</span>(ST,key)       <span class="hljs-comment">// 在静态查找表ST中查询是否存在其关键字等于key的数据元素</span><br><span class="hljs-built_in">Traverse</span>(ST,visit()) <span class="hljs-comment">// 遍历静态查找表ST</span><br>&#125; ADT StaticSearchTable<br></code></pre></td></tr></table></figure><h4 id="顺序存储表示"><a href="#顺序存储表示" class="headerlink" title="顺序存储表示"></a>顺序存储表示</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    keyType key;<br>    <span class="hljs-comment">// 其它数据项</span><br>&#125; ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType* elem; <span class="hljs-comment">// 从1开始</span><br>    <span class="hljs-type">int</span> length;<br>&#125; SSTable;<br></code></pre></td></tr></table></figure><h4 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="(1) 顺序查找"></a>(1) 顺序查找</h4><p>给定值与数据元素的关键字逐一比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 从前往后查</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(SSTable ST,keyType key)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;=ST.length;i++)<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">compare</span>(ST.elem[i].key,key))<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (i==ST.length+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">// 从后往前查</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(SSTable ST,keyType key)</span> </span>&#123;<br>    ST.elem[<span class="hljs-number">0</span>].key=key; <span class="hljs-comment">// 监视哨</span><br>    <span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=ST.length;!<span class="hljs-built_in">compare</span>(ST.elem[i].key,key);i--);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-comment">// ST.elem[0]起到了监视哨的作用，避免在查找过程中每一步都要判断整个表是否查找完毕</span><br><span class="hljs-comment">// 这样改进使得在查找表的长度大于1000时，查找所需的平均时间减少一半</span><br></code></pre></td></tr></table></figure><h5 id="时间性能分析"><a href="#时间性能分析" class="headerlink" title="时间性能分析"></a>时间性能分析</h5><p>查找不成功时的比较次数：n（若表中数据元素有序，则查找不成功时不用与整张表比较）</p><p>查找成功时的比较次数：取决于查找结果在表中的位置，利用<strong>平均查找长度</strong>（Average Search Length）分析：</p><p>$$ASL&#x3D;\sum_{i&#x3D;1}^nP_iC_i&#x3D;\frac1n\sum_{i&#x3D;1}^n(n-i+1)&#x3D;\frac{n+1}2$$（$$P_i$$ 为结果是第 i 个数据元素的概率，$$C_i$$ 为查到第 i 个数据元素时需要比较的次数，在等概率查找的情况下 $$P_i&#x3D;\frac1n$$）</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点：算法简单，适用面广，不要求有序，如果要插入可插在表尾</li><li>缺点：平均查找长度较大，表长很大时效率较低</li></ul><h4 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="(2) 二分查找"></a>(2) 二分查找</h4><p><strong>在表中数据元素按关键字有序的前提下</strong>，给定值不必与数据元素逐一比较，而采用二分查找（折半查找）</p><p>算法描述：设待查元素所在区域的下界为 low，上界为 high，则中间位置 mid &#x3D; (low + high) &#x2F; 2，先与中间位置数据元素的关键字比较</p><ul><li>若中间位置数据元素的关键字等于给定值，则查找成功</li><li>若中间位置数据元素的关键字大于给定值，则在区域 [low, mid-1] 内进行二分查找</li><li>若中间位置数据元素的关键字小于给定值，则在区域 [mid+1, high] 内进行二分查找</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(SSTable ST,keyType key)</span> </span>&#123;<br>    <span class="hljs-type">int</span> low=<span class="hljs-number">1</span>,high=ST.length;<br>    <span class="hljs-keyword">while</span> (low&lt;=high) &#123;<br>        <span class="hljs-type">int</span> mid=(low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (ST.elem[mid].key==key)<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ST.elem[mid].key&gt;key)<br>            high=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>            low=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="时间性能分析-1"><a href="#时间性能分析-1" class="headerlink" title="时间性能分析"></a>时间性能分析</h5><p>举例：</p><table><thead><tr><th align="left">$$i$$</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td align="left">$$C_i$$</td><td>3</td><td>4</td><td>2</td><td>3</td><td>4</td><td>1</td><td>3</td><td>4</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><p>上述查找过程可用二叉树（判定树）来描述：</p><img src="..\img\ep8\image-20221207232612762.png" alt="image-20221207232612762" style="zoom:25%;" /><p>查找不成功时的比较次数：$$⌊log_2n⌋$$ 或 $$⌊log_2n⌋+1$$（判定树的深度）</p><p>查找成功时的比较次数：取决于从根结点到查找成功处结点的路径上结点的个数，不超过 $$⌊log_2n⌋+1$$ （判定树的深度），具体分析如下：</p><p>假设 $$n&#x3D;2^h-1$$，则判定树为深度为 h 的满二叉树，层次为 k 的结点有 $$2^k-1$$ 个，则在等概率查找 $$P_i&#x3D;\frac1n$$ 的情况下：$$ASL&#x3D;\frac1n\sum_{i&#x3D;1}^nC_i&#x3D;\frac1n[\sum_{k&#x3D;1}^hk*2^{k-1}]&#x3D;\frac{n+1}nlog_2(n+1)-1$$，当 n 较大时，$$ASL&#x3D;log_2(n+1)-1$$</p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点：效率高</li><li>缺点：需要预先排序，只适合有序的顺序表，不能是链表</li></ul><h4 id="3-分块查找"><a href="#3-分块查找" class="headerlink" title="(3) 分块查找"></a>(3) 分块查找</h4><p>n 个数据元素被分成 m 块，第一块中任一元素的关键字都小于第二块中任一元素的关键字，第二块中任一元素的关键字都小于第三块中任一元素的关键字，以此类推，而每一块中元素的关键字不一定是有序的，此时采用分块查找</p><p>算法描述：“缩小区间”的思想</p><ol><li>抽出各块所含数据元素的最大关键字构成一个索引表</li><li>查找分两步进行：<ul><li>对索引表进行二分查找或顺序查找，确定待查记录在哪一块</li><li>对已确定的那一块进行顺序查找</li></ul></li></ol><p>索引表按关键字有序，包含：</p><ol><li>该块所含数据元素的最大关键字</li><li>指示该块第一个数据元素在静态查找表中位置的指针</li></ol><h5 id="时间性能分析-2"><a href="#时间性能分析-2" class="headerlink" title="时间性能分析"></a>时间性能分析</h5><p>ASL &#x3D; 查找索引表的平均查找长度 + 查找一个记录块的平均查找长度</p><p>关注最优性能：</p><p>假设长度为 n 的表平均分成 b 块，每块含有 s 个记录，即 b &#x3D; ⌈n&#x2F;s⌉，每条记录的查找概率相等，则每块的查找概率为 1&#x2F;b，块中每个记录的查找概率为 1&#x2F;s，采用<strong>顺序查找索引表和顺序查找被确定的块</strong>的方法，平均查找长度为：$$ASL&#x3D;\frac{b+1}2+\frac{s+1}2&#x3D;\frac{\frac{n}s+s}2+1$$，当 s 取 $$\sqrt{n}$$ 时，ASL 取最小值 $$\sqrt{n}+1$$</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h5 id="三种查找方法比较"><a href="#三种查找方法比较" class="headerlink" title="三种查找方法比较"></a>三种查找方法比较</h5><table><thead><tr><th align="center"></th><th align="center">顺序查找</th><th align="center">二分查找</th><th align="center">分块查找</th></tr></thead><tbody><tr><td align="center">等概率下ASL</td><td align="center">最大</td><td align="center">最小</td><td align="center">适中</td></tr><tr><td align="center">记录是否有序</td><td align="center">有序无序均可</td><td align="center"><strong>仅适用于有序</strong></td><td align="center">记录逐段有序</td></tr><tr><td align="center">表的存储结构</td><td align="center">顺序链式均可</td><td align="center"><strong>仅适用于顺序</strong></td><td align="center">顺序链式均可</td></tr></tbody></table><h5 id="四种查找表增删查操作时间性能比较"><a href="#四种查找表增删查操作时间性能比较" class="headerlink" title="四种查找表增删查操作时间性能比较"></a>四种查找表增删查操作时间性能比较</h5><table><thead><tr><th align="center"></th><th align="center">查找</th><th align="center">插入</th><th align="center">删除</th></tr></thead><tbody><tr><td align="center">无序顺序表</td><td align="center">O(n)</td><td align="center">O(1)（无需查找）</td><td align="center">O(n)</td></tr><tr><td align="center">无序链表</td><td align="center">O(n)</td><td align="center"><strong>O(1)（无需查找）</strong></td><td align="center"><strong>O(1)</strong></td></tr><tr><td align="center">有序顺序表</td><td align="center"><strong>O(logn)</strong></td><td align="center">O(n)（需查找）</td><td align="center">O(n)</td></tr><tr><td align="center">有序链表</td><td align="center">O(n)</td><td align="center">O(1)（需查找）</td><td align="center">O(1)</td></tr></tbody></table><p>从时间性能上看：频繁查找，使用有序顺序表；频繁增删，使用无序链表</p><h3 id="3-动态查找表"><a href="#3-动态查找表" class="headerlink" title="3 - 动态查找表"></a>3 - 动态查找表</h3><h4 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">ADT DynamicSearchTable &#123;<br>数据对象：<br>D是由同一类型的数据元素构成的集合，每个数据元素含有类型相同的关键字，可唯一标识该数据元素。<br>数据关系：<br>数据元素同属一个集合。<br>基本操作：<br><span class="hljs-built_in">Create</span>(&amp;DT)          <span class="hljs-comment">// 构造空的动态查找表DT</span><br><span class="hljs-built_in">Destroy</span>(&amp;DT)         <span class="hljs-comment">// 销毁动态查找表DT</span><br><span class="hljs-built_in">Search</span>(DT,key)       <span class="hljs-comment">// 在动态查找表DT中查询是否存在其关键字等于key的数据元素</span><br><span class="hljs-built_in">Insert</span>(&amp;DT,e)        <span class="hljs-comment">// 若DT中不存在其关键字等于e.key的数据元素，则插入e到DT</span><br><span class="hljs-built_in">Delete</span>(&amp;DT,key)      <span class="hljs-comment">// 若DT中存在其关键字等于key的数据元素，则删除之</span><br><span class="hljs-built_in">Traverse</span>(DT,visit()) <span class="hljs-comment">// 遍历动态查找表DT</span><br>&#125; ADT DynamicSearchTable<br></code></pre></td></tr></table></figure><h4 id="1-二叉搜索树（BST）"><a href="#1-二叉搜索树（BST）" class="headerlink" title="(1) 二叉搜索树（BST）"></a>(1) 二叉搜索树（BST）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ol><li>二叉搜索树或是一棵空树，或是具有如下特性的二叉树：<ul><li>若左子树不空，则左子树上所有结点的值均小于根结点的值</li><li>若右子树不空，则右子树上所有结点的值均大于根结点的值</li><li>它的左、右子树也都分别是二叉搜索树（递归定义）</li></ul></li><li>中根序遍历二叉搜索树，可以得到递增序列，所以，一个无序序列可以通过构造一棵二叉搜索树变成一个有序序列，构造过程即为排序过程，故<strong>二叉搜索树又称二叉排序树</strong></li><li>相应地，可以构造递减序列的二叉搜索树</li></ol><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><p>二叉链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> &#123;<br>    T data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild,*rchild;<br>&#125; BiTNode,*BiTree;<br></code></pre></td></tr></table></figure><h5 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h5><p>若二叉搜索树为空，则查找失败；否则</p><ul><li>若给定值等于根结点的关键字，则查找成功</li><li>若给定值小于根结点的关键字，则继续在左子树上进行查找</li><li>若给定值大于根结点的关键字，则继续在右子树上进行查找</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在根结点指针T所指二叉搜索树中递归地查找其关键字等于key的数据元素。若查找成功，则返</span><br><span class="hljs-comment"> * 回指向该数据元素结点的指针p，并返回函数值true；若查找失败，则返回指向查找路径上访</span><br><span class="hljs-comment"> * 问的最后一个结点的指针p，并返回函数值false。指针f指向当前访问结点的双亲。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 三个参数：T（初始值指向根结点），key，f（初始值为NULL）</span><br><span class="hljs-comment"> * 两个返回值：状态值，p</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Search</span><span class="hljs-params">(BiTree T,keyType key,BiTree f,BiTree &amp;p)</span> </span>&#123;<br>    <span class="hljs-comment">// 查找失败</span><br>    <span class="hljs-keyword">if</span> (!T) &#123;<br>        p=f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-comment">// 查找成功</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key==T-&gt;data.key) &#123;<br>        p=T;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 继续在左子树上进行查找</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key&lt;T-&gt;data.key) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Search</span>(T-&gt;lchild,key,T,p))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 继续在右子树上进行查找</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Search</span>(T-&gt;rchild,key,T,p))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h5><p>插入操作在查找不成功时才进行，新插入的结点必为一个新的叶子结点（若二叉搜索树为空树，则新插入的结点为根结点），显然插入操作后的二叉树仍然保持二叉搜索树的特性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若二叉搜索树T中不存在其关键字等于e.key的数据元素，则插入数据域为e的结点，并返回</span><br><span class="hljs-comment"> * true，否则返回false。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(BiTree &amp;T,T e)</span> </span>&#123;<br>    BiTree p;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Search</span>(T,e.key,<span class="hljs-literal">NULL</span>,p)) &#123;<br>        BiTree s=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br>        s-&gt;data=e;<br>        s-&gt;lchild=s-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (!p)<br>            T=s; <span class="hljs-comment">// 根结点</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.key&lt;p-&gt;data.key)<br>            p-&gt;lchild=s; <span class="hljs-comment">// p-&gt;lchild必定为空，此时插入*s</span><br>        <span class="hljs-keyword">else</span><br>            p-&gt;rchild=s; <span class="hljs-comment">// p-&gt;rchild必定为空，此时插入*s</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h5><p>和插入相反，删除操作在查找成功时进行，并且要求删除操作后的二叉树仍然保持二叉搜索树的特性，被删除的结点有三种情况：</p><ul><li>为叶子结点，则将其双亲结点中相应指针域改为空</li><li>为只有左子树或只有右子树的结点，则将其双亲结点中相应指针域改为“指向被删除结点的左子树或右子树”</li><li>为既有左子树又有右子树的结点，则先将其数据域改为其<strong>中序前驱结点</strong>数据域，再删除其中序前驱结点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若二叉搜索树T中存在其关键字等于key的数据元素，则删除该数据元素结点，并返回true，</span><br><span class="hljs-comment"> * 否则返回false。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Search</span><span class="hljs-params">(BiTree T,<span class="hljs-type">int</span> key,BiTree &amp;f,BiTree &amp;p)</span> </span>&#123; <span class="hljs-comment">// f需要引用传递，要为Delete修改原先的Search</span><br>    <span class="hljs-keyword">if</span> (!T) &#123;<br>        p=f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key==T-&gt;data) &#123;<br>        p=T;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key&lt;T-&gt;data) &#123;<br>    f=T; <span class="hljs-comment">// 更新f</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Search</span>(T-&gt;lchild,key,f,p))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    f=T; <span class="hljs-comment">// 更新f</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Search</span>(T-&gt;rchild,key,f,p))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Delete</span><span class="hljs-params">(BiTree &amp;T,keyType key)</span> </span>&#123;<br>    BiTree f=<span class="hljs-literal">NULL</span>,p;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Search</span>(T,key,f,p)) &#123;<br>        <span class="hljs-keyword">if</span> (!p-&gt;lchild&amp;&amp;!p-&gt;rchild) &#123;<br>            (f-&gt;lchild==p?f-&gt;lchild:f-&gt;rchild)=<span class="hljs-literal">NULL</span>;<br>            <span class="hljs-built_in">free</span>(p);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;lchild&amp;&amp;!p-&gt;rchild) &#123;<br>            (f-&gt;lchild==p?f-&gt;lchild:f-&gt;rchild)=p-&gt;lchild;<br>            <span class="hljs-built_in">free</span>(p);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!p-&gt;lchild&amp;&amp;p-&gt;rchild) &#123;<br>            (f-&gt;lchild==p?f-&gt;lchild:f-&gt;rchild)=p-&gt;rchild;<br>            <span class="hljs-built_in">free</span>(p);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            BiTree q=p,s=p-&gt;lchild;<br>            <span class="hljs-keyword">while</span> (s-&gt;rchild) &#123; <span class="hljs-comment">// 先转左，再一路向右</span><br>                q=s;<br>                s=s-&gt;rchild;<br>            &#125;<br>            p-&gt;data=s-&gt;data;<br>            <span class="hljs-keyword">if</span> (q!=p)<br>                q-&gt;rchild=s-&gt;lchild;<br>            <span class="hljs-keyword">else</span><br>                q-&gt;lchild=s-&gt;lchild; <span class="hljs-comment">// q==p表明p的左孩子s没有右孩子，s就是p的中序前驱</span><br>            <span class="hljs-built_in">free</span>(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="时间性能分析-3"><a href="#时间性能分析-3" class="headerlink" title="时间性能分析"></a>时间性能分析</h5><p>由相同的 n 个数据元素按照不同顺序构造所得的二叉搜索树不同，其平均查找长度也不同，例如：左图 ASL &#x3D; (1+2+3+4+5)&#x2F;5 &#x3D; 3，右图 ASL &#x3D; (1+2+2+3+3)&#x2F;5 &#x3D; 2.2</p><img src="..\img\ep8\image-20221210230543929.png" alt="image-20221210230543929" style="zoom:25%;" /><p>结论：$$ASL&#x3D;2\frac{n+1}nlogn+C$$</p><p>在进行插入和删除操作时，无需移动其它结点，仅需修改某个结点的指针，因此，对于需要经常插入和删除记录的有序表，采用二叉搜索树的数据结构更为合适</p><h4 id="2-平衡二叉树（AVL-树）"><a href="#2-平衡二叉树（AVL-树）" class="headerlink" title="(2) 平衡二叉树（AVL 树）"></a>(2) 平衡二叉树（AVL 树）</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><ol><li>平衡二叉树或是一棵空树，或是具有如下特性的<strong>二叉搜索树</strong>：<ul><li>左子树和右子树的高度之差（平衡因子）的绝对值不超过 1</li><li>它的左、右子树也都分别是平衡二叉树（递归定义）</li></ul></li><li>平衡二叉树的作用是：避免二叉搜索树退化为链表，提高其查找时间性能</li></ol><h5 id="插入算法-1"><a href="#插入算法-1" class="headerlink" title="插入算法"></a>插入算法</h5><p>先插入，再对<strong>最小不平衡子树</strong>进行调整</p><p>最小不平衡子树有四种类型，对应四种操作：</p><ul><li><p>类型 1：（LL 型）新结点插入在根结点<strong>左子树的左子树</strong>上，导致根结点的平衡因子由 1 变为 2</p><p>操作 1：对根结点左子树的根结点进行“右旋”</p><img src="..\img\ep8\image-20221217124819377.png" alt="image-20221217124819377" style="zoom: 25%;" /></li><li><p>类型 2：（RR 型）新结点插入在根结点<strong>右子树的右子树</strong>上，导致根结点的平衡因子由 -1 变为 -2</p><p>操作 2：对根结点右子树的根结点进行“左旋”</p><img src="..\img\ep8\image-20221217124924333.png" alt="image-20221217124924333" style="zoom:25%;" /></li><li><p>类型 3：（LR 型）新结点插入在根结点<strong>左子树的右子树</strong>上，导致根结点的平衡因子由 1 变为 2</p><p>操作 3：先对根结点左子树的右子树的根结点进行“左旋”，再（同操作 1）对根结点左子树的根结点进行“右旋”</p><img src="..\img\ep8\image-20221217133539798.png" alt="image-20221217133539798" style="zoom: 33%;" /></li><li><p>类型 4：（RL 型）新结点插入在根结点<strong>右子树的左子树</strong>上，导致根结点的平衡因子由 -1 变为 -2</p><p>操作 4：先对根结点右子树的左子树的根结点进行“右旋”，再（同操作 2）对根结点右子树的根结点进行“左旋”</p><img src="..\img\ep8\image-20221217133647339.png" alt="image-20221217133647339" style="zoom:33%;" /></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// source: https://github.com/imxtx/algorithms</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 树结点定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> *left;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> *right;<br>    <span class="hljs-type">int</span> height;<br>&#125; Node;<br><br><span class="hljs-comment">// 辅助函数：比大小</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-comment">// 辅助函数：计算树的高度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(root-&gt;left), <span class="hljs-built_in">height</span>(root-&gt;right));<br>&#125;<br><br><span class="hljs-comment">// 辅助函数：创建新结点</span><br><span class="hljs-function">Node *<span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *node = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Node));<br>    node-&gt;key = key;<br>    node-&gt;left = <span class="hljs-literal">NULL</span>;<br>    node-&gt;right = <span class="hljs-literal">NULL</span>;<br>    node-&gt;height = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里node-&gt;height可以定义为任意值</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 辅助函数：获得结点的平衡因子</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getBalanceFactor</span><span class="hljs-params">(Node *node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">height</span>(node-&gt;left) - <span class="hljs-built_in">height</span>(node-&gt;right);<br>&#125;<br><br><span class="hljs-comment">// 右旋</span><br><span class="hljs-function">Node *<span class="hljs-title">rightRotate</span><span class="hljs-params">(Node *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* 树结构示意图：</span><br><span class="hljs-comment">                y</span><br><span class="hljs-comment">               / \</span><br><span class="hljs-comment">              x   O</span><br><span class="hljs-comment">             / \</span><br><span class="hljs-comment">            O   O</span><br><span class="hljs-comment">    */</span><br>    Node *x = y-&gt;left;<br>    Node *xr = x-&gt;right;<br>    <span class="hljs-comment">// 旋转</span><br>    x-&gt;right = y;<br>    y-&gt;left = xr;<br>    <span class="hljs-comment">// 更新结点的高度</span><br>    x-&gt;height = <span class="hljs-built_in">height</span>(x);<br>    y-&gt;height = <span class="hljs-built_in">height</span>(y);<br>    <span class="hljs-comment">// 返回旋转后的根结点</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">// 左旋</span><br><span class="hljs-function">Node *<span class="hljs-title">leftRotate</span><span class="hljs-params">(Node *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* 树结构示意图：</span><br><span class="hljs-comment">                y</span><br><span class="hljs-comment">               / \</span><br><span class="hljs-comment">              O   x</span><br><span class="hljs-comment">                 / \</span><br><span class="hljs-comment">                O   O</span><br><span class="hljs-comment">    */</span><br>    Node *x = y-&gt;right;<br>    Node *xl = x-&gt;left;<br>    <span class="hljs-comment">// 旋转</span><br>    x-&gt;left = y;<br>    y-&gt;right = xl;<br>    <span class="hljs-comment">// 更新结点的高度</span><br>    x-&gt;height = <span class="hljs-built_in">height</span>(x);<br>    y-&gt;height = <span class="hljs-built_in">height</span>(y);<br>    <span class="hljs-comment">// 返回旋转后的根结点</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @brief 向以node为根结点的树中插入key</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param node 根结点</span><br><span class="hljs-comment"> * @param key 插入值</span><br><span class="hljs-comment"> * @return Node* 插入后该树的新的根结点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Node *<span class="hljs-title">insert</span><span class="hljs-params">(Node *node, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 按照BST的方法在叶结点上插入新值</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">newNode</span>(key);<br>    <span class="hljs-keyword">if</span> (key &lt; node-&gt;key)<br>        node-&gt;left = <span class="hljs-built_in">insert</span>(node-&gt;left, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; node-&gt;key)<br>        node-&gt;right = <span class="hljs-built_in">insert</span>(node-&gt;right, key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> node;<br><br>    <span class="hljs-comment">// 2. 更新插入路径上每棵子树的高度</span><br>    node-&gt;height = <span class="hljs-built_in">height</span>(node);<br><br>    <span class="hljs-comment">// 3. 计算平衡因子，不平衡则需要调整</span><br>    <span class="hljs-type">int</span> bf = <span class="hljs-built_in">getBalanceFactor</span>(node);<br><br>    <span class="hljs-comment">// LL型不平衡</span><br>    <span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>    <span class="hljs-comment">// RR型不平衡</span><br>    <span class="hljs-keyword">if</span> (bf &lt; <span class="hljs-number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>    <span class="hljs-comment">// LR型不平衡</span><br>    <span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key)<br>    &#123;<br>        node-&gt;left = <span class="hljs-built_in">leftRotate</span>(node-&gt;left);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>    &#125;<br>    <span class="hljs-comment">// RL型不平衡</span><br>    <span class="hljs-keyword">if</span> (bf &lt; <span class="hljs-number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key)<br>    &#123;<br>        node-&gt;right = <span class="hljs-built_in">rightRotate</span>(node-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果是平衡的直接返回根结点</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 辅助函数：输出树的先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, root-&gt;key);<br>        <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>        <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *root = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* 测试，最终树结构应该如下图所示：</span><br><span class="hljs-comment">            30</span><br><span class="hljs-comment">           /  \</span><br><span class="hljs-comment">         20   40</span><br><span class="hljs-comment">        /  \     \</span><br><span class="hljs-comment">       10  25    50</span><br><span class="hljs-comment">    */</span><br>    root = <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">10</span>);<br>    root = <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">20</span>);<br>    root = <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">30</span>);<br>    root = <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">40</span>);<br>    root = <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">50</span>);<br>    root = <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">25</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Preorder traversal of the constructed AVL tree is \n&quot;</span>);<br>    <span class="hljs-built_in">preOrder</span>(root);<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="时间性能分析-4"><a href="#时间性能分析-4" class="headerlink" title="时间性能分析"></a>时间性能分析</h5><p>平衡二叉树优化了二叉搜索树的查找时间性能：与二叉搜索树相同，在平衡二叉树上进行查找时，和给定值进行比较的关键字的个数不超过平衡二叉树的深度；经过优化，含有 n 个结点的平衡二叉树能达到的最大深度约为 log n，因此最坏情况下查找长度也仅仅约为 log n</p><p>平衡二叉树虽然查找时间性能能够始终保持 O(log n)，但是为了保持平衡，在插入和删除时导致太多调整树结构的操作</p><h4 id="3-B-树"><a href="#3-B-树" class="headerlink" title="(3) B 树"></a>(3) B 树</h4><p><a href="https://www.youtube.com/watch?v=aZjYr87r1b8">B Trees and B+ Trees. How they are useful in Databases - YouTube</a></p><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><ol><li><p>一棵 m 阶 B 树是具有如下特性的 m 叉树：</p><ul><li>每个结点<strong>至多</strong>有 m 棵子树（<strong>至多</strong>有 m-1 个关键字）</li><li>根结点<strong>至少</strong>有 2 棵子树（<strong>至少</strong>有 1 个关键字）或根结点为叶子结点（此时为空树）</li><li>其他结点<strong>至少</strong>有 ⌈m&#x2F;2⌉ 棵子树（<strong>至少</strong>有 ⌈m&#x2F;2⌉-1 个关键字）或其为叶子结点</li><li>所有的非叶子结点包含以下信息：(n, A0, K1, A1, K2, A2, …, Kn, An)，其中：<ul><li>n 为关键字个数：⌈m&#x2F;2⌉-1 ≤ n ≤ m-1（根结点：1 ≤ n ≤ m-1）</li><li>Ki (i &#x3D; 1, 2, …, n) 为关键字：K1 &lt; K2 &lt; … &lt; Kn</li><li>Ai (i &#x3D; 0, 1, …, n) 为指向子树根结点的指针：指针 Ai-1 所指子树中所有结点的关键字均小于 Ki (i &#x3D; 1, 2, …, n)，指针 An 所指子树中所有结点的关键字均大于 Kn</li><li>可能还有指向记录的指针 Di (i &#x3D; 1, 2, …, n)</li></ul></li><li>所有的叶子结点出现在同一层次上，并且不带信息（可以看作是查找失败的结点）</li></ul><p>例如：下图为一棵 4 阶 B 树，深度为 3（不包括失败结点），根结点 1 ≤ n ≤ 3，其他结点 1 ≤ n ≤ 3</p><img src="..\img\ep8\image-20221222124509587.png" alt="image-20221222124509587" style="zoom:25%;" /></li><li><p>B 树是一种平衡的多路查找树</p></li></ol><h5 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 10 <span class="hljs-comment">// B树的阶</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BTNode</span> &#123;<br>    <span class="hljs-type">int</span> keynum;              <span class="hljs-comment">// 关键字个数</span><br>keyType key[M+<span class="hljs-number">1</span>];        <span class="hljs-comment">// 关键字向量（0号单元不用，开多一个单元插入用）</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BTNode</span>* ptr[M+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 指向子树根结点的指针向量</span><br>    T* recptr[M+<span class="hljs-number">1</span>];          <span class="hljs-comment">// 指向记录的指针向量（0号单元不用）</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BTNode</span>* parent;   <span class="hljs-comment">// 指向双亲结点的指针（插入用）</span><br>&#125; BTNode,*BTree;<br></code></pre></td></tr></table></figure><h5 id="查找算法-1"><a href="#查找算法-1" class="headerlink" title="查找算法"></a>查找算法</h5><p>两个操作交叉进行：</p><ul><li>从根结点出发，沿指针查找结点</li><li>在结点内顺序（或折半）查找关键字</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在m阶B树T中查找关键字key，返回查找结果(tag,p,i)。若查找成功，则特征值tag为1，指</span><br><span class="hljs-comment"> * 针p所指结点中第i个关键字等于key；否则特征值tag为0，关键字key应插入在指针p所指结</span><br><span class="hljs-comment"> * 点中第i个关键字和第i+1个关键字之间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-type">int</span> tag;<br>    BTree p;<br><span class="hljs-type">int</span> i;<br>    <br>    <span class="hljs-built_in">Result</span>(<span class="hljs-type">int</span> tmp_tag,BTree tmp_p,<span class="hljs-type">int</span> tmp_i):<br>    <span class="hljs-built_in">tag</span>(tmp_tag),<span class="hljs-built_in">p</span>(tmp_p),<span class="hljs-built_in">i</span>(tmp_i) &#123;&#125;<br>    <span class="hljs-built_in">Result</span>(<span class="hljs-type">const</span> Result &amp;result):<br>    <span class="hljs-built_in">tag</span>(result.tag),<span class="hljs-built_in">p</span>(result.p),<span class="hljs-built_in">i</span>(result.i) &#123;&#125;<br>&#125; Result;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(BTree p,keyType key)</span> </span>&#123;<br>    <span class="hljs-type">int</span> low=<span class="hljs-number">1</span>,high=p-&gt;keynum,mid;<br>    <span class="hljs-keyword">while</span> (low&lt;=high) &#123;<br>        mid=(low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (p-&gt;key[mid]==key)<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;key[mid]&gt;key)<br>            high=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>            low=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (p-&gt;key[mid]&lt;key?mid:mid<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function">Result <span class="hljs-title">SearchBTree</span><span class="hljs-params">(BTree T,keyType key)</span> </span>&#123;<br>    BTree p=T,q=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> found=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p&amp;&amp;!found) &#123;<br>        i=<span class="hljs-built_in">Search</span>(p,key);<br>        <span class="hljs-keyword">if</span> (p-&gt;key[i]==key)<br>            found=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            q=p;<br>            p=p-&gt;ptr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (found)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Result</span>(<span class="hljs-number">1</span>,p,i);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Result</span>(<span class="hljs-number">0</span>,q,i);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入算法-2"><a href="#插入算法-2" class="headerlink" title="插入算法"></a>插入算法</h5><p>插入操作在查找不成功时才进行，关键字插入的位置必定在最下层的非叶子结点（若 B 树为空树，则用新插入的关键字创建根结点），插入后有两种情况：</p><ul><li>若该结点的关键字个数 n&lt;m，则不修改指针</li><li>若该结点的关键字个数 n&#x3D;m，则进行“分裂”：（令 s &#x3D; ⌈m&#x2F;2⌉）<ol><li>原结点保留有：(A0, K1, …, Ks-1, As-1)，建新结点：(As, Ks+1, …, Kn, An)</li><li>将 Ks 递归地插入到双亲结点中，若双亲为空，则创建新的根结点</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若m阶B树T中不存在关键字key，则插入key，并返回true，否则返回false。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">BTree <span class="hljs-title">Insert</span><span class="hljs-params">(BTree &amp;p,<span class="hljs-type">int</span> i,keyType key,T* record,BTree child,BTree new_child,BTree &amp;T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) &#123; <span class="hljs-comment">// 创建新的根结点</span><br>        p=(BTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BTNode));<br>        p-&gt;keynum=<span class="hljs-number">1</span>;<br>        p-&gt;key[<span class="hljs-number">1</span>]=key;<br>        p-&gt;ptr[<span class="hljs-number">0</span>]=child,p-&gt;ptr[<span class="hljs-number">1</span>]=new_child;<br>        p-&gt;recptr[<span class="hljs-number">1</span>]=record;<br>        p-&gt;parent=<span class="hljs-literal">NULL</span>;<br>        T=p; <span class="hljs-comment">// 标识新的根结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=p-&gt;keynum;j&gt;=i+<span class="hljs-number">1</span>;--j) &#123;<br>        p-&gt;key[j+<span class="hljs-number">1</span>]=p-&gt;key[j];<br>        p-&gt;ptr[j+<span class="hljs-number">1</span>]=p-&gt;ptr[j];<br>        p-&gt;recptr[j+<span class="hljs-number">1</span>]=p-&gt;recptr[j+<span class="hljs-number">1</span>];<br>    &#125;<br>    ++p-&gt;keynum;<br>    p-&gt;key[i+<span class="hljs-number">1</span>]=key;<br>    p-&gt;ptr[i+<span class="hljs-number">1</span>]=new_child;<br>    p-&gt;recptr[i+<span class="hljs-number">1</span>]=record;<br>    <span class="hljs-keyword">if</span> (p-&gt;keynum==M) &#123; <span class="hljs-comment">// 分裂</span><br>        <span class="hljs-type">int</span> s=M%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>?M/<span class="hljs-number">2</span>:M/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        BTree q=(BTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BTNode));<br>        p-&gt;keynum=s<span class="hljs-number">-1</span>;<br>        q-&gt;keynum=M<span class="hljs-number">-1</span>-p-&gt;keynum;<br>        q-&gt;ptr[<span class="hljs-number">0</span>]=p-&gt;ptr[s];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=q-&gt;keynum;++j) &#123;<br>            q-&gt;key[j]=p-&gt;key[s+j];<br>        q-&gt;ptr[j]=p-&gt;ptr[s+j];<br>        q-&gt;recptr[j]=p-&gt;recptr[s+j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p-&gt;parent)<br>        i=<span class="hljs-built_in">Search</span>(p-&gt;parent,p-&gt;key[s]);<br>        BTree t=<span class="hljs-built_in">Insert</span>(p-&gt;parent,i,p-&gt;key[s],p-&gt;recptr[s],p,q,T); <span class="hljs-comment">// 函数Insert第一个参数p为引用，目的是给p-&gt;parent赋值</span><br>        q-&gt;parent=t?t:p-&gt;parent;<br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertBTree</span><span class="hljs-params">(BTree &amp;T,keyType key,T* record)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!T) &#123; <span class="hljs-comment">// 创建根结点</span><br>        T=(BTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BTNode));<br>        T-&gt;keynum=<span class="hljs-number">1</span>;<br>        T-&gt;key[<span class="hljs-number">1</span>]=key;<br>        T-&gt;ptr[<span class="hljs-number">0</span>]=<span class="hljs-literal">NULL</span>,T-&gt;ptr[<span class="hljs-number">1</span>]=<span class="hljs-literal">NULL</span>;<br>        T-&gt;recptr[<span class="hljs-number">1</span>]=record;<br>        T-&gt;parent=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    Result res=<span class="hljs-built_in">SearchBTree</span>(T,key);<br>    <span class="hljs-keyword">if</span> (res.tag)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">Insert</span>(res.p,res.i,key,record,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,T);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除算法-1"><a href="#删除算法-1" class="headerlink" title="删除算法"></a>删除算法</h5><p>和插入相反，删除操作在查找成功时进行，被删除的关键字可以在最下层的非叶子结点或其上的结点：</p><ul><li><p>若被删除的关键字在最下层的非叶子结点之上，则该关键字的位置由其中序后继（先向右，再一路向左）填充，相当于被删除的关键字转换为在最下层的非叶子结点的该中序后继</p></li><li><p>删除后：</p><p><img src="/..%5Cimg%5Cep8%5Cimage-20221225201650635.png" alt="image-20221225201650635"></p></li></ul><h5 id="时间性能分析-5"><a href="#时间性能分析-5" class="headerlink" title="时间性能分析"></a>时间性能分析</h5><p>B 树常用于对外存数据或数据库组织索引，对数据进行查找时，查找时间花费在<strong>搜索结点（访问外存）</strong>和<strong>在结点内找关键字（访问内存）</strong>上，而访问外存比访问内存慢非常多，所以查找时间主要取决于访问外存的次数即在磁盘上搜索结点的次数，故查找时间主要取决于查找树的深度</p><p>推导含有 N 个关键字的 m 阶 B 树可能达到的最大深度 H（不包括失败结点）：</p><p>​先推导深度为 H（不包括失败结点）的 m 阶 B 树最少含有的结点数</p><p>​推导每一层最少含有的结点数：</p><p>​第 1 层：1 个</p><p>​第 2 层：2 个</p><p>​第 3 层：$$2*⌈m&#x2F;2⌉$$ 个</p><p>​第 4 层：$$2*⌈m&#x2F;2⌉^2$$ 个</p><p>​第 H+1 层：$$2*⌈m&#x2F;2⌉^{H-1}$$ 个</p><p>​第 H+1 层为叶子结点，而<strong>由 B 树中含有 N 个关键字可知叶子结点必为 N+1 个</strong>，故：</p><p>​$$N+1≥2*⌈m&#x2F;2⌉^{H-1}$$</p><p>​$$H-1≤log_{⌈m&#x2F;2⌉}\frac{N+1}2$$</p><p>​$$H≤log_{⌈m&#x2F;2⌉}\frac{N+1}2+1$$</p><p>所以，**在含有 N 个关键字的 m 阶 B 树上进行一次查找，需访问结点个数（访问外存次数）小于等于 $$H≤log_{⌈m&#x2F;2⌉}\frac{N+1}2+1$$**，在对外存数据或数据库组织索引方面，B 树的时间性能远高于二叉搜索树和平衡二叉树</p><h4 id="4-B-树"><a href="#4-B-树" class="headerlink" title="(4) B+ 树"></a>(4) B+ 树</h4><p>B+ 树结合了分块查找和 B 树，常用于对数据库组织索引，具有如下特性：</p><ol><li>所有的<strong>叶子结点</strong>出现在同一层次上，结点之间指针连接，所有叶子结点包含全部关键字和相应记录指针，结点内关键字增序排列，结点也增序排列，使得从第一个结点的第一个关键字到最后一个结点的最后一个关键字总体递增</li><li>所有的<strong>非叶子节点</strong>是所有叶子结点构成的递增序列的多层索引，其中关键字 Ki 为其相应指针 Ai 所指子树中关键字的最大值</li><li>设置两个头指针：一个指向根结点，一个指向含有最小关键字的叶子结点，对应地支持分块查找和顺序查找两种查找方式</li><li>每个<strong>叶子结点</strong>中关键字个数均介于 ⌈m&#x2F;2⌉ 和 m 之间；每个<strong>非叶子结点</strong>至多含有 m 个关键字和 m 棵子树；除根结点外，每个非叶子结点至少含有 ⌈m&#x2F;2⌉ 个关键字和 ⌈m&#x2F;2⌉ 棵子树（根结点可以没有子树，若有子树，那么至少有 2 棵子树和 2 个关键字）</li></ol><p>例如：下图为一棵 4 阶 B+ 树</p><img src="..\img\ep8\image-20221226111002849.png" alt="image-20221226111002849" style="zoom:25%;" /><h3 id="4-哈希表（散列表）"><a href="#4-哈希表（散列表）" class="headerlink" title="4 - 哈希表（散列表）"></a>4 - 哈希表（散列表）</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>以上介绍的查找表的共同点：查找过程为给定值依次与记录集合中各数据元素的关键字进行比较；查找性能取决于比较次数</p><p>对于需要频繁使用的查找表，希望 ASL &#x3D; 0，办法是：预先知道所查记录在表中的位置，避免比较</p><h5 id="“哈希函数”“哈希表”"><a href="#“哈希函数”“哈希表”" class="headerlink" title="“哈希函数”“哈希表”"></a>“哈希函数”“哈希表”</h5><p>在<strong>关键字</strong>与记录在表中的<strong>存储位置</strong>之间建立函数关系，即 h(key) 为关键字为 key 的记录在表中的位置，h(key) 称为哈希函数，该表称为哈希表</p><h5 id="“冲突”"><a href="#“冲突”" class="headerlink" title="“冲突”"></a>“冲突”</h5><p>有效的哈希函数应该是单射，但一般情况下，容易产生“冲突”现象，即 key1 ≠ key2，而 h(key1) &#x3D; h(key2)</p><p>很难找到一个不产生冲突的哈希函数，所以在构造哈希表时，既要构造使冲突尽可能少产生的哈希函数，又要给出处理冲突的算法</p><h4 id="构造哈希函数的方法"><a href="#构造哈希函数的方法" class="headerlink" title="构造哈希函数的方法"></a>构造哈希函数的方法</h4><p>对于非数字的关键字，需先将其数字化，可以用 ASCII 码等；对于数字的关键字，构造哈希函数的方法有：</p><h5 id="1-直接定址法"><a href="#1-直接定址法" class="headerlink" title="(1) 直接定址法"></a>(1) 直接定址法</h5><p>哈希函数为关键字的线性函数</p><h5 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="(2) 数字分析法"></a>(2) 数字分析法</h5><p>若每个关键字数字位数相同，则可分析关键字集合中的全体，并取各关键字值中分布近似随机的若干位组成哈希地址</p><p>举例：有 1000 个记录，关键字为 10 位十进制整数 x1x2…x10，哈希表长度为 2000；假设经过分析，各关键字值中 x3, x5, x7 的取值分布近似随机，则可构造哈希函数：h(key) &#x3D; h(x1x2…x10) &#x3D; x3x5x7，例如，h(3778597189) &#x3D; 757，h(9166372560) &#x3D; 632</p><p>适用场合：能够预先估计各关键字值中的每一位上各个数字出现的频度，某些位上各个数字频度均匀</p><h5 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="(3) 平方取中法"></a>(3) 平方取中法</h5><p>数字分析法的拓展，取关键字平方值的中间几位组成哈希地址（目的是扩大差别）</p><p>适用场合：能够预先估计各关键字值中的每一位上各个数字出现的频度，每一位上都有数字频度很高，或无法预先估计</p><h5 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="(4) 折叠法"></a>(4) 折叠法</h5><p>数字分析法的拓展，将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）组成哈希地址（目的是扩大差别），叠加的方法有移位叠加和边界叠加</p><p>举例：若哈希表长度为 1000，关键字 key &#x3D; 110108331119891，则将关键字分割成位数都为 3 的几部分，如图进行叠加：</p><img src="..\img\ep8\image-20221218104531861.png" alt="image-20221218104531861" style="zoom:25%;" /><p>适用场合：关键字位数较多，且预先估计出各关键字值中的每一位上都有数字频度很高或无法预先估计</p><h5 id="5-除留余数法"><a href="#5-除留余数法" class="headerlink" title="(5) 除留余数法"></a>(5) 除留余数法</h5><p>h(key) &#x3D; key mod p, p ≤ m(m 为表长)，不仅可以对关键字直接取模，也可以在平方取中、折叠等处理后取模；理论研究表明，为了减少冲突，p 取最接近 m 的素数或取 1.1n ~ 1.7n(n 为记录数) 之间的素数最好</p><table><thead><tr><th align="center">m</th><th align="center">8</th><th align="center">16</th><th align="center">32</th><th align="center">64</th><th align="center">128</th><th align="center">256</th><th align="center">512</th><th align="center">1000</th></tr></thead><tbody><tr><td align="center">p</td><td align="center">7</td><td align="center">13</td><td align="center">31</td><td align="center">61</td><td align="center">127</td><td align="center">251</td><td align="center">503</td><td align="center">997</td></tr></tbody></table><h5 id="6-伪随机数法"><a href="#6-伪随机数法" class="headerlink" title="(6) 伪随机数法"></a>(6) 伪随机数法</h5><p>h(key) &#x3D; Random(key)，Random 为伪随机函数</p><h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4><p>处理冲突的含义是：h(key) 是关键字为 key 的记录本应该在表中的位置，但是该位置已经被关键字为 key1 的记录占据，此时需要更新 h(key)；方法有：</p><h5 id="1-开放定址法"><a href="#1-开放定址法" class="headerlink" title="(1) 开放定址法"></a>(1) 开放定址法</h5><p>p &#x3D; (h(key) + di) mod m，m 为表长，di 为约定的增量序列的值，i 从 1 开始直至找到不发生冲突的位置（此时，更新后的 h(key) &#x3D; p）</p><p>要求哈希表需要<strong>有能力包含</strong>所有关键字对应的记录，即表长至少等于关键字个数；p 需要<strong>有能力覆盖</strong>哈希表中除了关键字为 key 的记录本应该在的位置之外的 m-1 个位置；di 的取法有：</p><ol><li><p><strong>线性探测再散列</strong></p><p>di &#x3D; c * i（需要自行检验覆盖能力）</p><p>最简单的情况：c &#x3D; 1, di &#x3D; 1, 2, …, m-1</p><p>优点：相比以下两种取法，限制较少且容易操作</p><p>缺点：容易发生“堆积”现象，即哈希地址本不相同的关键字发生了冲突</p></li><li><p><strong>平方探测再散列</strong></p><p>di &#x3D; $$1^2$$, $$-1^2$$, $$2^2$$, $$-2^2$$, …（为保证有能力覆盖，应满足表长 m 为<em>形如 4j + 3 的素数</em>，如 7, 11, 19, 23, …）</p></li><li><p><strong>随机探测再散列</strong></p><p>di 是一组伪随机序列或 di &#x3D; i * h2(key)（为保证有能力覆盖，应满足表长 m 和增量 di 没有公因子）</p></li></ol><p>哈希表中数据不经常变化时，常用开放定址法；而表中数据经常变化时，可用链地址法</p><h5 id="2-链地址法"><a href="#2-链地址法" class="headerlink" title="(2) 链地址法"></a>(2) 链地址法</h5><p>将所有哈希地址相同的记录都链接在同一链表中，同一链表中按关键字有序</p><p>若使用除留余数法构造哈希函数，则表长只需要等于 mod 值；例如，关键字为 19, 1, 23, 14, 55, 68, 11, 82, 36，哈希函数为 h(key) &#x3D; key mod 7，则哈希表如下图：</p><img src="..\img\ep8\image-20221226145050544.png" alt="image-20221226145050544" style="zoom:25%;" /><h5 id="3-再哈希法"><a href="#3-再哈希法" class="headerlink" title="(3) 再哈希法"></a>(3) 再哈希法</h5><p>构造多个不同的哈希函数，产生冲突时用另一个哈希函数得到哈希地址，直到冲突不再产生；这种方法不易发生“堆积”现象，但增加时间开销</p><h5 id="4-建立公共溢出区法"><a href="#4-建立公共溢出区法" class="headerlink" title="(4) 建立公共溢出区法"></a>(4) 建立公共溢出区法</h5><p>设置 HashTable（基本表）和 OverTable（溢出表）两个向量，如果发生冲突，不论哈希地址是什么，都填入溢出表</p><h4 id="查找算法及其时间性能分析"><a href="#查找算法及其时间性能分析" class="headerlink" title="查找算法及其时间性能分析"></a>查找算法及其时间性能分析</h4><p>查找过程和造表过程一致，算法描述如下：（以使用开放定址法处理冲突构造的哈希表为例，使用其他方法处理冲突构造的哈希表的查找同理）</p><p>对于给定值 k，得到哈希地址 p &#x3D; h(k)</p><ul><li>若 HashTable[p] &#x3D; NULL，则查找不成功</li><li>若 HashTable[p].key &#x3D; k，则查找成功</li><li>否则根据约定求下一地址，直至 HashTable[p] &#x3D; NULL（查找不成功）或 HashTable[p].key &#x3D; k（查找成功）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYINIT 0x3f3f3f3f</span><br><br><span class="hljs-type">int</span> sizelist[]=&#123;<span class="hljs-number">997</span>&#125;; <span class="hljs-comment">// 哈希表容量表（一个合适的递增素数序列）</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T* elem; <span class="hljs-comment">// 记录存储基址</span><br>    <span class="hljs-type">int</span> count; <span class="hljs-comment">// 当前记录数</span><br>    <span class="hljs-type">int</span> sizeindex; <span class="hljs-comment">// sizelist[sizeindex]为当前容量</span><br>&#125; HashTable;<br><br><span class="hljs-comment">// 查找成功，返回true；查找失败，返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Search</span><span class="hljs-params">(HashTable H,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> &amp;p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    p=<span class="hljs-built_in">h</span>(k);<br>    <span class="hljs-keyword">while</span> (H.elem[p].key!=KEYINIT&amp;&amp;H.elem[p].key!=k) &#123;<br>        ++i;<br>        p=(<span class="hljs-built_in">h</span>(k)+d[i])%sizelist[H.sizeindex];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (H.elem[p].key==k)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入成功，返回true；因哈希表中已有相同记录而插入失败，返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(HashTable &amp;H,T e)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Search</span>(H,e.key,p))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    H.elem[p]=e;<br>    ++H.count;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由查找过程可知，实际上哈希表 ASL ≠ 0，决定比较次数的因素有：</p><ul><li>哈希函数</li><li>处理冲突的方法</li><li><strong>哈希表的饱和程度 α &#x3D; n&#x2F;m (n 为记录数，m 为表长)</strong></li></ul><p>理论研究表明：当 α &lt; 0.5 即哈希表将近半满时，大部分情况下 ASL &lt; 2；所以，用哈希表构造查找表时，可以规定一个阈值 α（通常为 0.5），使得平均查找长度限定在某个范围内</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>操作系统中的可执行程序名</li><li>编译系统中的符号表</li><li>数据库中的索引</li><li>搜索引擎中的关键字词典</li><li>域名解析（域名与 IP 地址对应）</li><li>压缩算法、加密算法</li><li>C++ STL 中的 hash_map</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2023/03/02/%E5%9B%BE/"/>
    <url>/2023/03/02/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>数据结构课程笔记 ep7</p><span id="more"></span><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1 - 图的定义"></a>1 - 图的定义</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li><strong>图（Graph）</strong>是由一个<strong>顶点（Vertex）</strong>集 V 和一个<strong>弧（Arc）</strong>集 VR 构成的数据结构</li><li>弧是有方向的，因此图为<strong>有向图</strong></li><li>若有某顶点到另一顶点的弧必有另一顶点到该顶点的弧，则两弧表示两顶点之间的一条边，此时图为<strong>无向图</strong>（以后弧或边统称为弧）</li><li>假设图有 n 个顶点，e 条弧：<ul><li><strong>完全有向图</strong>：$$e&#x3D;A_n^2&#x3D;n(n-1)$$</li><li><strong>完全无向图</strong>：$$e&#x3D;C_n^2&#x3D;n(n-1)&#x2F;2$$</li></ul></li><li>一个图的顶点集和弧集分别是另一个图的顶点集和弧集的子集，该图称为另一个图的<strong>子图</strong></li><li>有向图：<strong>度</strong> &#x3D; 出度 + 入度；无向图：度</li><li>有时图的弧具有与它相关的数，称为<strong>权</strong>，权可以表示从一个顶点到另一个顶点的距离或耗费，带权图称为<strong>网</strong></li><li><strong>路径</strong>，<strong>回路</strong>，<strong>有向路径</strong></li><li>在无向图中，若图中任意两个顶点之间都有路径相通，则称此图为<strong>连通图</strong>，否则称之为<strong>非连通图</strong>（在非连通图中定义<strong>连通分量</strong>）</li><li>在有向图中，若图中任意两个顶点之间都有有向路径相通，则称此图为<strong>强连通图</strong></li><li>假设连通图有 n 个顶点和 e 条边，其中 n-1 条边和 n 个顶点构成一个<strong>极小连通子图</strong>，称为此连通图的<strong>生成树</strong></li></ul><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ADT Graph &#123;<br>数据对象V：<br>V是具有相同特性的数据元素的集合，称为顶点集。<br>数据关系VR：<br>VR=&#123;&lt;v,w&gt;<span class="hljs-pattern-match">|v,w∈<span class="hljs-constructor">V</span>且<span class="hljs-constructor">P(<span class="hljs-params">v</span>,<span class="hljs-params">w</span>)</span>&#125;</span><br><span class="hljs-pattern-match">&lt;v,w&gt;表示从v到w的一条弧，谓词<span class="hljs-constructor">P(<span class="hljs-params">v</span>,<span class="hljs-params">w</span>)</span>定义了弧&lt;v,w&gt;的意义或信息。</span><br><span class="hljs-pattern-match">    基本操作：</span><br><span class="hljs-pattern-match">    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 图的建立和销毁</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">CreateGraph(&amp;G,V,VR)</span></span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">DestroyGraph(&amp;G)</span></span><br><span class="hljs-pattern-match">    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 插入或删除顶点</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">InsertVex(&amp;G,<span class="hljs-params">v</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 在图<span class="hljs-constructor">G</span>中插入顶点v</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">DeleteVex(&amp;G,<span class="hljs-params">v</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 删除顶点v及其相关的弧</span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 插入和删除弧</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">InsertArc(&amp;G,<span class="hljs-params">v</span>,<span class="hljs-params">w</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 在图<span class="hljs-constructor">G</span>中增添弧&lt;v,w&gt;，若图<span class="hljs-constructor">G</span>是无向的，则还增添对称弧&lt;w,v&gt;</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">DeleteArc(&amp;G,<span class="hljs-params">v</span>,<span class="hljs-params">w</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 在图<span class="hljs-constructor">G</span>中删除弧&lt;v,w&gt;，若图<span class="hljs-constructor">G</span>是无向的，则还删除对称弧&lt;w,v&gt;</span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 对顶点的访问操作</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">LocateVex(G,<span class="hljs-params">v</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 返回顶点位置信息</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">GetVex(G,<span class="hljs-params">v</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 返回顶点值</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">PutVex(&amp;G,<span class="hljs-params">v</span>,<span class="hljs-params">value</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 对顶点赋值</span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 对邻接点的操作</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">FirstAdjVex(G,<span class="hljs-params">v</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 返回顶点v的第一个邻接点，若顶点v没有邻接点，则返回空</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">NextAdjVex(G,<span class="hljs-params">v</span>,<span class="hljs-params">w</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 返回顶点v相对于w的下一个邻接点，若w是v的最后一个邻接点，则返回空</span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 遍历</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">DFSTraverse(G,<span class="hljs-params">v</span>,<span class="hljs-params">visit</span>()</span>) <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 从顶点v起深度优先遍历图<span class="hljs-constructor">G</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">BFSTraverse(G,<span class="hljs-params">v</span>,<span class="hljs-params">visit</span>()</span>) <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 从顶点v起广度优先遍历图<span class="hljs-constructor">G</span></span><br><span class="hljs-pattern-match">&#125; <span class="hljs-constructor">ADT</span> <span class="hljs-constructor">Graph</span></span><br></code></pre></td></tr></table></figure><h3 id="2-图的存储"><a href="#2-图的存储" class="headerlink" title="2 - 图的存储"></a>2 - 图的存储</h3><h4 id="邻接矩阵（Adjacent-matrix）"><a href="#邻接矩阵（Adjacent-matrix）" class="headerlink" title="邻接矩阵（Adjacent matrix）"></a>邻接矩阵（Adjacent matrix）</h4><p>用一个二维数组来表示顶点间的相邻关系</p><h5 id="有向图的邻接矩阵"><a href="#有向图的邻接矩阵" class="headerlink" title="有向图的邻接矩阵"></a>有向图的邻接矩阵</h5><p>有 n(n≥1) 个顶点的有向图的邻接矩阵是具有如下性质的 n 阶方阵：</p><ul><li>A[i][j] &#x3D; 1，当 &lt;v_i, v_j&gt; ∈ VR</li><li>A[i][j] &#x3D; 0，当 &lt;v_i, v_j&gt; ∉ VR</li></ul><p>有向图的邻接矩阵不一定是对称方阵，邻接矩阵第 i 行的元素之和为顶点 v_i 的出度，邻接矩阵第 i 列的元素之和为顶点 v_i 的入度</p><h5 id="无向图的邻接矩阵"><a href="#无向图的邻接矩阵" class="headerlink" title="无向图的邻接矩阵"></a>无向图的邻接矩阵</h5><p>有 n(n≥1) 个顶点的无向图的邻接矩阵是具有如下性质的 n 阶方阵：</p><ul><li>A[i][j] &#x3D; A[j][i] &#x3D; 1，当 (v_i, v_j) ∈ VR</li><li>A[i][j] &#x3D; A[j][i] &#x3D; 0，当 (v_i, v_j) ∉ VR</li></ul><p>无向图的邻接矩阵是对称方阵，邻接矩阵第 i 行（或第 i 列）的元素之和为顶点 v_i 的度</p><h5 id="网的邻接矩阵"><a href="#网的邻接矩阵" class="headerlink" title="网的邻接矩阵"></a>网的邻接矩阵</h5><p>有 n(n≥1) 个顶点的有向网的邻接矩阵是具有如下性质的 n 阶方阵：</p><ul><li>A[i][j] &#x3D; w_ij，当 &lt;v_i, v_j&gt; ∈ VR</li><li>A[i][j] &#x3D; ∞，当 &lt;v_i, v_j&gt; ∉ VR</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_VERTEX_NUM=<span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INFINITY=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;DG,DN,UDG,UDN&#125; GraphKind; <span class="hljs-comment">// &#123;有向图，有向网，无向图，无向网&#125;</span><br><br><span class="hljs-comment">// 弧的定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> adj; <span class="hljs-comment">// 对图，为1或0，表示是否相邻；对网，为权值</span><br>    InfoType* info; <span class="hljs-comment">// 该弧相关信息的指针</span><br>&#125; ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br><br><span class="hljs-comment">// 图的定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    GraphKind kind;<br>    T vexs[MAX_VERTEX_NUM];<br>    AdjMatrix arcs;<br>    <span class="hljs-type">int</span> vexnum,arcnum;<br>&#125; MGraph;<br></code></pre></td></tr></table></figure><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点：省时间（容易判定任意两个顶点之间是否有弧相连或其权值，容易求得各个顶点的度）</li><li>缺点：费空间（占用空间大小只与图中顶点个数有关，而与边的数目无关）</li></ul><h4 id="邻接表（Adjacent-list）"><a href="#邻接表（Adjacent-list）" class="headerlink" title="邻接表（Adjacent list）"></a>邻接表（Adjacent list）</h4><p>对图中每个顶点建立一个单链表，每个单链表的结点表示该顶点的所有邻接顶点（在头结点和第一个表结点之间插入新的表结点，在最后插入新的表结点容易出现“无效的指针赋值”的错误）</p><img src="..\img\ep7\image-20221115214543044.png" alt="image-20221115214543044" style="zoom:25%;" /><h5 id="有向图的邻接表"><a href="#有向图的邻接表" class="headerlink" title="有向图的邻接表"></a>有向图的邻接表</h5><p>在有向图的邻接表中，其中一个链表的表结点数是顶点的出度</p><p>在有向图的逆邻接表中，其中一个链表的表结点数是顶点的入度</p><h5 id="无向图的邻接表"><a href="#无向图的邻接表" class="headerlink" title="无向图的邻接表"></a>无向图的邻接表</h5><p>在无向图的邻接表中，其中一个链表的表结点数是顶点的度</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_VERTEX_NUM=<span class="hljs-number">20</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;DG,DN,UDG,UDN&#125; GraphKind; <span class="hljs-comment">// &#123;有向图，有向网，无向图，无向网&#125;</span><br><br><span class="hljs-comment">// 弧的结点结构（表结点）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> &#123;<br>    <span class="hljs-type">int</span> adjvex;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>* nextarc;<br>    InfoType* info; <span class="hljs-comment">// 该弧相关信息的指针（如权值）</span><br>&#125; ArcNode;<br><br><span class="hljs-comment">// 顶点的结点结构（头结点）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T vex;<br>    ArcNode* firstarc;<br>&#125; VNode,AdjList[MAX_VERTEX_NUM];<br><br><span class="hljs-comment">// 图的定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    GraphKind kind;<br>    AdjList vexs;<br>    <span class="hljs-type">int</span> vexnum,arcnum;<br>&#125; LGraph;<br></code></pre></td></tr></table></figure><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点：省空间（占用空间大小取决于边的数目）</li><li>缺点：费时间（要判定任意两个顶点之间是否有弧相连时，需扫描链表）</li></ul><h4 id="有向图的十字链表"><a href="#有向图的十字链表" class="headerlink" title="有向图的十字链表"></a>有向图的十字链表</h4><p>十字链表是将有向图的邻接表和逆邻接表结合起来得到的一种链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_VERTEX_NUM=<span class="hljs-number">20</span>;<br><br><span class="hljs-comment">// 弧的结点结构（表结点）</span><br><span class="hljs-comment">// |弧尾顶点位置|弧头顶点位置|指向下一个有相同弧尾的结点的指针|指向下一个有相同弧头的结点的指针|弧的相关信息|</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcBox</span> &#123;<br>    <span class="hljs-type">int</span> tailvex,headvex;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcBox</span> *tlink,*hlink;<br>InfoType* info;<br>&#125; ArcBox;<br><br><span class="hljs-comment">// 顶点的结点结构（头结点）</span><br><span class="hljs-comment">// |顶点数据|指向该顶点的第一条入弧|指向该顶点的第一条出弧|</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T data;<br>    ArcBox *firstin,*firstout;<br>&#125; VexNode;<br><br><span class="hljs-comment">// 图的定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    VexNode vexs[MAX_VERTEX_NUM];<br>    <span class="hljs-type">int</span> vexnum,arcnum;<br>&#125; OLGraph;<br></code></pre></td></tr></table></figure><h3 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3 - 图的遍历"></a>3 - 图的遍历</h3><blockquote><p>图的遍历要比树的遍历复杂得多，因为图中任一顶点都可能和其余顶点相邻接。为了避免同一顶点被多次访问，在遍历过程中，必须记下每个已访问过的顶点。为此，可设一个标志数组 <code>visited</code>，初始化为 0，一旦访问了顶点 $$v_i$$，便置 <code>visited[i]</code> 为 1 或被访问时的次序号。</p></blockquote><h4 id="深度优先搜索（Depth-First-Search）"><a href="#深度优先搜索（Depth-First-Search）" class="headerlink" title="深度优先搜索（Depth First Search）"></a>深度优先搜索（Depth First Search）</h4><p>连通图：从图中某个顶点 $$v_0$$ 出发，访问此顶点，然后依次从 $$v_0$$ 的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和 $$v_0$$ 有路径相通的顶点都被访问到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 从顶点v出发，深度优先搜索遍历连通图G</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-built_in">visit</span>(v);<br>    visited[v]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w=<span class="hljs-built_in">FirstAdjVex</span>(G,v);w!=<span class="hljs-number">-1</span>;w=<span class="hljs-built_in">NextAdjVex</span>(G,v,w))<br>        <span class="hljs-keyword">if</span> (!visited[w])<br>            <span class="hljs-built_in">DFS</span>(G,w);<br>&#125;<br><br><span class="hljs-comment">// 从顶点v出发，深度优先搜索遍历连通图G（邻接矩阵存储）</span><br><span class="hljs-comment">// 时间复杂度：O(n^2)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(MGraph G,<span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-built_in">visit</span>(G.vexs[v]);<br>    visited[v]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;G.vexnum;++j)<br>        <span class="hljs-keyword">if</span> (G.arcs[v][j]!=<span class="hljs-number">0</span>&amp;&amp;!visited[j])<br>            <span class="hljs-built_in">DFS</span>(G,j);<br>&#125;<br><br><span class="hljs-comment">// 从顶点v出发，深度优先搜索遍历连通图G（邻接表存储）</span><br><span class="hljs-comment">// 时间复杂度：O(n+e)，n为顶点数，e为弧数或两倍边数（通过遍历表结点查找所有顶点的邻接点所需时间为O(e)，访问顶点所需时间为O(n)）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(LGraph G,<span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-built_in">visit</span>(G.vexs[v].vex);<br>    visited[v]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (ArcNode* p=G.vexs[v].firstarc;p;p=p-&gt;nextarc)<br>        <span class="hljs-keyword">if</span> (!visited[p-&gt;adjvex])<br>            <span class="hljs-built_in">DFS</span>(G,p-&gt;adjvex);<br>&#125;<br></code></pre></td></tr></table></figure><p>非连通图：非连通图的遍历是一般情形，遍历非连通图就是多次遍历连通图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFSTraverse</span><span class="hljs-params">(Graph G)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;G.vexnum;++v)<br>        <span class="hljs-keyword">if</span> (!visited[v])<br>            <span class="hljs-built_in">DFS</span>(G,v);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="广度优先搜索（Breadth-First-Search）"><a href="#广度优先搜索（Breadth-First-Search）" class="headerlink" title="广度优先搜索（Breadth First Search）"></a>广度优先搜索（Breadth First Search）</h4><p>连通图：从图中的某个顶点 $$v_0$$ 出发，并在访问此顶点之后依次访问 $$v_0$$ 的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和 $$v0$$ 有路径相通的顶点都被访问到（使用<strong>队列</strong>）</p><p>非连通图：若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">时间复杂度</span><br><span class="hljs-comment">邻接矩阵存储：O(n^2)</span><br><span class="hljs-comment">邻接表存储：O(n+e)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFSTraverse</span><span class="hljs-params">(Graph G)</span> </span>&#123;<br>    Queue Q;<br>    <span class="hljs-built_in">InitQueue</span>(Q);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;G.vexnum;++v)<br>        <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>            <span class="hljs-built_in">visit</span>(v);<br>            visited[v]=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">EnQueue</span>(Q,v);<br>            <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">QueueEmpty</span>(Q)) &#123;<br>                <span class="hljs-type">int</span> u=<span class="hljs-built_in">DeQueue</span>(Q);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w=<span class="hljs-built_in">FirstAdjVex</span>(G,u);w!=<span class="hljs-number">-1</span>;w=<span class="hljs-built_in">NextAdjVex</span>(G,u,w))<br>                    <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>                        <span class="hljs-built_in">visit</span>(w);<br>                        visited[w]=<span class="hljs-number">1</span>;<br>                        <span class="hljs-built_in">EnQueue</span>(Q,w);<br>                    &#125;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历算法的应用举例"><a href="#遍历算法的应用举例" class="headerlink" title="遍历算法的应用举例"></a>遍历算法的应用举例</h4><h5 id="求一条从顶点-v-到顶点-s-的简单路径-x2F-判断两顶点是否连通"><a href="#求一条从顶点-v-到顶点-s-的简单路径-x2F-判断两顶点是否连通" class="headerlink" title="求一条从顶点 v 到顶点 s 的简单路径 &#x2F; 判断两顶点是否连通"></a>求一条从顶点 v 到顶点 s 的简单路径 &#x2F; 判断两顶点是否连通</h5><ul><li>若存在从顶点 v 到顶点 s 的路径，则从顶点 v 出发进行 <strong>DFS</strong>，必能搜索到顶点 s</li><li>遍历过程中搜索到的顶点不一定是路径上的顶点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SearchPath</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> s,<span class="hljs-type">char</span>* PATH)</span> </span>&#123;<br>    <span class="hljs-built_in">Append</span>(PATH,<span class="hljs-built_in">GetVex</span>(G,v));<br>    visited[v]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w=<span class="hljs-built_in">FirstAdjVex</span>(G,v);w!=<span class="hljs-number">-1</span>&amp;&amp;!found;w=<span class="hljs-built_in">NextAdjVex</span>(G,v,w))<br>        <span class="hljs-keyword">if</span> (w==s) &#123;<br>            found=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">Append</span>(PATH,<span class="hljs-built_in">GetVex</span>(G,w));<br>        &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!visited[w])<br>            <span class="hljs-built_in">SearchPath</span>(G,w,s,PATH);<br>    <span class="hljs-keyword">if</span> (!found)<br>        <span class="hljs-built_in">Delete</span>(PATH); <span class="hljs-comment">// 删除路径上的点</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h5><ul><li><p>只考虑<strong>不带权的图</strong>中两点之间的最短路径问题，即两顶点间所含弧的数目最少的路径就是最短路径（带权图中两点之间的最短路径问题见“5 - 最短路径”）</p></li><li><p><strong>BFS</strong> 按路径长度渐增的次序遍历图，适合求最短路径问题</p></li><li><p>使用链队列：</p><ol><li>给链队列结点设置 next 和 prior 两个指针</li><li>修改入队操作：在队尾插入新结点，令其 prior 指针指向头结点</li><li>修改出队操作：仅移动队头指针，而不将队头结点从链表中删除</li></ol></li><li><p>例子：</p><img src="..\img\ep7\image-20230114191228105.png" alt="image-20230114191228105" style="zoom: 33%;" /></li></ul><h3 id="4-最小生成树"><a href="#4-最小生成树" class="headerlink" title="4 - 最小生成树"></a>4 - 最小生成树</h3><p>从无向连通图中任一顶点开始遍历，遍历图时走过的边和图中所有顶点一起构成该连通图的<strong>极小连通子图</strong>（含义是：任何具有 n 个顶点的连通图，至少有 n-1 条边），称为该连通图的<strong>生成树</strong>（含义是：所有具有 n-1 条边的连通图都是树）</p><p>图的生成树不唯一，从不同顶点出发进行不同搜索，都可以得到不同的生成树</p><p>若为连通图的各条边赋权，表示相应的代价，则从连通图中选择一棵总代价最小的树，即为<strong>最小代价生成树</strong></p><ul><li>经典算法：<strong>克鲁斯卡尔（Kruskal）算法</strong>和<strong>普里姆（Prim）算法</strong></li><li>基本思想：贪心，按权值非递减次序构造最小代价生成树</li></ul><h4 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h4><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><p>先分离图的顶点和边，再尝试将边连接回各顶点。规则是：从权值最小的边开始，若它的添加不使现在的图产生回路，则添加这条边，否则丢弃；如此重复，直至添加 n-1 条边为止。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">无向连通网的简单存储方法：</span><br><span class="hljs-comment">- 定义存储顶点数的变量vexnum和存储边数的变量arcnum</span><br><span class="hljs-comment">- 将图的顶点映射到0~vexnum-1</span><br><span class="hljs-comment">- 用Edge类型数组存储图的边（同一条边只存储一次）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> vex1;<br>    <span class="hljs-type">int</span> vex2;<br>    <span class="hljs-type">int</span> w;<br>&#125; Edge;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> vexnum,arcnum;<br>    Edge edge[MAX_EDGE_NUM];<br>&#125; Graph;<br><br><span class="hljs-comment">// 用STL中的sort实现边数组元素按权值排序，以下为排序方式定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">less_weight</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Edge &amp;a1,<span class="hljs-type">const</span> Edge &amp;a2)</span><span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a1.w&lt;a2.w;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 主算法</span><br><span class="hljs-function">Graph <span class="hljs-title">MiniSpanTree_K</span><span class="hljs-params">(Graph G)</span> </span>&#123;<br>    Graph res;<br>    res.vexnum=G.vexnum;<br>    res.arcnum=G.vexnum?G.vexnum<span class="hljs-number">-1</span>:<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-built_in">sort</span>(G.edge+<span class="hljs-number">0</span>,G.edge+G.arcnum,<span class="hljs-built_in">less_weight</span>());<br>    <br>    <span class="hljs-type">int</span> vset[MAX_VERTEX_NUM]; <span class="hljs-comment">// 辅助数组，用于判断回路（重要思路：集合的合并）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.vexnum;++i)<br>        vset[i]=i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;G.arcnum;++i) &#123; <span class="hljs-comment">// i为G.edge下标，j为res.edge下标</span><br>        <span class="hljs-type">int</span> tmp1=vset[G.edge[i].vex1];<br>        <span class="hljs-type">int</span> tmp2=vset[G.edge[i].vex2];<br>        <span class="hljs-keyword">if</span> (tmp1!=tmp2) &#123;<br>            res.edge[j++]=G.edge[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;res.vexnum;++k)<br>                <span class="hljs-keyword">if</span> (vset[k]==tmp2)<br>                    vset[k]=tmp1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j==res.arcnum)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>Kruskal 算法的时间复杂度就是将边数组元素按权值排序的时间复杂度，即 O(eloge)，其中 e 为边数。因此，Kruskal 算法更适用于稀疏图。</p><h4 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h4><h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><p>取图中任意一个顶点 v 作为生成树的根，然后取图中与 v 直接连接且连接边权值最小的顶点 w 加入生成树；接着将生成树中已有的顶点看作整体，取图中与该整体直接连接且连接边权值最小的顶点加入生成树，循环上述过程直至生成树上含有 n 个顶点为止。设置两个集合分别表示生成树中已有的顶点和图中其他顶点。</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>实现过程示例：从顶点 a 出发构造最小生成树（结合代码理解）</p><img src="..\img\ep7\image-20230113183637017.png" alt="image-20230113183637017" style="zoom:25%;" /><ul><li><p>初始化：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">a (0)</th><th align="center">b (1)</th><th align="center">c (2)</th><th align="center">d (3)</th><th align="center">e (4)</th><th align="center">f (5)</th><th align="center">g (6)</th></tr></thead><tbody><tr><td align="center">mst[i].adjvex</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">mst[i].lowcost</td><td align="center">∞</td><td align="center">∞</td><td align="center">∞</td><td align="center">∞</td><td align="center">∞</td><td align="center">∞</td><td align="center">∞</td></tr><tr><td align="center">mst[i].flag</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table></li><li><p>第一轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">a (0)</th><th align="center">b (1)</th><th align="center">c (2)</th><th align="center">d (3)</th><th align="center">e (4)</th><th align="center">f (5)</th><th align="center">g (6)</th></tr></thead><tbody><tr><td align="center">mst[i].adjvex</td><td align="center"></td><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center">a</td><td align="center"></td><td align="center">a</td></tr><tr><td align="center">mst[i].lowcost</td><td align="center">∞</td><td align="center">19</td><td align="center">∞</td><td align="center">∞</td><td align="center"><em><strong>14</strong></em></td><td align="center">∞</td><td align="center">18</td></tr><tr><td align="center">mst[i].flag</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0→1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table></li><li><p>第二轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">a (0)</th><th align="center">b (1)</th><th align="center">c (2)</th><th align="center">d (3)</th><th align="center">e (4)</th><th align="center">f (5)</th><th align="center">g (6)</th></tr></thead><tbody><tr><td align="center">mst[i].adjvex</td><td align="center"></td><td align="center">e</td><td align="center"></td><td align="center">e</td><td align="center">a</td><td align="center"></td><td align="center">e</td></tr><tr><td align="center">mst[i].lowcost</td><td align="center">∞</td><td align="center">12</td><td align="center">∞</td><td align="center"><em><strong>8</strong></em></td><td align="center">14</td><td align="center">∞</td><td align="center">16</td></tr><tr><td align="center">mst[i].flag</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0→1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table></li><li><p>第三轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">a (0)</th><th align="center">b (1)</th><th align="center">c (2)</th><th align="center">d (3)</th><th align="center">e (4)</th><th align="center">f (5)</th><th align="center">g (6)</th></tr></thead><tbody><tr><td align="center">mst[i].adjvex</td><td align="center"></td><td align="center">d</td><td align="center">d</td><td align="center">e</td><td align="center">a</td><td align="center">d</td><td align="center">e</td></tr><tr><td align="center">mst[i].lowcost</td><td align="center">∞</td><td align="center">7</td><td align="center"><em><strong>3</strong></em></td><td align="center">8</td><td align="center">14</td><td align="center">21</td><td align="center">16</td></tr><tr><td align="center">mst[i].flag</td><td align="center">1</td><td align="center">0</td><td align="center">0→1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table></li><li><p>第四轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">a (0)</th><th align="center">b (1)</th><th align="center">c (2)</th><th align="center">d (3)</th><th align="center">e (4)</th><th align="center">f (5)</th><th align="center">g (6)</th></tr></thead><tbody><tr><td align="center">mst[i].adjvex</td><td align="center"></td><td align="center">c</td><td align="center">d</td><td align="center">e</td><td align="center">a</td><td align="center">d</td><td align="center">e</td></tr><tr><td align="center">mst[i].lowcost</td><td align="center">∞</td><td align="center"><em><strong>5</strong></em></td><td align="center">3</td><td align="center">8</td><td align="center">14</td><td align="center">21</td><td align="center">16</td></tr><tr><td align="center">mst[i].flag</td><td align="center">1</td><td align="center">0→1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table></li><li><p>第五轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">a (0)</th><th align="center">b (1)</th><th align="center">c (2)</th><th align="center">d (3)</th><th align="center">e (4)</th><th align="center">f (5)</th><th align="center">g (6)</th></tr></thead><tbody><tr><td align="center">mst[i].adjvex</td><td align="center"></td><td align="center">c</td><td align="center">d</td><td align="center">e</td><td align="center">a</td><td align="center">d</td><td align="center">e</td></tr><tr><td align="center">mst[i].lowcost</td><td align="center">∞</td><td align="center">5</td><td align="center">3</td><td align="center">8</td><td align="center">14</td><td align="center">21</td><td align="center"><em><strong>16</strong></em></td></tr><tr><td align="center">mst[i].flag</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0→1</td></tr></tbody></table></li><li><p>第六轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">a (0)</th><th align="center">b (1)</th><th align="center">c (2)</th><th align="center">d (3)</th><th align="center">e (4)</th><th align="center">f (5)</th><th align="center">g (6)</th></tr></thead><tbody><tr><td align="center">mst[i].adjvex</td><td align="center"></td><td align="center">c</td><td align="center">d</td><td align="center">e</td><td align="center">a</td><td align="center">d</td><td align="center">e</td></tr><tr><td align="center">mst[i].lowcost</td><td align="center">∞</td><td align="center">5</td><td align="center">3</td><td align="center">8</td><td align="center">14</td><td align="center"><em><strong>21</strong></em></td><td align="center">16</td></tr><tr><td align="center">mst[i].flag</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0→1</td><td align="center">1</td></tr></tbody></table></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T vexs[MAX_VERTEX_NUM];<br>    AdjMatrix arcs;<br>    <span class="hljs-type">int</span> vexnum,arcnum;<br>&#125; Graph;<br><br><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> adjvex; <span class="hljs-comment">// 将图的顶点映射到0~vexnum-1</span><br>    <span class="hljs-type">int</span> lowcost;<br>    <span class="hljs-type">bool</span> flag;<br>&#125; mst[MAX_VERTEX_NUM];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniSpanTree_P</span><span class="hljs-params">(Graph G,T v)</span> </span>&#123; <span class="hljs-comment">// 从顶点v出发构造最小生成树</span><br>    <span class="hljs-comment">// 初始化mst数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i) &#123;<br>        mst[i].lowcost=INFINITY;<br>        mst[i].flag=<span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> k=<span class="hljs-built_in">LocateVex</span>(G,v);<br>    mst[k].flag=<span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;t&lt;G.vexnum;++t) &#123; <span class="hljs-comment">// t记轮数</span><br>        <span class="hljs-type">int</span> min=INFINITY,minidx;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i) &#123;<br>            <span class="hljs-keyword">if</span> (!mst[i].flag&amp;&amp;G.arcs[k][i]&lt;mst[i].lowcost) &#123;<br>                mst[i].adjvex=k;<br>                mst[i].lowcost=G.arcs[k][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!mst[i].flag&amp;&amp;mst[i].lowcost&lt;min) &#123;<br>                min=mst[i].lowcost;<br>                minidx=i;<br>            &#125;<br>        &#125;<br>        mst[minidx].flag=<span class="hljs-literal">true</span>;<br>        k=minidx;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>Prim 算法的时间复杂度是 O(n^2)，其中 n 为顶点数。因此，Prim 算法更适用于稠密图。</p><h4 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h4><p>Kruskal 算法和 Prim 算法被称为避圈法，相应地，另一种破圈法的思路是：从大到小删除边并保证删除后仍是连通图，直至剩下 n-1 条边。</p><h3 id="5-最短路径"><a href="#5-最短路径" class="headerlink" title="5 - 最短路径"></a>5 - 最短路径</h3><p>经典算法：</p><ul><li><strong>迪杰斯特拉（Dijkstra）算法</strong>：基于贪心思想，求从某顶点到其他各顶点的最短路径</li><li><strong>弗洛伊德（Floyd）算法</strong>：基于动态规划，求每一对顶点之间的最短路径</li></ul><h4 id="Dijkstra-算法：求从某顶点到其他各顶点的最短路径"><a href="#Dijkstra-算法：求从某顶点到其他各顶点的最短路径" class="headerlink" title="Dijkstra 算法：求从某顶点到其他各顶点的最短路径"></a>Dijkstra 算法：求从某顶点到其他各顶点的最短路径</h4><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><img src="..\img\ep7\image-20230114202714985.png" alt="image-20230114202714985" style="zoom:25%;" /><p>上图所示带权有向图中从 v0 到其他各顶点的最短路径为：</p><table><thead><tr><th align="center">终点</th><th align="center">最短路径</th><th align="center">最短路径长度</th></tr></thead><tbody><tr><td align="center">v1</td><td align="center">无</td><td align="center">-</td></tr><tr><td align="center">v2</td><td align="center">(v0, v2)</td><td align="center">10</td></tr><tr><td align="center">v3</td><td align="center">(v0, v4, v3)</td><td align="center">50</td></tr><tr><td align="center">v4</td><td align="center">(v0, v4)</td><td align="center">30</td></tr><tr><td align="center">v5</td><td align="center">(v0, v4, v3, v5)</td><td align="center">60</td></tr></tbody></table><p>从 v0 到其他各顶点的<strong>最短路径</strong>中的<strong>最短者</strong>为从 v0 到 v2 的最短路径</p><h5 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h5><p>基本思想：按<strong>最短路径长度</strong>递增的次序产生最短路径</p><ul><li>最短路径中的最短者的特点：该路径上必定只有一条弧，且这条弧必定是从始点出发的弧中权值最小的，记作 (v0, vi)</li><li>最短路径中的次短者的特点：（两种情况）或是直接从始点到该点，记作 (v0, vj)（从始点出发的弧中权值次小的弧）；或是从始点经过顶点 vi 再到该点，记作 (v0, vi, vj)（从始点出发的弧中权值最小的弧 + 从顶点 vi 出发的弧中权值最小的弧）</li><li>最短路径中的第三短者的特点：（三种情况）或是直接从始点到该点，记作 (v0, vk)；或是从始点经过顶点 vi 再到该点，记作 (v0, vi, vk)；或是从始点经过顶点 vj 再到该点，记作 (v0, …, vj, vk)</li><li>其余最短路径的特点：或是直接从始点到该点；或是从始点经过已求得最短路径的顶点，再到该点</li></ul><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p>实现过程示例（与 Prim 算法很类似）：求示例图中从 v0 到其他各顶点的最短路径（结合代码理解）</p><ul><li><p>初始化：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">v0</th><th align="center">v1</th><th align="center">v2</th><th align="center">v3</th><th align="center">v4</th><th align="center">v5</th></tr></thead><tbody><tr><td align="center">path[i]</td><td align="center">(v0)</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">pathdist[i]</td><td align="center">0</td><td align="center">∞</td><td align="center">∞</td><td align="center">∞</td><td align="center">∞</td><td align="center">∞</td></tr><tr><td align="center">flag[i]</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table></li><li><p>第一轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">v0</th><th align="center">v1</th><th align="center">v2</th><th align="center">v3</th><th align="center">v4</th><th align="center">v5</th></tr></thead><tbody><tr><td align="center">path[i]</td><td align="center">(v0)</td><td align="center"></td><td align="center">(v0, v2)</td><td align="center"></td><td align="center">(v0, v4)</td><td align="center">(v0, v5)</td></tr><tr><td align="center">pathdist[i]</td><td align="center">0</td><td align="center">∞</td><td align="center"><em><strong>10</strong></em></td><td align="center">∞</td><td align="center">30</td><td align="center">100</td></tr><tr><td align="center">flag[i]</td><td align="center">1</td><td align="center">0</td><td align="center">0→1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table></li><li><p>第二轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">v0</th><th align="center">v1</th><th align="center">v2</th><th align="center">v3</th><th align="center">v4</th><th align="center">v5</th></tr></thead><tbody><tr><td align="center">path[i]</td><td align="center">(v0)</td><td align="center"></td><td align="center">(v0, v2)</td><td align="center">(v0, v2, v3)</td><td align="center">(v0, v4)</td><td align="center">(v0, v5)</td></tr><tr><td align="center">pathdist[i]</td><td align="center">0</td><td align="center">∞</td><td align="center">10</td><td align="center">60</td><td align="center"><em><strong>30</strong></em></td><td align="center">100</td></tr><tr><td align="center">flag[i]</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0→1</td><td align="center">0</td></tr></tbody></table></li><li><p>第三轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">v0</th><th align="center">v1</th><th align="center">v2</th><th align="center">v3</th><th align="center">v4</th><th align="center">v5</th></tr></thead><tbody><tr><td align="center">path[i]</td><td align="center">(v0)</td><td align="center"></td><td align="center">(v0, v2)</td><td align="center">(v0, v4, v3)</td><td align="center">(v0, v4)</td><td align="center">(v0, v4, v5)</td></tr><tr><td align="center">pathdist[i]</td><td align="center">0</td><td align="center">∞</td><td align="center">10</td><td align="center"><em><strong>50</strong></em></td><td align="center">30</td><td align="center">90</td></tr><tr><td align="center">flag[i]</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0→1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table></li><li><p>第四轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">v0</th><th align="center">v1</th><th align="center">v2</th><th align="center">v3</th><th align="center">v4</th><th align="center">v5</th></tr></thead><tbody><tr><td align="center">path[i]</td><td align="center">(v0)</td><td align="center"></td><td align="center">(v0, v2)</td><td align="center">(v0, v4, v3)</td><td align="center">(v0, v4)</td><td align="center">(v0, v4, v3, v5)</td></tr><tr><td align="center">pathdist[i]</td><td align="center">0</td><td align="center">∞</td><td align="center">10</td><td align="center">50</td><td align="center">30</td><td align="center"><em><strong>60</strong></em></td></tr><tr><td align="center">flag[i]</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0→1</td></tr></tbody></table></li><li><p>第五轮：</p><table><thead><tr><th align="center">G.vexs[i]</th><th align="center">v0</th><th align="center">v1</th><th align="center">v2</th><th align="center">v3</th><th align="center">v4</th><th align="center">v5</th></tr></thead><tbody><tr><td align="center">path[i]</td><td align="center">(v0)</td><td align="center"></td><td align="center">(v0, v2)</td><td align="center">(v0, v4, v3)</td><td align="center">(v0, v4)</td><td align="center">(v0, v4, v3, v5)</td></tr><tr><td align="center">pathdist[i]</td><td align="center">0</td><td align="center"><em><strong>∞</strong></em></td><td align="center">10</td><td align="center">50</td><td align="center">30</td><td align="center">60</td></tr><tr><td align="center">flag[i]</td><td align="center">1</td><td align="center">0→1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T vexs[MAX_VERTEX_NUM];<br>    AdjMatrix arcs;<br>    <span class="hljs-type">int</span> vexnum,arcnum;<br>&#125; Graph;<br><br><span class="hljs-type">int</span> path[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br><span class="hljs-type">int</span> pathdist[MAX_VERTEX_NUM];<br><span class="hljs-type">bool</span> flag[MAX_VERTEX_NUM];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShortestPath_D</span><span class="hljs-params">(Graph G,T v)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i) &#123;<br>        pathdist[i]=INFINITY;<br>        flag[i]=<span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> k=<span class="hljs-built_in">LocateVex</span>(G,v);<br>    path[k][<span class="hljs-number">0</span>]=k;<br>    pathdist[k]=<span class="hljs-number">0</span>;<br>    flag[k]=<span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;t&lt;G.vexnum;++t) &#123; <span class="hljs-comment">// t记轮数</span><br>        <span class="hljs-type">int</span> min=INFINITY,minidx;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i) &#123;<br>            <span class="hljs-keyword">if</span> (!flag[i]&amp;&amp;pathdist[k]+G.arcs[k][i]&lt;pathdist[i]) &#123;<br>                <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    path[i][j]=path[k][j];<br>                    ++j;<br>                &#125;<br>                <span class="hljs-keyword">while</span> (path[k][j<span class="hljs-number">-1</span>]!=k);<br>                path[i][j]=i;<br>                pathdist[i]=pathdist[k]+G.arcs[k][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!flag[i]&amp;&amp;pathdist[i]&lt;min) &#123;<br>                min=pathdist[i];<br>                minidx=i;<br>            &#125;<br>        &#125;<br>        flag[minidx]=<span class="hljs-literal">true</span>;<br>        k=minidx;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><ul><li>时间复杂度：O(n^2)，其中 n 为顶点数</li><li>局限：若图中含有负数权值，则无法保证按最短路径长度递增的次序产生最短路径，即 Dijkstra 算法很有可能失效；解决方法是：先将所有权值映射到正区间再使用 Dijkstra 算法，或采用改进的 Bellman-Ford 算法</li></ul><h4 id="Floyd-算法：求每一对顶点之间的最短路径"><a href="#Floyd-算法：求每一对顶点之间的最短路径" class="headerlink" title="Floyd 算法：求每一对顶点之间的最短路径"></a>Floyd 算法：求每一对顶点之间的最短路径</h4><p>求每一对顶点之间的最短路径，解决方法是：每次以一个顶点为始点执行 n 次 Dijkstra 算法，或采用 Floyd 算法</p><h5 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h5><p>基本思想：在每一对顶点之间所有存在的路径中，选出一条长度最短的路径；关键是要确认两点间的所有路径都被比较过</p><ul><li>若从 vi 到 vj 的弧存在，则存在路径 (vi, vj)</li><li>若路径 (vi, vk) 和 (vk, vj) 存在，则存在路径 (vi, vk, vj)</li><li>若路径 (vi, …, vk) 和 (vk, …, vj) 存在，则存在路径 (vi, …, vk, …, vj)</li><li>以此类推，从 vi 到 vj 的最短路径为上述这些路径中长度最短者</li></ul><h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><p>实现过程示例：求图中每一对顶点之间的最短路径，用数组 pathdist 存储，pathdist[i][j] 表示从 vi 到 vj 的已比较的路径中的最短者（结合代码理解）</p><img src="..\img\ep7\image-20230116232008436.png" alt="image-20230116232008436" style="zoom:25%;" /><ul><li><p>初始化：</p><img src="..\img\ep7\image-20230116232405378.png" alt="image-20230116232405378" style="zoom:25%;" /></li><li><p>pathdist[i][j] 与路径 (vi, …, v0, …, vj) 的比较：</p><img src="..\img\ep7\image-20230116232528809.png" alt="image-20230116232528809" style="zoom:25%;" /></li><li><p>pathdist[i][j] 与路径 (vi, …, v1, …, vj) 的比较：</p><img src="..\img\ep7\image-20230116232558608.png" alt="image-20230116232558608" style="zoom:25%;" /></li><li><p>pathdist[i][j] 与路径 (vi, …, v2, …, vj) 的比较：</p><img src="..\img\ep7\image-20230116232630516.png" alt="image-20230116232630516" style="zoom:25%;" /></li><li><p>pathdist[i][j] 与路径 (vi, …, v3, …, vj) 的比较：</p><img src="..\img\ep7\image-20230116232651353.png" alt="image-20230116232651353" style="zoom:25%;" /></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T vexs[MAX_VERTEX_NUM];<br>    AdjMatrix arcs;<br>    <span class="hljs-type">int</span> vexnum,arcnum;<br>&#125; Graph;<br><br><span class="hljs-type">int</span> path[MAX_VERTEX_NUM][MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br><span class="hljs-type">int</span> pathdist[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShortestPath_F</span><span class="hljs-params">(Graph G)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;G.vexnum;++j) &#123;<br>            path[i][j][<span class="hljs-number">0</span>]=i;<br>            path[i][j][<span class="hljs-number">1</span>]=j;<br>            <span class="hljs-keyword">if</span> (i==j)<br>                pathdist[i][j]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                pathdist[i][j]=G.arcs[i][j];<br>        &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;++k)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;G.vexnum;++j) &#123;<br>                <span class="hljs-keyword">if</span> (pathdist[i][k]+pathdist[k][j]&lt;pathdist[i][j]) &#123;<br>                    pathdist[i][j]=pathdist[i][k]+pathdist[k][j];<br>                    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        path[i][j][t]=path[i][k][t];<br>                        ++t;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span> (path[i][k][t<span class="hljs-number">-1</span>]!=k);<br>                    <span class="hljs-type">int</span> tmp=t;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        path[i][j][t]=path[k][j][t-tmp+<span class="hljs-number">1</span>];<br>                        ++t;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span> (path[k][j][t-tmp]!=j);<br>                &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h5><ul><li>时间复杂度：O(n^3)，其中 n 为顶点数</li><li>允许有负数权值</li></ul><h3 id="6-拓扑排序"><a href="#6-拓扑排序" class="headerlink" title="6 - 拓扑排序"></a>6 - 拓扑排序</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>对于<strong>有向图</strong>，给出其顶点的线性序列 (v_0, v_1, …, v_n-1)，如果该线性序列满足：若图中从顶点 v_i 到顶点 v_j 有一条路径，则序列中顶点 v_i 必在顶点 v_j 之前，那么称该线性序列为<strong>拓扑序列</strong>；求有向图顶点的拓扑序列的过程，称作<strong>拓扑排序</strong></p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>有向图可以表示工程的施工流程、产品的生产流程、学生的课程安排等：有向图的顶点表示一项子工程、一个子产品或一门课程，弧 &lt;v_i, v_j&gt; 表示子工程、子产品或课程 v_i 必须在 v_j 之前完成</p><p>对有向图的顶点进行拓扑排序，对应于这些实际问题就是为各项子工程、各个子产品或各门课程排出一个线性的顺序关系</p><p>若受条件限制这些工作必须串行，则应该按照拓扑序列安排执行的先后顺序</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>某项工程的施工流程为：</p><ul><li>子工程 1：无条件</li><li>子工程 2：在子工程 1, 3 之后</li><li>子工程 3：在子工程 1 之后</li><li>子工程 4：在子工程 1, 6 之后</li><li>子工程 5：在子工程 3, 4, 6 之后</li><li>子工程 6：无条件</li></ul><p>要求为各项子工程排出一个线性的顺序关系</p><ol><li><p>该工程的施工流程对应的有向图为：（唯一）</p><img src="..\img\ep7\image-20230117122543014.png" alt="image-20230117122543014" style="zoom:25%;" /></li><li><p>对有向图的顶点进行拓扑排序，得到的拓扑序列为：（不唯一且不一定存在）</p><ul><li>1, 3, 2, 6, 4, 5</li><li>6, 1, 4, 3, 2, 5</li><li>……</li></ul></li></ol><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>用顶点表示活动，用弧表示活动间优先关系的<strong>有向无环图</strong>称为 <strong>AOV-网（Activity On Vertex network）</strong></p><p><strong>在 AOV-网中，要求不能出现有向环</strong>；因为有向环表示某项活动应以自己为先决条件，而显然这是荒谬的（死循环，拓扑序列不存在）</p><h4 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h4><h5 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h5><ol><li>从图中选择一个入度为零的顶点加入序列</li><li>从图中删除此顶点及由它发出的弧</li><li>重复执行 1, 2，直至所有顶点加入序列（完成拓扑排序）或图中再也没有入度为零的顶点（图中存在有向环，拓扑序列不存在）</li></ol><p>在<strong>邻接矩阵</strong>上实现的具体算法：</p><p>设置 flag 数组（flag[i] &#x3D; 0 表示顶点 vexs[i] 存在；flag[i] &#x3D; 1 表示顶点 vexs[i] 被删除）</p><ul><li>选择一个入度为零的顶点：找全零的一列（还需根据 flag 数组判断顶点存在）</li><li>删除此顶点及由它发出的弧：flag 数组对应元素置为 1；对应行置为全零</li></ul><p>在<strong>邻接表</strong>上实现的具体算法：</p><p>在头结点增加一个域，存放顶点入度；设置一个栈，存放入度为零的顶点</p><ol><li>建立邻接表存储图</li><li>查找头结点向量中入度为零的顶点，将其压入栈</li><li>重复执行以下操作，直至栈空：<ul><li>栈顶元素 v 出栈，将其加入序列</li><li>在头结点向量中查找 v 的所有邻接点，将其入度减 1，若其入度变成零，则将其压入栈</li></ul></li><li>栈空时，若所有顶点都已加入序列，则完成拓扑排序，否则说明图中存在有向环，拓扑序列不存在</li></ol><h5 id="在邻接表上的实现"><a href="#在邻接表上的实现" class="headerlink" title="在邻接表上的实现"></a>在邻接表上的实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> &#123;<br>    <span class="hljs-type">int</span> adjvex;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>* nextarc;<br>&#125; ArcNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T vex;<br>    <span class="hljs-type">int</span> indegree;<br>    ArcNode* firstarc;<br>&#125; VNode,AdjList[MAX_VERTEX_NUM];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    AdjList vexs;<br>    <span class="hljs-type">int</span> vexnum,arcnum;<br>&#125; Graph;<br><br><span class="hljs-comment">// 若成功完成拓扑排序，则返回true；若图中存在有向环，拓扑序列不存在，则返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(Graph G,T TopoSeq[])</span> </span>&#123;<br>    Stack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)<br>        <span class="hljs-keyword">if</span> (G.vexs[i].indegree==<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">Push</span>(S,G.vexs[i].vex);<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">StackEmpty</span>(S)) &#123;<br>        T v=<span class="hljs-built_in">Pop</span>(S);<br>        TopoSeq[cnt++]=v;<br>        <span class="hljs-type">int</span> k=<span class="hljs-built_in">LocateVex</span>(G,v);<br>        <span class="hljs-keyword">for</span> (ArcNode* p=G.vexs[k].firstarc;p;p=p-&gt;nextarc) &#123;<br>            --G.vexs[p-&gt;adjvex].indegree;<br>            <span class="hljs-keyword">if</span> (G.vexs[p-&gt;adjvex].indegree==<span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">Push</span>(S,G.vexs[p-&gt;adjvex].vex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt&lt;G.vexnum)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-关键路径"><a href="#7-关键路径" class="headerlink" title="7 - 关键路径"></a>7 - 关键路径</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><h5 id="AOE-网"><a href="#AOE-网" class="headerlink" title="AOE-网"></a>AOE-网</h5><p>用顶点表示事件，用弧表示活动，用弧上权值表示活动持续时间的<strong>带权有向无环图</strong>称为 <strong>AOE-网（Activity On Edge network）</strong>；AOE-网可以用来估算工程完成时间</p><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p>某项工程的进度图如下：</p><img src="..\img\ep7\image-20230127151451896.png" alt="image-20230127151451896" style="zoom:25%;" /><p>入度为零的顶点称为<strong>源点</strong>，可以看作工程的开始点；出度为零的顶点称为<strong>汇点</strong>，可以看作工程的完成点；AOE-网通常只有一个源点和一个汇点</p><p>分析过程如下：</p><ol><li><p>求<strong>拓扑序列</strong>：1, 3, 2, 4, 5, 6</p><p>求<strong>逆拓扑序列</strong>：6, 5, 4, 2, 3, 1（两种求法：依次将出度为零的顶点加入序列；反写拓扑序列）</p><p>拓扑序列中第一个顶点为源点，最后一个顶点为汇点</p></li><li><p>按照拓扑序列的顺序，计算各顶点所表示<strong>事件的最早发生时间 Ve</strong>（求法：木桶原理，约定源点的最早发生时间为 0，求所有指向某一事件的活动中，弧尾事件的最早发生时间与该活动持续时间之和的最大值）</p><p>按照逆拓扑序列的顺序，计算各顶点所表示<strong>事件的最晚发生时间 Vl</strong>（求法：想象赶 DDL，约定汇点的最晚发生时间等于其最早发生时间，求所有指离某一事件的活动中，弧头事件的最晚发生时间与该活动持续时间之差的最小值）</p><p>列下表：</p><table><thead><tr><th align="center"></th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th></tr></thead><tbody><tr><td align="center">Ve</td><td align="center">0</td><td align="center">19</td><td align="center">15</td><td align="center">29</td><td align="center">38</td><td align="center">43</td></tr><tr><td align="center">Vl</td><td align="center">0</td><td align="center">19</td><td align="center">15</td><td align="center">37</td><td align="center">38</td><td align="center">43</td></tr></tbody></table></li><li><p>计算各弧所表示<strong>活动的最早开始时间 e</strong>（弧尾事件的最早发生时间）</p><p>计算各弧所表示<strong>活动的最晚开始时间 l</strong>（弧头事件的最晚发生时间与该活动持续时间之差）</p><p>列下表：</p><table><thead><tr><th align="center"></th><th align="center">&lt;1, 2&gt;</th><th align="center">&lt;1, 3&gt;</th><th align="center">&lt;2, 4&gt;</th><th align="center">&lt;2, 5&gt;</th><th align="center">&lt;3, 2&gt;</th><th align="center">&lt;3, 5&gt;</th><th align="center">&lt;4, 6&gt;</th><th align="center">&lt;5, 6&gt;</th></tr></thead><tbody><tr><td align="center">e</td><td align="center">0</td><td align="center">0</td><td align="center">19</td><td align="center">19</td><td align="center">15</td><td align="center">15</td><td align="center">29</td><td align="center">38</td></tr><tr><td align="center">l</td><td align="center">17</td><td align="center">0</td><td align="center">27</td><td align="center">19</td><td align="center">15</td><td align="center">27</td><td align="center">37</td><td align="center">38</td></tr><tr><td align="center">l-e</td><td align="center">17</td><td align="center"><strong>0</strong></td><td align="center">8</td><td align="center"><strong>0</strong></td><td align="center"><strong>0</strong></td><td align="center">12</td><td align="center">8</td><td align="center"><strong>0</strong></td></tr></tbody></table></li></ol><h5 id="示例引出的重要概念"><a href="#示例引出的重要概念" class="headerlink" title="示例引出的重要概念"></a>示例引出的重要概念</h5><ul><li><p><strong>关键活动</strong>：l-e &#x3D; 0 的活动</p></li><li><p><strong>关键路径</strong>：由关键活动组成的路径，关键路径长度等于汇点的发生时间，即完成工程的最短时间，如下图：</p><img src="..\img\ep7\image-20230127164013423.png" alt="image-20230127164013423" style="zoom:25%;" /></li></ul><p>注意：</p><ol><li>增加某一关键活动持续时间将增加关键路径长度，延长工期；因此，如果工期固定，那么关键活动的开始时间不能耽误</li><li>一定程度上，减少某一关键活动持续时间将减少关键路径长度，缩短工期；但减少某一关键活动持续时间可能改变关键路径，继续减少该活动持续时间将无法缩短工期</li><li>若有多条关键路径，则只使一条关键路径的长度减少将无法缩短工期，需使所有关键路径的长度同时减少</li></ol><h4 id="求关键路径算法"><a href="#求关键路径算法" class="headerlink" title="求关键路径算法"></a>求关键路径算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> &#123;<br>    <span class="hljs-type">int</span> adjvex;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> e;<br>    <span class="hljs-type">int</span> l;<br>    <span class="hljs-type">int</span> tag; <span class="hljs-comment">// tag为1，该弧表示关键活动；tag为0，该弧表示非关键活动</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>* nextarc;<br>&#125; ArcNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T vex;<br>    <span class="hljs-type">int</span> indegree;<br>    ArcNode* firstarc;<br>&#125; VNode,AdjList[MAX_VERTEX_NUM];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    AdjList vexs;<br>    <span class="hljs-type">int</span> vexnum,arcnum;<br>&#125; Graph;<br><br><span class="hljs-type">int</span> Ve[MAX_VERTEX_NUM],Vl[MAX_VERTEX_NUM];<br><br><span class="hljs-comment">// 拓扑排序过程中完成各顶点Ve的计算，若成功完成拓扑排序，则返回true；若图中存在有向环，拓扑序列不存在，则返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(Graph G,T TopoSeq[])</span> </span>&#123;<br>    Stack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)<br>        <span class="hljs-keyword">if</span> (G.vexs[i].indegree==<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">Push</span>(S,G.vexs[i].vex);<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">StackEmpty</span>(S)) &#123;<br>        T v=<span class="hljs-built_in">Pop</span>(S);<br>        TopoSeq[cnt++]=v;<br>        <span class="hljs-type">int</span> k=<span class="hljs-built_in">LocateVex</span>(G,v);<br>        <span class="hljs-keyword">for</span> (ArcNode* p=G.vexs[k].firstarc;p;p=p-&gt;nextarc) &#123;<br>            --G.vexs[p-&gt;adjvex].indegree;<br>            <span class="hljs-keyword">if</span> (G.vexs[p-&gt;adjvex].indegree==<span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">Push</span>(S,G.vexs[p-&gt;adjvex].vex);<br>            <span class="hljs-comment">// *****增加的代码：各顶点Ve的计算*****</span><br>            <span class="hljs-keyword">if</span> (Ve[k]+p-&gt;weight&gt;Ve[p-&gt;adjvex])<br>                Ve[p-&gt;adjvex]=Ve[k]+p-&gt;weight;<br>            <span class="hljs-comment">// ********************************</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt&lt;G.vexnum)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 若成功完成拓扑排序，则返回true；若图中存在有向环，拓扑序列不存在，则返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CriticalPath</span><span class="hljs-params">(Graph G)</span> </span>&#123;<br>    T TopoSeq[MAX_VERTEX_NUM];<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">TopologicalSort</span>(G,TopoSeq))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 初始化各顶点Vl</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)<br>        Vl[i]=Ve[G.vexnum<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-comment">// 各顶点Vl的计算</span><br>    <span class="hljs-type">int</span> cnt=G.vexnum<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (cnt) &#123;<br>        <span class="hljs-type">int</span> k=<span class="hljs-built_in">LocateVex</span>(G,TopoSeq[--cnt]);<br>        <span class="hljs-keyword">for</span> (ArcNode* p=G.vexs[k].firstarc;p;p=p-&gt;nextarc)<br>            <span class="hljs-keyword">if</span> (Vl[p-&gt;adjvex]-p-&gt;weight&lt;Vl[k])<br>                Vl[k]=Vl[p-&gt;adjvex]-p-&gt;weight;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 各弧e和l的计算，标识关键活动</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)<br>        <span class="hljs-keyword">for</span> (ArcNode* p=G.vexs[i].firstarc;p;p=p-&gt;nextarc) &#123;<br>            p-&gt;e=Ve[i];<br>            p-&gt;l=Vl[p-&gt;adjvex]-p-&gt;weight;<br>            <span class="hljs-keyword">if</span> (p-&gt;e==p-&gt;l)<br>                p-&gt;tag=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                p-&gt;tag=<span class="hljs-number">0</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树和二叉树</title>
    <link href="/2023/03/02/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/03/02/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>数据结构课程笔记 ep6</p><span id="more"></span><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="1-树的定义"><a href="#1-树的定义" class="headerlink" title="1 - 树的定义"></a>1 - 树的定义</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>树（Tree）</strong>是 n(n≥0) 个结点的有限集。当 n&#x3D;0 时称为<strong>空树</strong>。在任意一棵非空树中，有且仅有一个称为<strong>根（Root）</strong>的结点，其余的结点可分为 m(m≥0) 个互不相交的有限集 T1,T2,…,Tm，其中每一个集合又成为一棵树，并且称为根的<strong>子树</strong>。同理，每一棵子树又可以分为若干个互不相交的有限集。</p><h5 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h5><ul><li>无序树</li><li>有序树</li></ul><h5 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h5><ul><li><strong>结点（Node）</strong>：包含一个数据元素及若干个指向其子树的分支</li><li><strong>度（Degree）</strong>：结点的度是一个结点拥有的子树数目；树的度是一棵树上所有结点度的最大值</li><li><strong>叶子结点</strong>：度为零的结点</li><li><strong>分支结点</strong>：度大于零的结点</li><li><strong>结点之间的关系</strong>：孩子、双亲、兄弟、堂兄弟、祖先、子孙</li><li><strong>深度 &#x2F; 结点的层次</strong>：从根结点到该结点所经过的路径长度加 1</li><li><strong>高度</strong>：从该结点向下到某个叶子结点所经过的最长路径长度加 1</li><li><strong>树的深度</strong>：树中叶子结点具有的最大深度</li><li><strong>树的高度</strong>：树中根结点具有的高度</li></ul><h5 id="延展概念"><a href="#延展概念" class="headerlink" title="延展概念"></a>延展概念</h5><p><strong>森林</strong>是 m(m≥0) 棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。所以任何一棵非空树是一个二元组 Tree &#x3D; (root, F)（root 是根结点；F 是子树森林）。</p><img src="/img/ep6/image-20221019132111728.png" alt="image-20221019132111728" style="zoom: 25%;" /><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs scss">ADT Tree &#123;<br>数据对象D：<br>D是具有相同特性的数据元素的集合。<br>数据关系R：<br>若D为空集：<br>则称为空树。<br>否则：<br>        <span class="hljs-number">1</span>.在D中存在唯一的称为根的数据元素root；<br>        <span class="hljs-number">2</span>.当n&gt;<span class="hljs-number">1</span>时，其余结点可分为<span class="hljs-built_in">m</span>(m&gt;<span class="hljs-number">0</span>)个互不相交的有限集T1,T2,…,Tm，其中每一棵子集本身又是一棵符合本定义的树，称为根root的子树。<br>基本操作：<br>查找类<br><span class="hljs-built_in">Root</span>(T)                       <span class="hljs-comment">// 求根结点</span><br><span class="hljs-built_in">Value</span>(T,e)                    <span class="hljs-comment">// 求当前结点的元素值</span><br><span class="hljs-built_in">Parent</span>(T,e)                   <span class="hljs-comment">// 求当前结点的双亲结点</span><br><span class="hljs-built_in">LeftChild</span>(T,e)                <span class="hljs-comment">// 求当前结点的最左孩子</span><br><span class="hljs-built_in">RightSibling</span>(T,e)             <span class="hljs-comment">// 求当前结点的右兄弟</span><br><span class="hljs-built_in">TreeEmpty</span>(T)                  <span class="hljs-comment">// 判空</span><br><span class="hljs-built_in">TreeDepth</span>(T)                  <span class="hljs-comment">// 求深度</span><br><span class="hljs-built_in">TraverseTree</span>(T,Visit())       <span class="hljs-comment">// 遍历</span><br>插入类<br><span class="hljs-built_in">InitTree</span>(&amp;T)                  <span class="hljs-comment">// 初始化树</span><br><span class="hljs-built_in">CreateTree</span>(&amp;T,definition)     <span class="hljs-comment">// 按定义构造树</span><br><span class="hljs-built_in">Assign</span>(&amp;T,e,value)            <span class="hljs-comment">// 给当前结点赋值</span><br><span class="hljs-built_in">InsertChild</span>(&amp;T,&amp;p,i,c)        <span class="hljs-comment">// 将以c为根的树插入为结点p的第i棵子树</span><br>删除类<br><span class="hljs-built_in">ClearTree</span>(&amp;T)                 <span class="hljs-comment">// 清空树</span><br><span class="hljs-built_in">DestroyTree</span>(&amp;T)               <span class="hljs-comment">// 销毁树</span><br><span class="hljs-built_in">DeleteChild</span>(&amp;T,&amp;p,i)          <span class="hljs-comment">// 删除结点p的第i棵子树</span><br>&#125; ADT Tree<br></code></pre></td></tr></table></figure><h3 id="2-二叉树的定义与性质"><a href="#2-二叉树的定义与性质" class="headerlink" title="2 - 二叉树的定义与性质"></a>2 - 二叉树的定义与性质</h3><h4 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>二叉树（Binary tree）</strong>是 n(n≥0) 个结点的有限集合。这个集合或是空集，或是由一个根结点以及两棵互不相交的<strong>左子树</strong>和<strong>右子树</strong>所组成。左子树和右子树分别又是一棵二叉树。</p><h4 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scss">ADT Binary tree &#123;<br>数据对象D：<br>D是具有相同特性的数据元素的集合。<br>数据关系R：<br>若D为空集：<br>则称为空树。<br>否则：<br>        <span class="hljs-number">1</span>.在D中存在唯一的称为根的数据元素root；<br>        <span class="hljs-number">2</span>.当n&gt;<span class="hljs-number">1</span>时，其余结点可分为<span class="hljs-number">2</span>个互不相交的有限集，称为根root的左子树和右子树，左子树和右子树本身又是一棵符合本定义的二叉树。<br>基本操作：<br>查找类<br><span class="hljs-built_in">Root</span>(T)                       <span class="hljs-comment">// 求根结点</span><br><span class="hljs-built_in">Value</span>(T,e)                    <span class="hljs-comment">// 求当前结点的元素值</span><br><span class="hljs-built_in">Parent</span>(T,e)                   <span class="hljs-comment">// 求当前节点的双亲结点</span><br><span class="hljs-built_in">LeftChild</span>(T,e)<br><span class="hljs-built_in">RightChild</span>(T,e)               <span class="hljs-comment">// 求当前结点的孩子结点</span><br><span class="hljs-built_in">LeftSibling</span>(T,e)<br><span class="hljs-built_in">RightSibling</span>(T,e)             <span class="hljs-comment">// 求当前结点的左右兄弟</span><br><span class="hljs-built_in">BiTreeEmpty</span>(T)                <span class="hljs-comment">// 判空</span><br><span class="hljs-built_in">BiTreeDepth</span>(T)                <span class="hljs-comment">// 求深度</span><br><span class="hljs-built_in">PreOrderTraverse</span>(T,Visit())   <span class="hljs-comment">// 先序遍历</span><br><span class="hljs-built_in">InOrderTraverse</span>(T,Visit())    <span class="hljs-comment">// 中序遍历</span><br><span class="hljs-built_in">PostOrderTraverse</span>(T,Visit())  <span class="hljs-comment">// 后序遍历</span><br><span class="hljs-built_in">LevelOrderTraverse</span>(T,Visit()) <span class="hljs-comment">// 层序遍历</span><br>插入类<br><span class="hljs-built_in">InitBiTree</span>(&amp;T)                <span class="hljs-comment">// 初始化二叉树</span><br><span class="hljs-built_in">CreateBiTree</span>(&amp;T,definition)   <span class="hljs-comment">// 按定义构造二叉树</span><br><span class="hljs-built_in">Assign</span>(&amp;T,e,value)            <span class="hljs-comment">// 给当前结点赋值</span><br><span class="hljs-built_in">InsertChild</span>(&amp;T,&amp;p,LR,c)       <span class="hljs-comment">// 将以c为根的二叉树插入为结点p的左或右子树</span><br>删除类<br><span class="hljs-built_in">ClearBiTree</span>(&amp;T)               <span class="hljs-comment">// 清空二叉树</span><br><span class="hljs-built_in">DestroyBiTree</span>(&amp;T)             <span class="hljs-comment">// 销毁二叉树</span><br><span class="hljs-built_in">DeleteChild</span>(&amp;T,&amp;p,LR)         <span class="hljs-comment">// 删除结点p的左或右子树</span><br>&#125; ADT Binary tree<br></code></pre></td></tr></table></figure><h4 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h4><p>1.二叉树的第 i(i≥1) 层至多有 $$2^{i-1}$$ 个结点</p><p>2.深度为 k(k≥1) 的二叉树至多含 $$2^k-1$$ 个结点</p><p>3.若二叉树含有 n0 个叶子结点和 n2 个度为 2 的结点，则有关系式 $$n_0&#x3D;n_2+1$$</p><p>   证明：</p><p>​结点总数 $$n&#x3D;n_0+n_1+n_2$$</p><p>​分支总数 $$b&#x3D;n_1+2n_2&#x3D;n-1$$</p><p>​得 $$n_0&#x3D;n_2+1$$</p><h5 id="铺垫：二叉树的分类"><a href="#铺垫：二叉树的分类" class="headerlink" title="铺垫：二叉树的分类"></a>铺垫：二叉树的分类</h5><ul><li><p>一般的二叉树</p><img src="/img/ep6/image-20221020141624210.png" alt="image-20221020141624210" style="zoom:25%;" /></li><li><p><strong>满二叉树</strong>：深度为 k 且含有 $$2^k-1$$ 个结点的二叉树</p><img src="/img/ep6/image-20221020132816312.png" alt="image-20221020132816312" style="zoom:25%;" /></li><li><p><strong>完全二叉树</strong>：树中所含的 n 个结点和满二叉树中编号为 1 至 n 的结点一一对应</p><img src="/img/ep6/image-20221020133027149.png" alt="image-20221020133027149" style="zoom:25%;" /></li></ul><p>4.具有 n 个结点的<strong>完全二叉树</strong>的深度为 $$⌊log_2n⌋+1$$</p><p>5.若对含 n 个结点的<strong>完全二叉树</strong>从上至下、从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p><ul><li>若 i&#x3D;1，则该结点是根结点，无双亲；否则其双亲结点编号是 ⌊i&#x2F;2⌋</li><li>若 2i&gt;n，则该结点无左孩子；否则其左孩子结点编号是 2i</li><li>若 2i+1&gt;n，则该结点无右孩子；否则其右孩子结点编号是 2i+1</li></ul><h3 id="3-二叉树的存储"><a href="#3-二叉树的存储" class="headerlink" title="3 - 二叉树的存储"></a>3 - 二叉树的存储</h3><h4 id="二叉树的顺序存储表示"><a href="#二叉树的顺序存储表示" class="headerlink" title="二叉树的顺序存储表示"></a>二叉树的顺序存储表示</h4><p>用一组地址连续的存储单元从上至下、从左至右存储二叉树上的结点元素。</p><ul><li>完全二叉树容易用顺序存储表示</li><li>对于一般的二叉树，可以参照完全二叉树，将对应的完全二叉树中存在但该二叉树中不存在的结点数据元素置空</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> T SqBiTree[MAX_TREE_SIZE]; <span class="hljs-comment">// 1号单元存储根结点</span><br><br>SqBiTree bt;<br></code></pre></td></tr></table></figure><h4 id="二叉树的链式存储表示"><a href="#二叉树的链式存储表示" class="headerlink" title="二叉树的链式存储表示"></a>二叉树的链式存储表示</h4><h5 id="两个指针域（二叉链表）"><a href="#两个指针域（二叉链表）" class="headerlink" title="两个指针域（二叉链表）"></a>两个指针域（二叉链表）</h5><img src="/img/ep6/image-20221021092557581.png" alt="image-20221021092557581" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> &#123;<br>T data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild,*rchild; <span class="hljs-comment">// 左右孩子指针</span><br>&#125; BiTNode,*BiTree;<br><br>BiTree bt;<br></code></pre></td></tr></table></figure><h5 id="三个指针域（三叉链表）"><a href="#三个指针域（三叉链表）" class="headerlink" title="三个指针域（三叉链表）"></a>三个指针域（三叉链表）</h5><img src="/img/ep6/image-20221021092705470.png" alt="image-20221021092705470" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> &#123;<br>    T data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild,*rchild,*parent; <span class="hljs-comment">// 左右孩子指针和双亲指针</span><br>&#125; BiTNode,*BiTree;<br><br>BiTree bt;<br></code></pre></td></tr></table></figure><h5 id="一个指针域（双亲链表）"><a href="#一个指针域（双亲链表）" class="headerlink" title="一个指针域（双亲链表）"></a>一个指针域（双亲链表）</h5><img src="/img/ep6/image-20221021092758693.png" alt="image-20221021092758693" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 静态链表实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T data;<br>    <span class="hljs-type">int</span> parent; <span class="hljs-comment">// 双亲指针</span><br>    <span class="hljs-type">int</span> LRTag;<br>&#125; BiTNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    BiTNode nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> num_node; <span class="hljs-comment">// 结点数目</span><br>    <span class="hljs-type">int</span> root; <span class="hljs-comment">// 根结点的位置</span><br>&#125; BiTree;<br><br>BiTree bt;<br></code></pre></td></tr></table></figure><h3 id="4-二叉树的遍历"><a href="#4-二叉树的遍历" class="headerlink" title="4 - 二叉树的遍历"></a>4 - 二叉树的遍历</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><ul><li>分为先根序、中根序、后根序三种遍历顺序，每种遍历顺序又有递归实现和非递归实现</li><li>以下 9 种算法，时间复杂度都为 O(n)，空间复杂度都为 O(n)</li><li>示例图：</li></ul><img src="/img/ep6/image-20221021100035659.png" alt="image-20221021100035659" style="zoom:25%;" /><h5 id="先根序"><a href="#先根序" class="headerlink" title="先根序"></a>先根序</h5><p>算法描述：若二叉树为空树，则空操作；否则，</p><ol><li>访问根结点</li><li>先根序遍历左子树</li><li>先根序遍历右子树</li></ol><p>示例：示例图二叉树遍历顺序为 - + a * b - c d &#x2F; e f</p><p>递归实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (T) &#123;<br><span class="hljs-built_in">visit</span>(T-&gt;data); <span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild,visit); <span class="hljs-comment">// 先根序遍历左子树</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild,visit); <span class="hljs-comment">// 先根序遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归实现：</p><p>先根序遍历时结点输出顺序是根、左孩子和右孩子，根据这个特点可以使用一个栈实现非递归的先根序遍历，右孩子、左孩子和根依次入栈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 第一种方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123;<br>    Stack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    <span class="hljs-keyword">if</span> (T)<br>        <span class="hljs-built_in">Push</span>(S,T);<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">StackEmpty</span>(S)) &#123;<br>        BiTree t=<span class="hljs-built_in">Pop</span>(S);<br>        <span class="hljs-built_in">visit</span>(t-&gt;data); <span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-keyword">if</span> (t-&gt;rchild)<br>            <span class="hljs-built_in">Push</span>(S,t-&gt;rchild); <span class="hljs-comment">// 右子树入栈</span><br>        <span class="hljs-keyword">if</span> (t-&gt;lchild)<br>            <span class="hljs-built_in">Push</span>(S,t-&gt;lchild); <span class="hljs-comment">// 左子树入栈</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第二种方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoFarLeft</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e),Stack &amp;S)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (T) &#123;<br>    <span class="hljs-built_in">visit</span>(T-&gt;data); <span class="hljs-comment">// 找到最左下的结点，沿途结点立即访问</span><br>    <span class="hljs-keyword">if</span> (T-&gt;rchild)<br>        <span class="hljs-built_in">Push</span>(S,T-&gt;rchild); <span class="hljs-comment">// 沿途右子树自顶向下入栈</span><br>        T=T-&gt;lchild;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123;<br>    Stack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    <span class="hljs-keyword">while</span> (T) &#123;<br>        <span class="hljs-built_in">GoFarLeft</span>(T,visit,S);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">StackEmpty</span>(S))<br>            T=<span class="hljs-built_in">Pop</span>(S);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中根序"><a href="#中根序" class="headerlink" title="中根序"></a>中根序</h5><p>算法描述：若二叉树为空树，则空操作；否则，</p><ol><li>中根序遍历左子树</li><li>访问根结点</li><li>中根序遍历右子树</li></ol><p>示例：示例图二叉树遍历顺序为 a + b * c - d - e &#x2F; f</p><p>递归实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (T) &#123;<br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lchild,visit); <span class="hljs-comment">// 中根序遍历左子树</span><br>        <span class="hljs-built_in">visit</span>(T-&gt;data); <span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rchild,visit); <span class="hljs-comment">// 中根序遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归实现：</p><p>中根序遍历时结点输出顺序是左孩子、根和右孩子，根据这个特点可以使用一个栈实现非递归的中根序遍历，右孩子、根和左孩子依次入栈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 第一种方式</span><br><span class="hljs-function">BiTree <span class="hljs-title">GoFarLeft</span><span class="hljs-params">(BiTree T,Stack &amp;S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!T)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (T-&gt;lchild) &#123; <span class="hljs-comment">// 找到最左下的结点</span><br>        <span class="hljs-built_in">Push</span>(S,T); <span class="hljs-comment">// 沿途结点入栈，最左下的结点没有入栈</span><br>        T=T-&gt;lchild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> T; <span class="hljs-comment">// 返回最左下的结点</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123;<br>    Stack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    BiTree t=<span class="hljs-built_in">GoFarLeft</span>(T,S);<br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        <span class="hljs-built_in">visit</span>(t-&gt;data);<br>        <span class="hljs-keyword">if</span> (t-&gt;rchild)<br>            t=<span class="hljs-built_in">GoFarLeft</span>(t-&gt;rchild,S);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">StackEmpty</span>(S))<br>            t=<span class="hljs-built_in">Pop</span>(S);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第二种方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoFarLeft</span><span class="hljs-params">(BiTree &amp;T,Stack &amp;S)</span> </span>&#123; <span class="hljs-comment">// 注意：T需要引用传递</span><br>    <span class="hljs-keyword">while</span> (T) &#123;<br>        <span class="hljs-built_in">Push</span>(S,T);<br>        T=T-&gt;lchild;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123;<br>    Stack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (T)<br>        <span class="hljs-built_in">GoFarLeft</span>(T,S);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">StackEmpty</span>(S)) &#123;<br>            T=<span class="hljs-built_in">Pop</span>(S);<br>            <span class="hljs-built_in">visit</span>(T-&gt;data);<br>            T=T-&gt;rchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后根序"><a href="#后根序" class="headerlink" title="后根序"></a>后根序</h5><p>算法描述：若二叉树为空树，则空操作；否则，</p><ol><li>后根序遍历左子树</li><li>后根序遍历右子树</li><li>访问根结点</li></ol><p>示例：示例图二叉树遍历顺序为 a b c d - * + e f &#x2F; -</p><p>递归实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (T) &#123;<br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lchild,visit); <span class="hljs-comment">// 后根序遍历左子树</span><br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rchild,visit); <span class="hljs-comment">// 后根序遍历右子树</span><br>        <span class="hljs-built_in">visit</span>(T-&gt;data); <span class="hljs-comment">// 访问根结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归实现：</p><p>需要一个标记区别回到根结点时是从左子树返回还是从右子树返回的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 第一种方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123;<br>    BiTree S[stacksize];<br>    <span class="hljs-type">int</span> tag[stacksize],top=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">while</span> (T) &#123; <span class="hljs-comment">// 一路向左</span><br>            S[++top]=T;<br>            tag[top]=<span class="hljs-number">0</span>;<br>            T=T-&gt;lchild;<br>        &#125;<br><span class="hljs-keyword">while</span> (top&gt;=<span class="hljs-number">0</span>&amp;&amp;tag[top]==<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 左右子树都访问过</span><br>            <span class="hljs-built_in">visit</span>(S[top]-&gt;data);<br>            top--;<br>        &#125;<br>        T=S[top];<br>        <span class="hljs-keyword">if</span> (top&gt;=<span class="hljs-number">0</span>&amp;&amp;tag[top]==<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 扫描右子树</span><br>            T=T-&gt;rchild;<br>            tag[top]=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (T!=<span class="hljs-literal">NULL</span>||top&gt;=<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 第二种方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123;<br>    Stack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    BiTree p=T,r=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">// p记录当前访问结点，r记录上一个访问到的结点</span><br>    <span class="hljs-keyword">while</span> (p||!<span class="hljs-built_in">StackEmpty</span>(S)) &#123;<br>        <span class="hljs-keyword">if</span> (p) &#123; <span class="hljs-comment">// 一路向左</span><br>            <span class="hljs-built_in">Push</span>(S,p);<br>            p=p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p=<span class="hljs-built_in">GetTop</span>(S);<br>            <span class="hljs-keyword">if</span> (p-&gt;rchild&amp;&amp;p-&gt;rchild!=r) &#123; <span class="hljs-comment">// 扫描右子树</span><br>                p=p-&gt;rchild;<br>                <span class="hljs-built_in">Push</span>(S,p);<br>                p=p-&gt;lchild;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 左右子树都访问过</span><br>                <span class="hljs-built_in">Pop</span>(S);<br>                <span class="hljs-built_in">visit</span>(p-&gt;data);<br>                r=p;<br>                p=<span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BFS（层次遍历）"><a href="#BFS（层次遍历）" class="headerlink" title="BFS（层次遍历）"></a>BFS（层次遍历）</h4><ul><li>时间复杂度为 O(n)，空间复杂度为 O(n)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrderTraverse</span><span class="hljs-params">(BiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123;<br>    Queue q;<br>    <span class="hljs-built_in">InitQueue</span>(q);<br>    <span class="hljs-keyword">if</span> (T) &#123;<br>        <span class="hljs-built_in">visit</span>(T-&gt;data);<br>        <span class="hljs-built_in">EnQueue</span>(q,T);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">QueueEmpty</span>(q)) &#123;<br>        T=<span class="hljs-built_in">GetHead</span>(q);<br>        <span class="hljs-built_in">DeQueue</span>(q);<br>        <span class="hljs-keyword">if</span> (T-&gt;lchild) &#123;<br>            <span class="hljs-built_in">visit</span>(T-&gt;lchild-&gt;data);<br>            <span class="hljs-built_in">EnQueue</span>(q,T-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (T-&gt;rchild) &#123;<br>            <span class="hljs-built_in">visit</span>(T-&gt;rchild-&gt;data);<br>            <span class="hljs-built_in">EnQueue</span>(q,T-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历算法的应用举例"><a href="#遍历算法的应用举例" class="headerlink" title="遍历算法的应用举例"></a>遍历算法的应用举例</h4><p>遍历算法是二叉树的重要算法，二叉树的很多问题都可以用遍历算法的思想解决，包括：求（叶子）结点个数、求深度、建立二叉树、删除二叉树、交换左右子树、将完全二叉树的顺序存储表示转换为二叉链表表示等等。</p><h5 id="求（叶子）结点个数"><a href="#求（叶子）结点个数" class="headerlink" title="求（叶子）结点个数"></a>求（叶子）结点个数</h5><p>遍历二叉树，在遍历过程中查找叶子结点并计数。由此，需要增添一个 count 参数，并将算法中 visit 的操作改为：若是叶子，则计数器增 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 第一种方式</span><br><span class="hljs-comment">// 定义 cnt，visit 操作为：若是叶子结点，则 cnt++（先根序、中根序、后根序、层次遍历都可以）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CountLeaf</span><span class="hljs-params">(BiTree T,<span class="hljs-type">int</span> &amp;count)</span> </span>&#123; <span class="hljs-comment">// count初值为0</span><br>    <span class="hljs-keyword">if</span> (T) &#123;<br>        <span class="hljs-keyword">if</span> (!T-&gt;lchild&amp;&amp;!T-&gt;rchild)<br>            count++;<br>        <span class="hljs-built_in">CountLeaf</span>(T-&gt;lchild,count);<br>        <span class="hljs-built_in">CountLeaf</span>(T-&gt;rchild,count);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第二种方式</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountLeaf</span><span class="hljs-params">(BiTree T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!T)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!T-&gt;lchild&amp;&amp;!T-&gt;rchild)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">CountLeaf</span>(T-&gt;lchild)+<span class="hljs-built_in">CountLeaf</span>(T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="求深度"><a href="#求深度" class="headerlink" title="求深度"></a>求深度</h5><p>由二叉树深度的定义可知，二叉树的深度为其左、右子树深度的较大值加 1。由此，需要将算法中 visit 的操作改为：分别求得左、右子树深度的较大值，然后加 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BiTreeDepth</span><span class="hljs-params">(BiTree T)</span> </span>&#123;<br>    <span class="hljs-type">int</span> depthval;<br>    <span class="hljs-keyword">if</span> (!T)<br>        depthval=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> depthLeft=<span class="hljs-built_in">BiTreeDepth</span>(T-&gt;lchild);<br>        <span class="hljs-type">int</span> depthRight=<span class="hljs-built_in">BiTreeDepth</span>(T-&gt;rchild);<br>        depthval=<span class="hljs-number">1</span>+(depthLeft&gt;depthRight?depthLeft:depthRight); <span class="hljs-comment">// 只能后根序</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> depthval;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="建立二叉树"><a href="#建立二叉树" class="headerlink" title="建立二叉树"></a>建立二叉树</h5><ol><li><p>约定以字符串（先根序、带空结点）的形式表示一棵二叉树</p><p>以’#’表示空结点</p><p>例如：</p><ul><li><p>空树：用字符串”#”表示</p></li><li><p>只含根结点(a)的二叉树：用字符串”a##”表示</p></li><li><p>一般情况：</p><p>​    a<br>   &#x2F; <br>  b  c<br> &#x2F; <br>d  e</p><p>用字符串”abd##e##c##”表示</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree &amp;T)</span> </span>&#123;<br>    <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;#&#x27;</span>)<br>        T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode))))<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>约定以先序序列和中序序列同时给出的形式表示一棵二叉树</p><p>已知二叉树的<strong>先序序列</strong>和<strong>中序序列</strong>，<strong>可以</strong>唯一确定一棵二叉树</p><p>例如，先序序列为 ABECDFGHIJ，中序序列为 EBCDAFHIGJ，建树过程如下：</p><img src="/img/ep6/image-20221104205406639.png" alt="image-20221104205406639" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(<span class="hljs-type">char</span> in[],<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;i&lt;<span class="hljs-built_in">strlen</span>(in);i++)<br>        <span class="hljs-keyword">if</span> (in[i]==ch)<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">return</span> i==<span class="hljs-built_in">strlen</span>(in)?<span class="hljs-number">-1</span>:i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree &amp;T,<span class="hljs-type">char</span> pre[],<span class="hljs-type">char</span> in[],<span class="hljs-type">int</span> ps,<span class="hljs-type">int</span> is,<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// pre[ps...ps+n-1]为二叉树的先序序列，in[is...is+n-1]为二叉树的中序序列，ps为先序序列的开始位置，is为中序序列的开始位置，n为序列长度</span><br>    <span class="hljs-keyword">if</span> (!n)<br>        T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> k=<span class="hljs-built_in">Search</span>(in,pre[ps]); <span class="hljs-comment">// 查询先序序列中的第一个字符在中序序列中的位置</span><br>        <span class="hljs-keyword">if</span> (k==<span class="hljs-number">-1</span>)<br>            T=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br>            T-&gt;data=pre[ps];<br>            <span class="hljs-keyword">if</span> (k==is)<br>                T-&gt;lchild=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 先序序列中的第一个字符在中序序列中也是第一个字符，表示没有左子树</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild,pre,in,ps+<span class="hljs-number">1</span>,is,k-is);<br>            <span class="hljs-keyword">if</span> (k==is+n<span class="hljs-number">-1</span>)<br>                T-&gt;rchild=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 先序序列中的第一个字符在中序序列中是最后一个字符，表示没有右子树</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild,pre,in,ps+<span class="hljs-number">1</span>+(k-is),k+<span class="hljs-number">1</span>,n-(k-is)<span class="hljs-number">-1</span>); <span class="hljs-comment">// 注意这里ps,is,n三个参数</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>已知二叉树的<strong>后序序列</strong>和<strong>中序序列</strong>，也<strong>可以</strong>唯一确定一棵二叉树</p><p>已知二叉树的<strong>先序序列</strong>和<strong>后序序列</strong>，<strong>不能</strong>唯一确定一棵二叉树</p></li><li><p>约定以表达式的形式表示一棵二叉树</p><p>操作数为叶子结点，算符为分支结点</p><p>例如：</p><img src="/img/ep6/image-20221104223707667.png" alt="image-20221104223707667" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 由前缀表达式建树</span><br><span class="hljs-comment">// 与由字符串（先根序、带空结点）建树类似</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateExpBiTree</span><span class="hljs-params">(BiTree &amp;T)</span> </span>&#123;<br>    <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (!(T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode))))<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>   T-&gt;data=ch;<br>    <span class="hljs-keyword">if</span> (ch&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<br>        T-&gt;lchild=T-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 由原表达式建树</span><br><span class="hljs-comment">// 算法思想与栈的应用举例中表达式求值类似</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用两个栈：一个存放叶子结点或子树，一个存放运算符。</span><br><span class="hljs-comment">步骤：</span><br><span class="hljs-comment">1.读入一个字符；</span><br><span class="hljs-comment">2.如果是操作数，建叶子结点入树栈；</span><br><span class="hljs-comment">3.如果是运算符，与运算符栈的栈顶元素比较优先级：</span><br><span class="hljs-comment">(1)若当前的优先级高，则入运算符栈；</span><br><span class="hljs-comment">(2)若优先级相同（左右括号），则弹出运算符栈栈顶元素（左括号）；</span><br><span class="hljs-comment">(3)若栈顶的优先级高，则弹出运算符栈栈顶元素（根），从树栈中弹出两个元素（右左孩子）建子树，新建的子树入树栈，继续比较至情况(1)(2)。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 定义树栈（类似OPND）和运算符栈（OPTR）</span><br>TreeStack OPND;<br>OptrStack OPTR;<br><span class="hljs-comment">// 建叶子结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CrtNode</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>    BiTree T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br>    T-&gt;data=ch;<br>    T-&gt;lchild=T-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">Push</span>(OPND,T);<br>&#125;<br><span class="hljs-comment">// 建子树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CrtSubtree</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>    BiTree T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br>    T-&gt;data=ch;<br>    BiTree rc=<span class="hljs-built_in">Pop</span>(OPND);<br>    T-&gt;rchild=rc;<br>    BiTree lc=<span class="hljs-built_in">Pop</span>(OPND);<br>    T-&gt;lchild=lc; <span class="hljs-comment">// 左子树先入栈，右子树后入栈，先弹出的是右子树</span><br>    <span class="hljs-built_in">Push</span>(OPND,T);<br>&#125;<br><span class="hljs-comment">// 栈顶和当前运算符比较</span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Precede</span><span class="hljs-params">(<span class="hljs-type">char</span> stop,<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (stop) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;=&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<br>        <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;=&#x27;</span>;<br>&#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 判断是否是操作数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isOperand</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateExpBiTree</span><span class="hljs-params">(BiTree &amp;T,<span class="hljs-type">char</span> exp[])</span> </span>&#123; <span class="hljs-comment">// exp[strlen(exp)]=&#x27;#&#x27;;</span><br>    <span class="hljs-built_in">InitStack</span>(OPND);<br>    <span class="hljs-built_in">InitStack</span>(OPTR);<br>    <span class="hljs-built_in">Push</span>(OPTR,<span class="hljs-string">&#x27;#&#x27;</span>);<br>    <span class="hljs-type">char</span>* p=exp;<br>    <span class="hljs-type">char</span> ch=*p;<br>    <span class="hljs-keyword">while</span> (ch!=<span class="hljs-string">&#x27;#&#x27;</span>||<span class="hljs-built_in">GetTop</span>(OPTR)!=<span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isOperand</span>(ch)) &#123;<br>            <span class="hljs-built_in">CrtNode</span>(ch);<br>            ch=*(++p);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">Precede</span>(<span class="hljs-built_in">GetTop</span>(OPTR),ch)) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>                <span class="hljs-built_in">Push</span>(OPTR,ch);<br>                ch=*(++p);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;=&#x27;</span>:<br>                <span class="hljs-built_in">Pop</span>(OPTR);<br>                ch=*(++p);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>                <span class="hljs-built_in">CrtSubtree</span>(<span class="hljs-built_in">Pop</span>(OPTR));<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    T=<span class="hljs-built_in">GetTop</span>(OPND);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><h5 id="提出背景"><a href="#提出背景" class="headerlink" title="提出背景"></a>提出背景</h5><p>当以二叉链表作为存储结构时，只能找到结点的左右孩子信息，而不能直接得到结点在任一序列的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到。如何把遍历过程中得到的结点的前驱和后继信息保存下来？</p><p><strong>方法一：</strong>在每个结点上增加两个指针域 fwd 和 bkwd，分别指示结点在任一次序遍历时得到的序列的前驱和后继信息。但是这种方法大大降低了存储密度。</p><p><strong>方法二：</strong>对于一个有 n 个结点的二叉链表，一共有 2n 个指针域，只有 n-1 条分支（除头结点，每一条分支都指向一个结点），也就是存在 2n-(n-1) &#x3D; n+1 个空指针。这些指针域只是白白浪费空间，因此，可以利用这些空链域来存放结点的前驱和后继信息。</p><p>这种利用空链域来存放结点的前驱和后继信息的二叉树称为<strong>线索二叉树</strong>，以某种次序遍历二叉树使其变为线索二叉树的过程称为<strong>线索化</strong>。</p><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p>为了区分指针域指示的是左右孩子信息还是前驱和后继信息，在二叉链表的结点中增加两个标志域 LTag 和 RTag，其中：</p><ul><li>LTag &#x3D; 0，lchild 域指示结点的左孩子</li><li>LTag &#x3D; 1，lchild 域指示结点的前驱</li><li>RTag &#x3D; 0，rchild 域指示结点的右孩子</li><li>RTag &#x3D; 1，rchild 域指示结点的后继</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;Link,Thread&#125; Pointer; <span class="hljs-comment">// Link：指针指示左右孩子，值为0；Thread：线索指示前驱后继，值为1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThrBiTNode</span> &#123;<br>    T data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThrBiTNode</span> *lchild,*rchild;<br>    Pointer LTag,RTag;<br>&#125; ThrBiTNode,*ThrBiTree;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中根序遍历二叉树的线索化（二叉树已建好）</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">约定：</span><br><span class="hljs-comment">1.添加头结点，其lchild指针指向根结点，rchild指针指向访问的最后一个结点</span><br><span class="hljs-comment">2.中根序遍历访问的第一个结点的lchild指针和最后一个结点的rchild指针均指向头结点</span><br><span class="hljs-comment">思考：</span><br><span class="hljs-comment">1.中根序遍历访问的第一个结点是？</span><br><span class="hljs-comment">左子树上处于“最左下”的结点。</span><br><span class="hljs-comment">2.以中根序线索化后的二叉链表中结点的后继是？</span><br><span class="hljs-comment">若无右子树，则为后继线索所指结点；否则为对其右子树进行中根序遍历时访问的第一个结点</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 线索化的过程即为在遍历过程中修改空指针的过程。为了记下遍历过程中访问结点的先后关系，附设一个指针pre指向当前访问的结点的前驱。</span><br><br><span class="hljs-comment">// 对以p为根的非空二叉树进行中序线索化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Threading</span><span class="hljs-params">(ThrBiTree p,ThrBiTree &amp;pre)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p) &#123;<br>        <span class="hljs-built_in">Threading</span>(p-&gt;lchild,pre); <span class="hljs-comment">// 左子树线索化</span><br>        <span class="hljs-keyword">if</span> (!p-&gt;lchild) &#123; <span class="hljs-comment">// 左孩子空，建前驱线索</span><br>            p-&gt;LTag=Thread;<br>            p-&gt;lchild=pre;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!pre-&gt;rchild) &#123; <span class="hljs-comment">// 前驱的右孩子空，建后继线索</span><br>            pre-&gt;RTag=Thread;<br>            pre-&gt;rchild=p;<br>        &#125;<br>        pre=p; <span class="hljs-comment">// 保持pre指向p的前驱</span><br>        <span class="hljs-built_in">Threading</span>(p-&gt;rchild,pre); <span class="hljs-comment">// 右子树线索化</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderThreading</span><span class="hljs-params">(ThrBiTree &amp;h,ThrBiTree T)</span> </span>&#123;<br>    <span class="hljs-comment">// h指向头结点，T指向根结点</span><br>    <span class="hljs-comment">// 重点看h-&gt;lchild，h-&gt;rchild，第一个结点的lchild，最后一个结点的rchild四个指针指向</span><br>    <span class="hljs-comment">// h需要引用传递，因为要为h申请堆上内存，如果是值传递，函数结束空间就被释放</span><br>    <span class="hljs-keyword">if</span> (!(h=(ThrBiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ThrBiTNode))))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    h-&gt;LTag=Link; <span class="hljs-comment">// 中根序遍历访问的第一个结点是左子树上处于“最左下”的结点，当根节点没有左子树时，如何定义“最左下”？就是这句代码</span><br>    h-&gt;RTag=Thread;<br>    h-&gt;rchild=h; <span class="hljs-comment">// 右指针回指</span><br>    <span class="hljs-keyword">if</span> (!T) h-&gt;lchild=h; <span class="hljs-comment">// 若二叉树空，左指针回指</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        h-&gt;lchild=T;<br>        ThrBiTree pre=h;<br>        <span class="hljs-built_in">Threading</span>(T,pre);<br>        pre-&gt;RTag=Thread;<br>        pre-&gt;rchild=h;<br>        h-&gt;rchild=pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中根序遍历线索二叉树的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverse_Thr</span><span class="hljs-params">(ThrBiTree T,<span class="hljs-type">void</span>(*visit)(T &amp;e))</span> </span>&#123; <span class="hljs-comment">// T指向头结点</span><br>    ThrBiTree p=T-&gt;lchild; <span class="hljs-comment">// p指向根结点</span><br>    <span class="hljs-keyword">while</span> (p!=T) &#123; <span class="hljs-comment">// 空树或遍历结束时，p==T</span><br>        <span class="hljs-keyword">while</span> (p-&gt;LTag==Link)<br>            p=p-&gt;lchild; <span class="hljs-comment">// 一路向左，找第一个结点</span><br>        <span class="hljs-built_in">visit</span>(p-&gt;data);<br>        <span class="hljs-keyword">while</span> (p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T) &#123;<br>            p=p-&gt;rchild;<br>            <span class="hljs-built_in">visit</span>(p-&gt;data);<br>        &#125;<br>        p=p-&gt;rchild;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-树的存储"><a href="#5-树的存储" class="headerlink" title="5 - 树的存储"></a>5 - 树的存储</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>每个结点只有一个双亲（除根结点），所以用一组连续空间存储树的结点，并在每个结点中附设一个指示其双亲结点的位置域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 结点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span> &#123;<br>    T data;<br>    <span class="hljs-type">int</span> parent; <span class="hljs-comment">// 双亲位置域</span><br>&#125; PTNode;<br><br><span class="hljs-comment">// 树结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    PTNode nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> r,n; <span class="hljs-comment">// 根结点的位置和结点个数</span><br>&#125; PTree;<br></code></pre></td></tr></table></figure><p>双亲表示法容易求结点的双亲，但是求结点的孩子时需要遍历整个结构。</p><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>每个结点有多个孩子（除叶子结点），所以用一组连续空间存储树的结点，但是每个结点需要多个指示其孩子结点的位置域。</p><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><img src="/img/ep6/image-20221112120358207.png" alt="image-20221112120358207" style="zoom:25%;" /><p>设树的度为 d，每个结点直接开 d 个孩子位置域。操作简单，但是由于树中很多结点的度小于 d，空间较浪费。对于一棵有 n 个结点、度为 k 的树，一共有 n*k 个指针域，只有 n-1 条分支（除头结点，每一条分支都指向一个结点），也就是存在 nk-(n-1) &#x3D; n(k-1)+1 个空指针。</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><img src="/img/ep6/image-20221112120423189.png" alt="image-20221112120423189" style="zoom:25%;" /><p>根据每个结点的度为其申请数量不同的孩子位置域。节省空间，但是操作复杂。</p><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><img src="/img/ep6/image-20221112122049599.png" alt="image-20221112122049599" style="zoom:25%;" /><p>把每个结点的孩子结点排列起来成为一个线性表（以单链表作为存储结构，叶子结点的链表为空表），而每个结点又组成一个线性表（为了便于查找，可采用顺序存储结构）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>* next;<br>&#125; *ChildPtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T data;<br>    ChildPtr h; <span class="hljs-comment">// 孩子链表的头指针</span><br>&#125; CTBox;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    CTBox nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> r,n; <span class="hljs-comment">// 根结点的位置和结点个数</span><br>&#125; CTree;<br></code></pre></td></tr></table></figure><p>孩子表示法容易求结点的孩子，但是求结点的双亲时需要遍历整个结构。</p><h4 id="带双亲的孩子链表表示法"><a href="#带双亲的孩子链表表示法" class="headerlink" title="带双亲的孩子链表表示法"></a>带双亲的孩子链表表示法</h4><img src="/img/ep6/image-20221112123908144.png" alt="image-20221112123908144" style="zoom:25%;" /><p>结合了双亲表示法和孩子表示法的优点，容易求结点的双亲和孩子。</p><h4 id="孩子-兄弟表示法（二叉链表表示法）"><a href="#孩子-兄弟表示法（二叉链表表示法）" class="headerlink" title="孩子-兄弟表示法（二叉链表表示法）"></a>孩子-兄弟表示法（二叉链表表示法）</h4><img src="/img/ep6/image-20221112160158152.png" alt="image-20221112160158152" style="zoom:25%;" /><p>以二叉链表作为树的存储结构，链表中结点的两个链域分别指向该结点的<strong>第一个孩子</strong>和<strong>下一个兄弟</strong>。给定一棵树，可以找到唯一一棵二叉树与之对应。任何一棵树所对应的二叉树，其右子树必为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> &#123;<br>    T data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> *firstchild,*nextsibling;<br>&#125; CSNode,*CSTree;<br></code></pre></td></tr></table></figure><p>二叉链表表示法便于实现各种树的操作。例如，若要访问某个结点的第 i 个孩子，则只要先从该结点的 firstchild 域找到第 1 个孩子，然后沿着孩子结点的 nextsibling 域连续走 i-1 步。</p><h4 id="带度数的层序表示（顺序存储表示）"><a href="#带度数的层序表示（顺序存储表示）" class="headerlink" title="带度数的层序表示（顺序存储表示）"></a>带度数的层序表示（顺序存储表示）</h4><img src="/img/ep6/image-20221112164713218.png" alt="image-20221112164713218" style="zoom:25%;" /><h3 id="6-树的遍历"><a href="#6-树的遍历" class="headerlink" title="6 - 树的遍历"></a>6 - 树的遍历</h3><p>树的遍历有<strong>先根序遍历</strong>、<strong>后根序遍历</strong>和<strong>层次遍历</strong>三种方式。</p><h4 id="二叉链表所存树的遍历"><a href="#二叉链表所存树的遍历" class="headerlink" title="二叉链表所存树的遍历"></a>二叉链表所存树的遍历</h4><img src="/img/ep6/image-20221112171534444.png" alt="image-20221112171534444" style="zoom:25%;" /><p>上图中：</p><ul><li>树的先根序遍历次序：ABEFCDGHIJK，也是对应二叉树的先根序遍历次序</li><li>树的后根序遍历次序：EFBCIJKHGDA，也是对应二叉树的中根序遍历次序</li><li>树的层次遍历次序：ABCDEFGHIJK</li></ul><p>使用二叉链表表示法存储树，可以沿用二叉树的遍历算法。</p><h4 id="遍历算法的应用举例-1"><a href="#遍历算法的应用举例-1" class="headerlink" title="遍历算法的应用举例"></a>遍历算法的应用举例</h4><h5 id="求深度-1"><a href="#求深度-1" class="headerlink" title="求深度"></a>求深度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(CSTree T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!T)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> h1=<span class="hljs-built_in">TreeDepth</span>(T-&gt;firstchild);<br>        <span class="hljs-type">int</span> h2=<span class="hljs-built_in">TreeDepth</span>(T-&gt;nextsibling);<br>        <span class="hljs-keyword">return</span> h1+<span class="hljs-number">1</span>&gt;h2?(h1+<span class="hljs-number">1</span>):h2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h5><ol><li><p>约定以表示边的二元组 (parent, child) 的形式表示一棵树</p><p>以二元组 (parent, child) 的形式自上而下、自左而右依次输入树的各边，建立树的孩子-兄弟链表</p><p>例如：</p><p>​     a<br>   &#x2F; | <br>b   c   d<br>​    &#x2F; <br>  e    f<br>  |<br>  g</p><p>输入为 #aabacadcecfeg##</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateTree</span><span class="hljs-params">(CSTree &amp;T)</span> </span>&#123;<br>T=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 健壮性：只输入##</span><br>SqQueue Q;<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-type">char</span> fa,ch;<br>CSTree r;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%c&quot;</span>,&amp;fa,&amp;ch);ch!=<span class="hljs-string">&#x27;#&#x27;</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%c&quot;</span>,&amp;fa,&amp;ch)) &#123;<br>CSTree p=(CSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(CSNode));<br>p-&gt;data=ch;<br>p-&gt;firstchild=<span class="hljs-literal">NULL</span>;<br>p-&gt;nextsibling=<span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">EnCycque</span>(Q,p);<br><span class="hljs-keyword">if</span> (fa==<span class="hljs-string">&#x27;#&#x27;</span>)<br>T=p;<br><span class="hljs-keyword">else</span> &#123;<br>CSTree s=<span class="hljs-built_in">GetHead</span>(Q);<br><span class="hljs-keyword">while</span> (s-&gt;data!=fa) &#123;<br><span class="hljs-built_in">DeCycque</span>(Q);<br>s=<span class="hljs-built_in">GetHead</span>(Q);<br>&#125;<br><span class="hljs-keyword">if</span> (!(s-&gt;firstchild)) &#123;<br>s-&gt;firstchild=p;<br>r=p;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>r-&gt;nextsibling=p;<br>r=p;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>约定以先序序列和后序序列同时给出的形式表示一棵树</p><p>对应以先序序列和中序序列同时给出的形式表示一棵二叉树</p></li></ol><h3 id="7-哈夫曼树"><a href="#7-哈夫曼树" class="headerlink" title="7 - 哈夫曼树"></a>7 - 哈夫曼树</h3><h4 id="相关概念-2"><a href="#相关概念-2" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>路径：两个结点之间的分支</li><li>结点的路径长度：从根结点到该结点的路径上分支的数目</li><li>树的路径长度：树中所有结点的路径长度之和</li><li>树的带权路径长度：树中所有<strong>叶子结点</strong>的带权路径长度之和：$$WPL(T)&#x3D;\sum(w_k*l_k)$$</li><li>哈夫曼树 &#x2F; 最优二叉树：在所有含 n 个叶子结点、并带相同权值的二叉树中，必定存在一棵其带权路径长度取最小值的树，称为哈夫曼树</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>例如：已知权值 W &#x3D; {5, 6, 2, 9, 7}</p><img src="/img/ep6/image-20221112220735038.png" alt="image-20221112220735038" style="zoom:25%;" /><h4 id="重要性质-1"><a href="#重要性质-1" class="headerlink" title="重要性质"></a>重要性质</h4><p>有 n 个叶子结点的哈夫曼树的结点总数为 2n-1</p><p>证明：m 叉哈夫曼树只有度为 m 和度为 0 的结点，故二叉哈夫曼树只有度为 2 和度为 0 的结点，故结点总数为 $$n_0+n_2$$。又对于每个度为 2 的结点都有 2 个分支，度为 0 的结点没有分支，故结点总数为 $$2n_2+1$$（加上根结点）。故 $$n_0+n_2&#x3D;2n_2+1$$，得到 $$n_2&#x3D;n_0-1$$，故总结点数为 $$2n_0-1$$。</p><h4 id="重要应用：最优前缀编码"><a href="#重要应用：最优前缀编码" class="headerlink" title="重要应用：最优前缀编码"></a>重要应用：最优前缀编码</h4><h5 id="前缀编码"><a href="#前缀编码" class="headerlink" title="前缀编码"></a>前缀编码</h5><p>对字符集进行二进制编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀</p><p>例如：设有 a, b, c, d 需要编码表示，若 a&#x3D;0, b&#x3D;10, c&#x3D;110, d&#x3D;11，则 110 表示的可以是 c 或 da，出现这种情况是因为 d 的编码是 c 的编码的前缀</p><h5 id="最优前缀编码"><a href="#最优前缀编码" class="headerlink" title="最优前缀编码"></a>最优前缀编码</h5><p>利用哈夫曼树可以构造最优前缀编码，即使得所传电文的总长度最短，也称为哈夫曼编码</p><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><img src="/img/ep6/image-20221112223738307.png" alt="image-20221112223738307" style="zoom:25%;" /><p>以 n 种字符出现的频率作权，设计一棵哈夫曼树。约定左分支表示字符 0，右分支表示字符 1，则从根结点到叶子结点的路径的分支上 01 字符组成的字符串就是该叶子结点字符的编码</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组和广义表</title>
    <link href="/2023/03/02/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <url>/2023/03/02/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>数据结构课程笔记 ep5</p><span id="more"></span><h2 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1 - 数组"></a>1 - 数组</h3><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">ADT Array &#123;<br>    数据对象：<br>        D=&#123;a[j_1][j_2]<span class="hljs-string">...</span>[j_i]<span class="hljs-string">...</span>[j_n]|j_i=0,<span class="hljs-string">...</span>,<span class="hljs-params">(b_i)</span>-1, i=1,2,<span class="hljs-string">...</span>,n, j_i是第i维索引值, b_i是第i维长度&#125;<br>数据关系：<br>R=&#123;R_1,R_2,<span class="hljs-string">...</span>,R_i,<span class="hljs-string">...</span>,R_n&#125;<br>    R_k=&#123;&lt;a[j_1][j_2]<span class="hljs-string">...</span>[j_k]<span class="hljs-string">...</span>[j_i]<span class="hljs-string">...</span>[j_n], a[j_1][j_2]<span class="hljs-string">...</span>[<span class="hljs-params">(j_k)</span>+1]<span class="hljs-string">...</span>[k_i]<span class="hljs-string">...</span>[jn]&gt;|j_k=0,<span class="hljs-string">...</span>,<span class="hljs-params">(b_k)</span>-2, j_i=0,<span class="hljs-string">...</span>,<span class="hljs-params">(b_i)</span>-1, i=1,2,<span class="hljs-string">...</span>,k-1,k+1,<span class="hljs-string">...</span>,n, j_i是第i维索引值, b_i是第i维长度, k是特定的i&#125;<br>    基本操作：<br>    InitArray<span class="hljs-params">(&amp;A,n,bound1,...,boundn)</span> <span class="hljs-string">//</span> 初始化，n是维数，boundi是维界<br>    DestroyArray<span class="hljs-params">(&amp;A)</span>                  <span class="hljs-string">//</span> 销毁<br>    Value<span class="hljs-params">(A,&amp;e,index1,...,indexn)</span>     <span class="hljs-string">//</span> 读值<br>    Assign<span class="hljs-params">(&amp;A,e,index1,...,indexn)</span>    <span class="hljs-string">//</span> 赋值<br>&#125; ADT Array<br></code></pre></td></tr></table></figure><h4 id="顺序存储表示"><a href="#顺序存储表示" class="headerlink" title="顺序存储表示"></a>顺序存储表示</h4><h5 id="类型特点"><a href="#类型特点" class="headerlink" title="类型特点"></a>类型特点</h5><ol><li>没有增删操作，只有改查操作；数组建立后，元素个数与元素之间的关系不会发生变动。故可以用顺序存储表示数组；</li><li>数组是多维结构，而存储空间是一维结构。故用一组连续存储单元存放数组元素存在<strong>次序约定</strong>的问题。</li></ol><h5 id="两种次序约定"><a href="#两种次序约定" class="headerlink" title="两种次序约定"></a>两种次序约定</h5><ol><li><p>以行序为主序（低下标优先），C 语言采用该次序约定</p><img src="..\img\ep5\image-20221124141647348.png" alt="image-20221124141647348" style="zoom:25%;" /><ul><li><p>二维数组 a[b1][b2] 中任一元素 a[i][j] 的存储位置 LOC(i, j) &#x3D; LOC(0, 0) + (b2 * i + j) * L</p></li><li><p>三维数组 a[b1][b2][b3] 中任一元素 a[j1][j2][j3] 的存储位置 LOC(j1, j2, j3) &#x3D; LOC(0, 0, 0) + (b2 * b3 * j1 + b3 * j2 + j3) * L</p></li><li><p>LOC(j1, j2, …, jn) &#x3D; LOC(0, 0, …, 0) + (b2 * b3 * … * bn * j1 + b3 * … * bn * j2 + … + j3) * L</p></li></ul></li><li><p>以列序为主序（高下标优先）</p><p>计算顺序由自左向右转换为自右向左即可，意义不大</p></li></ol><h4 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h4><p>当阶数很高的矩阵中有许多值相同的元素或零元素时，为了节省空间，要对矩阵进行压缩，即把二维数组的数据元素压缩到一维数组上。这里<strong>压缩</strong>的含义是：<strong>对多个值相同的元素只分配一个存储空间</strong>；<strong>零元素不分配存储空间</strong>。</p><h5 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h5><p>特点：值相同的元素或零元素在矩阵中的分布有一定规则</p><ol><li><p><strong>对称矩阵</strong></p><ul><li><p>特点：n 阶方阵满足 a[i][j] &#x3D; a[j][i] (0 ≤ i, j ≤ n-1)</p></li><li><p>方法：对每一对对称元素只分配一个存储空间，将 $$n^2$$ 个元素压缩存储到 $$n*(n+1)&#x2F;2$$ 个元素的空间中</p></li><li><p>图示：</p><img src="..\img\ep5\image-20221124153241399.png" alt="image-20221124153241399" style="zoom:25%;" /></li><li><p>公式：</p><p>存下三角：LOC(i, j) &#x3D; LOC(0, 0) + [i * (i + 1) &#x2F; 2 + j] * L</p><p>存上三角：LOC(i, j) &#x3D; LOC(0, 0) + [i * (2 * n - i + 1) &#x2F; 2] * L</p></li></ul></li><li><p><strong>三角矩阵</strong></p><ul><li>特点：n 阶方阵满足下（上）三角矩阵的上（下）三角（不包括对角线）中的元均为常数</li><li>方法：除了和对称矩阵一样，只存储其下（上）三角中的元之外，再加一个存储常数 C 的存储空间即可</li></ul></li><li><p><strong>对角矩阵</strong></p><ul><li>特点：n 阶方阵满足所有的非零元都集中在以主对角线为中心的带状区域中，即除了主对角线上和其上下方紧邻的若干条对角线上的元之外，所有其它的元皆为零</li><li>方法：以行的顺序或以对角线的顺序将其压缩存储到一维数组上，并找出每个非零元在一维数组中的对应关系</li></ul></li></ol><h5 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h5><p>基本操作：</p><ul><li><code>CreateSMatrix(&amp;M)</code></li><li><code>DestroySMatrix(&amp;M)</code></li><li><code>PrintSMatrix(M)</code></li><li><code>CopySMatrix(M,&amp;T)</code></li><li><code>AddSMatrix(M,N,&amp;Q)</code>（若稀疏矩阵 M 和 N 的行数与列数对应相等，求稀疏矩阵的和）</li><li><code>SubSMatrix(M,N,&amp;Q)</code>（若稀疏矩阵 M 和 N 的行数与列数对应相等，求稀疏矩阵的差）</li><li><code>MultSMatrix(M,N,&amp;Q)</code>（若稀疏矩阵 M 的列数等于 N 的行数，求稀疏矩阵的乘积）</li><li><code>TransSMatrix(M,&amp;T)</code>（求稀疏矩阵的转置）</li></ul><p>用二维数组存储稀疏矩阵存在的问题：</p><ul><li>零值元素占了很大空间 → 期望尽可能少存或不存零值元素</li><li>将进行很多和零值的运算 → 期望尽可能减少没有实际意义的运算</li><li>还期望操作方便，即：尽可能快地找到对应下标值 i, j 的元素，尽可能快地找到同一行或同一列的非零元素</li></ul><p>方法：</p><ol><li><p><strong>用三元组表示</strong>：用一个线性表来表示稀疏矩阵，表中结点对应非零元素（包括三个域：行下标、列下标和值），结点间的先后顺序按矩阵的行优先顺序排列（跳过零元素）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100 <span class="hljs-comment">// 非零元素个数上限</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> i,j;<br>    T v;<br>&#125; Triple;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Triple data[MAXSIZE]; <span class="hljs-comment">// 非零元素三元组表</span><br><span class="hljs-type">int</span> mu,nu,tu; <span class="hljs-comment">// 矩阵的行数、列数和非零元素个数</span><br>&#125; TSMatrix;<br></code></pre></td></tr></table></figure><p><strong>矩阵转置算法</strong>：</p><p>用二维数组表示稀疏矩阵时转置算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row=<span class="hljs-number">1</span>;row&lt;=mu;++row)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col=<span class="hljs-number">1</span>;col&lt;=nu;++col)<br>N[col][row]=M[row][col];<br><span class="hljs-comment">// 时间复杂度：O(mu*nu)</span><br></code></pre></td></tr></table></figure><p>用三元组表示稀疏矩阵时转置算法：</p><p>交换矩阵的行数和列数→交换每个三元组的 i 和 j →<strong>重排三元组之间的次序（以行序为主序）</strong>，实现重排有两种方法：</p><ul><li><p>方法1：按矩阵 M 的列序进行转置，即按对应三元组表中三元组的第二个字段值（列下标）由小到大的顺序进行转置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TransSMatrix</span><span class="hljs-params">(TSMatrix M,TSMatrix &amp;T)</span> </span>&#123;<br>T.mu=M.nu,T.nu=M.mu,T.tu=M.tu;<br>    <span class="hljs-keyword">if</span> (M.tu) &#123;<br>        <span class="hljs-type">int</span> q=<span class="hljs-number">0</span>; <span class="hljs-comment">// 目标矩阵T三元组表的索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col=<span class="hljs-number">1</span>;col&lt;=M.nu;col++) <span class="hljs-comment">// 按矩阵M的列序进行转置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;p&lt;M.tu;p++) <span class="hljs-comment">// 扫描矩阵M三元组表</span><br>                <span class="hljs-keyword">if</span> (M.data[p].j==col) &#123;<br>                    T.data[q].i=M.data[p].j;<br>                    T.data[q].j=M.data[p].i;<br>                    T.data[q].v=M.data[p].v;<br>                    q++;<br>                &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 时间复杂度：O(tu*nu)</span><br></code></pre></td></tr></table></figure></li><li><p>方法2：按矩阵 M 的行序进行转置，即按对应三元组表的本身次序进行转置，然后按三元组表中三元组的第一个字段值（行下标）由小到大的顺序将三元组置入矩阵 T 对应三元组表中恰当的位置</p><p>预处理：如果能够预先确定矩阵 M 中每一列（即 T 中每一行）的第一个非零元素在矩阵 T 对应三元组表中应有的位置，那么在对矩阵 M 对应三元组表中的三元组进行转置时，便可直接将其放到矩阵 T 对应三元组表中恰当的位置；附设两个向量：</p><ul><li><p><code>num[col]</code> 表示矩阵 M 中第 col 列非零元素的个数</p></li><li><p><code>cpot[col]</code> 表示矩阵 M 中第 col 列第一个非零元素在矩阵 T 对应三元组表中恰当的位置（column position）</p></li><li><p>&#96;&#96;&#96;c++<br>cpot[1]&#x3D;0;<br>for (int col&#x3D;2;col&lt;&#x3D;M.nu;++col)<br>cpot[col]&#x3D;cpot[col-1]+num[col-1];</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>```c++<br>void <span class="hljs-constructor">TransSMatrix(TSMatrix M,TSMatrix &amp;T)</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>mu=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>nu,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>nu=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>mu,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>tu=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>tu;<br><span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>tu) &#123;<br>        <span class="hljs-comment">// 预处理</span><br>        <span class="hljs-built_in">int</span> num<span class="hljs-literal">[MAXCOL]</span>;<br>        <span class="hljs-built_in">int</span> cpot<span class="hljs-literal">[MAXCOL]</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col=<span class="hljs-number">1</span>;col&lt;=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>nu;++col)<br>            num<span class="hljs-literal">[<span class="hljs-identifier">col</span>]</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> t=<span class="hljs-number">0</span>;t&lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>tu;++t)<br>            num<span class="hljs-literal">[M.<span class="hljs-identifier">data</span>[<span class="hljs-identifier">t</span>]</span>.j]++;<br>        cpot<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col=<span class="hljs-number">2</span>;col&lt;=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>nu;++col)<br>            cpot<span class="hljs-literal">[<span class="hljs-identifier">col</span>]</span>=cpot<span class="hljs-literal">[<span class="hljs-identifier">col</span>-<span class="hljs-number">1</span>]</span>+num<span class="hljs-literal">[<span class="hljs-identifier">col</span>-<span class="hljs-number">1</span>]</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> p=<span class="hljs-number">0</span>;p&lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>tu;p++) &#123;<br>            <span class="hljs-built_in">int</span> col=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">p</span>]</span>.j;<br>            <span class="hljs-built_in">int</span> q=cpot<span class="hljs-literal">[<span class="hljs-identifier">col</span>]</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">q</span>]</span>.i=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">p</span>]</span>.j;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">q</span>]</span>.j=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">p</span>]</span>.i;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">q</span>]</span>.v=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">p</span>]</span>.v;<br>            cpot<span class="hljs-literal">[<span class="hljs-identifier">col</span>]</span>++;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 时间复杂度：O(tu+nu)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>用三元组附加行指针表示</strong>：相比用三元组表示，在稀疏矩阵的结构定义中增加指示矩阵 M 中每一行的第一个非零元素在对应三元组表中的位置的向量 rpot（row position）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> i,j;<br>    T v;<br>&#125; Triple;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Triple data[MAXSIZE];<br>    <span class="hljs-type">int</span> rpot[MAXROW]; <span class="hljs-comment">// 若某行无非零元素，则该行行指针照样在其本应在的位置，即该行之前的所有行的非零元素在data中的最大下标加1</span><br><span class="hljs-type">int</span> mu,nu,tu;<br>&#125; TSMatrix;<br></code></pre></td></tr></table></figure><p><strong>矩阵相乘算法</strong>：</p><p>用二维数组表示稀疏矩阵时相乘算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Q=M*N，M是m1×n1矩阵，N是m2×n2矩阵，n1=m2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m1;++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n2;++j) &#123;<br>        Q[i][j]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n1;++k)<br>            Q[i][j]+=M[i][k]*N[k][j];<br>    &#125;<br><span class="hljs-comment">// 时间复杂度：O(m1*n1*n2)</span><br></code></pre></td></tr></table></figure><p>用三元组附加行指针表示稀疏矩阵时相乘算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 若稀疏矩阵M的列数等于N的行数，则用Q返回稀疏矩阵的乘积，并返回true；否则返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MultSMatrix</span><span class="hljs-params">(TSMatrix M,TSMatrix N,TSMatrix &amp;Q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (M.nu!=N.mu)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Q.mu=M.mu,Q.nu=N.nu,Q.tu=<span class="hljs-number">0</span>; <span class="hljs-comment">// Q.tu初值为0</span><br>    <span class="hljs-keyword">if</span> (M.tu*N.tu!=<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> sum[MAXROW],top;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row_M=<span class="hljs-number">1</span>;row_M&lt;=M.mu;++row_M) &#123;<br>            Q.rpot[row_M]=Q.tu+<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col=<span class="hljs-number">1</span>;col&lt;=N.nu;++col)<br>                sum[col]=<span class="hljs-number">0</span>;<br>            <br>            <span class="hljs-keyword">if</span> (row_M&lt;M.mu) <span class="hljs-comment">// 顶部</span><br>                top=M.rpot[row_M+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                top=M.tu<span class="hljs-number">-1</span>;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=M.rpot[row_M];j&lt;=top;++j) &#123;<br>                <span class="hljs-type">int</span> row_N=M.data[j].j,t;<br>                <span class="hljs-keyword">if</span> (row_N&lt;N.mu) <span class="hljs-comment">// 顶部</span><br>                    t=N.rpot[row_N+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    t=N.tu<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=N.rpot[row_N];k&lt;=t;++k) &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * 示意图：</span><br><span class="hljs-comment">                     *         col </span><br><span class="hljs-comment">                     * O O O O- - -</span><br><span class="hljs-comment">                     * - O O OO O O</span><br><span class="hljs-comment">                     * O O O OO O O</span><br><span class="hljs-comment">                     *          O O O</span><br><span class="hljs-comment">                     *    M       N</span><br><span class="hljs-comment">                     * 由此可见，完全避免了与0有关的乘法</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-type">int</span> col=N.data[k].j;<br>sum[col]+=M.data[j].v*N.data[k].v;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col=<span class="hljs-number">1</span>;col&lt;=N.nu;++col) <span class="hljs-comment">// 抄答案</span><br>                <span class="hljs-keyword">if</span> (sum[col]) &#123;<br>                    Q.data[Q.tu].i=row_M;<br>Q.data[Q.tu].j=col;<br>Q.data[Q.tu].v=sum[col];<br>                    ++Q.tu;<br>&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>用带行指针向量的单链表表示</strong>：将稀疏矩阵中每一行的非零元素分别链接成一个单链表，表中结点对应该行非零元素（包括三个域：列下标、值和指针），附设一个作为各单链表头指针的行指针向量</p><p>类似地，也可以用带列指针向量的单链表表示</p></li><li><p><strong>用带行指针向量和列指针向量的十字链表表示</strong>：结合了带行指针向量的单链表表示法和带列指针向量的单链表表示法，表中结点可以包括五个域：行下标、列下标、值、行指针和列指针</p><img src="..\img\ep5\image-20230111134959493.png" alt="image-20230111134959493" style="zoom: 33%;" /></li></ol><h3 id="2-广义表"><a href="#2-广义表" class="headerlink" title="2 - 广义表"></a>2 - 广义表</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ol><li><strong>广义表（Generalized list）</strong>是 n 个单元素（或称<strong>原子</strong>）或<strong>子广义表</strong> α1, α2, …, αn 的有限序列，记作 LS &#x3D; (α1, α2, …, αn)，约定用小写字母表示原子、用大写字母表示广义表</li><li>广义表是线性表的推广，线性表是广义表的特例；广义表是递归定义，其运算通常也用递归函数完成</li><li>广义表的<strong>长度</strong>为最外层的元素个数，<strong>深度</strong>为层数即所含括弧的最大重数</li><li>当广义表非空时，称第一个元素 α1 为<strong>表头（Head）</strong>，其余元素组成的广义表 (α2, α3, …, αn) 为<strong>表尾（Tail）</strong></li></ol><p>例子：</p><ul><li><p>A &#x3D; ()</p><p>A 是空表，长度为 0，深度为 1</p></li><li><p>B &#x3D; (a, b, c, d)</p><p>B 是由四个原子组成的广义表，长度为 4，深度为 1</p><p>Head(B) &#x3D; a，Tail(B) &#x3D; (b, c, d)</p></li><li><p>C &#x3D; (a, (b, c, d))</p><p>C 是由一个原子和一个子表组成的广义表，长度为 2，深度为 2</p><p>Head(C) &#x3D; a，Tail(C) &#x3D; ((b, c, d))</p></li><li><p>D &#x3D; (A, B, C) &#x3D; ((), (a, b, c, d), (a, (b, c, d)))</p><p>D 是由三个子表组成的广义表，长度为 3，深度为 3</p><p>Head(D) &#x3D; A，Tail(D) &#x3D; (B, C)</p></li><li><p>E &#x3D; (a, E) &#x3D; (a, (a, (a, (…))))</p><p>E 是由一个原子和一个子表组成的广义表，长度为 2，深度为无穷，它是一个无限递归的广义表</p><p>Head(E) &#x3D; a，Tail(E) &#x3D; (E)</p></li></ul><h4 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ADT Generalized <span class="hljs-built_in">list</span> &#123;<br>数据对象：<br>D=&#123;e_i<span class="hljs-pattern-match">|e<span class="hljs-constructor">_i</span>为原子且e<span class="hljs-constructor">_i</span>∈<span class="hljs-constructor">AtomSet</span>,或e<span class="hljs-constructor">_i</span>为广义表,i=1,2,<span class="hljs-operator">...</span>,n&#125;</span><br><span class="hljs-pattern-match">数据关系：</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">R</span>=&#123;&lt;e<span class="hljs-constructor">_i</span>-1,e<span class="hljs-constructor">_i</span>&gt;|e<span class="hljs-constructor">_i</span>-1,e<span class="hljs-constructor">_i</span>∈<span class="hljs-constructor">D</span>,i=2,<span class="hljs-operator">...</span>,n&#125;</span><br><span class="hljs-pattern-match">基本操作：</span><br><span class="hljs-pattern-match">创建和销毁操作</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">InitGList(&amp;L)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">DestroyGList(&amp;L)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">CopyGList(&amp;T,L)</span></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">插入和删除操作</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">InsertFirst(&amp;L,<span class="hljs-params">e</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 插入e，作为第一个元素</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">DeleteFirst(&amp;L,&amp;<span class="hljs-params">e</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 删除第一个元素，用e返回</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">查询函数</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">GListEmpty(L)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">GListLength(L)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">GListDepth(L)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">GListHead(L)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">GListTail(L)</span></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">遍历函数</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">TraverseGList(L,<span class="hljs-params">visit</span>()</span>)</span><br><span class="hljs-pattern-match">&#125; <span class="hljs-constructor">ADT</span> <span class="hljs-constructor">Generalized</span> <span class="hljs-built_in">list</span></span><br></code></pre></td></tr></table></figure><h4 id="广义表的链式存储表示"><a href="#广义表的链式存储表示" class="headerlink" title="广义表的链式存储表示"></a>广义表的链式存储表示</h4><p>由于广义表中数据元素可以是原子或广义表，因此难以用顺序存储结构表示；通常采用链式存储结构，并设置<strong>表结点</strong>和<strong>原子结点</strong>两类结点，每个数据元素用一个结点表示；广义表的链式存储结构常见的两种表示方法为：</p><h5 id="表头表尾表示法"><a href="#表头表尾表示法" class="headerlink" title="表头表尾表示法"></a>表头表尾表示法</h5><ul><li><p><strong>表结点</strong>包括三个域：结点类型标记 tag（为 1）、指向表头的指针 hp 和指向表尾的指针 tp</p><p><strong>原子结点</strong>包括三个域：结点类型标记 tag（为 0）和值 value</p></li><li><p>除空表的表指针为空外，表指针均指向一个表结点，该结点的 hp 域指示该表表头、tp 域指示该表表尾（除非表尾为空，否则必为表结点）</p><img src="..\img\ep5\image-20230111174224504.png" alt="image-20230111174224504" style="zoom:25%;" /></li><li><p><strong>例子</strong>：</p><ul><li><p>A &#x3D; ()</p><p>表示为：A &#x3D; NULL</p></li><li><p>B &#x3D; (a, b, c, d)</p><p>表示为：</p><img src="..\img\ep5\image-20230111182729865.png" alt="image-20230111182729865" style="zoom:25%;" /></li><li><p>C &#x3D; (a, (b, c, d))</p><p>表示为：</p><img src="..\img\ep5\image-20230111182803189.png" alt="image-20230111182803189" style="zoom:25%;" /></li><li><p>D &#x3D; (A, B, C) &#x3D; ((), (a, b, c, d), (a, (b, c, d)))</p><p>表示为：</p><img src="..\img\ep5\image-20230111182836511.png" alt="image-20230111182836511" style="zoom:25%;" /></li><li><p>E &#x3D; (a, E)</p><p>表示为：</p><img src="..\img\ep5\image-20230111182909880.png" alt="image-20230111182909880" style="zoom:25%;" /></li></ul></li><li><p><strong>优点</strong>：容易分清层次；广义表的长度为最高层中表结点的个数，深度为最大层次数减 1；因此，对于求长度、求深度、求表头、求表尾等相关操作很方便</p><p><strong>缺点</strong>：表结点个数多，空间效率低；表结点个数和括号对数不匹配</p></li></ul><h5 id="子表表示法"><a href="#子表表示法" class="headerlink" title="子表表示法"></a>子表表示法</h5><ul><li><p><strong>表结点</strong>包括三个域：结点类型标记 tag（为 1）、指向子表中第一个元素的指针 head 和指向下一个元素的指针 next</p><p><strong>原子结点</strong>包括三个域：结点类型标记 tag（为 0）、值 value 和指向下一个元素的指针 next</p></li><li><p>一个表结点对应一个括号</p><img src="..\img\ep5\image-20230111205131819.png" alt="image-20230111205131819" style="zoom:25%;" /></li><li><p><strong>例子</strong>：</p><ul><li><p>A &#x3D; ()</p><p>表示为：</p><img src="..\img\ep5\image-20230111211428323.png" alt="image-20230111211428323" style="zoom:25%;" /></li><li><p>B &#x3D; (a, b, c, d)</p><p>表示为：</p><img src="..\img\ep5\image-20230111211641331.png" alt="image-20230111211641331" style="zoom:25%;" /></li><li><p>C &#x3D; (a, (b, c, d))</p><p>表示为：</p><img src="..\img\ep5\image-20230111211732220.png" alt="image-20230111211732220" style="zoom:25%;" /></li><li><p>D &#x3D; (A, B, C) &#x3D; ((), (a, b, c, d), (a, (b, c, d)))</p><p>表示为：</p><img src="..\img\ep5\image-20230111211802537.png" alt="image-20230111211802537" style="zoom:25%;" /></li><li><p>E &#x3D; (a, E)</p><p>表示为：</p><img src="..\img\ep5\image-20230111211825606.png" alt="image-20230111211825606" style="zoom:25%;" /></li></ul></li><li><p><strong>优点</strong>：表结点个数少；表结点个数和括号对数一致</p><p><strong>缺点</strong>：写递归算法不方便，例如求深度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GListDepth</span><span class="hljs-params">(GList L)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!L)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (GList p=L;p;p=p-&gt;next) &#123;<br>        <span class="hljs-type">int</span> dep=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (L-&gt;tag==<span class="hljs-number">1</span>)<br>            dep=<span class="hljs-built_in">GListDepth</span>(p-&gt;head);<br>        <span class="hljs-keyword">if</span> (dep&gt;max)<br>            max=dep;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串</title>
    <link href="/2023/03/02/%E4%B8%B2/"/>
    <url>/2023/03/02/%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>数据结构课程笔记 ep4</p><span id="more"></span><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="1-串的定义和操作"><a href="#1-串的定义和操作" class="headerlink" title="1 - 串的定义和操作"></a>1 - 串的定义和操作</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>串（String）</strong>是由零个或多个字符组成的有限序列，串中任意个连续字符组成的子序列称为该串的<strong>子串</strong>（约定空串和该串也为该串的字串），对应地，该串称为<strong>主串</strong>，子串在主串中的位置用子串的第一个字符在主串中的位置来表示</p><h4 id="抽象数据类型和相关操作"><a href="#抽象数据类型和相关操作" class="headerlink" title="抽象数据类型和相关操作"></a>抽象数据类型和相关操作</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk">ADT String &#123;<br>数据对象：<br>D=&#123;a_i|a_i∈CharacterSet,i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...,n&#125;<br>数据关系：<br>R=&#123;&lt;a_i-<span class="hljs-number">1</span>,a_i&gt;|a_i-<span class="hljs-number">1</span>,a_i∈D,i=<span class="hljs-number">2</span>,...,n&#125;<br>基本操作：<br><span class="hljs-regexp">//</span> 销毁串S<br>StrDestroy(&amp;S)<br><span class="hljs-regexp">//</span> 清空串S<br>StrClear(&amp;S)<br><br>最小操作子集<br><span class="hljs-regexp">//</span> 把字符串常量chars赋值给串T<br>StrAssign(&amp;T,chars)<br><span class="hljs-regexp">//</span> 由串S复制得串T<br>StrCopy(&amp;T,S)<br><span class="hljs-regexp">//</span> 由串S1和串S2连接得串T<br>Concat(&amp;T,S1,S2)<br><span class="hljs-regexp">//</span> 按照字典序，若串S1&gt;<span class="hljs-regexp">/=/</span>&lt;串S2，则返回值&gt;<span class="hljs-regexp">/=/</span>&lt;<span class="hljs-number">0</span><br>StrCompare(S1,S2)<br><span class="hljs-regexp">//</span> 求串长<br>StrLength(S)<br><span class="hljs-regexp">//</span> 用Sub返回串S第pos个字符起长度为len的子串（<span class="hljs-number">1</span>≤pos≤StrLength(S)且<span class="hljs-number">0</span>≤len≤StrLength(S)-pos+<span class="hljs-number">1</span>）<br>Substring(&amp;Sub,S,pos,len)<br><br>在最小操作子集上实现的串操作<br><span class="hljs-regexp">//</span> 在串S第pos个字符之前插入串T（<span class="hljs-number">1</span>≤pos≤StrLength(S)+<span class="hljs-number">1</span>）<br>StrInsert(&amp;S,pos,T)<br><span class="hljs-regexp">//</span> 从串S中删除第pos个字符起长度为len的子串（<span class="hljs-number">1</span>≤pos≤StrLength(S)且<span class="hljs-number">0</span>≤len≤StrLength(S)-pos+<span class="hljs-number">1</span>）<br>StrDelete(&amp;S,pos,len)<br><span class="hljs-regexp">//</span> 用串V替换主串S中所有与串T相等的不重叠的子串（串T非空）<br>Replace(&amp;S,T,V)<br><span class="hljs-regexp">//</span> 在主串S第pos个字符后求子串T出现的位置（串T非空且<span class="hljs-number">1</span>≤pos≤StrLength(S)）<br>Index(S,pos,T)<br><span class="hljs-regexp">//</span> 若串S为空，则返回true，否则返回false<br>StrEmpty(S)<br>&#125; ADT String<br></code></pre></td></tr></table></figure><p>在抽象数据类型定义的 13 种基本操作中，赋值、复制、连接、比较、求串长、求子串构成<strong>最小操作子集</strong>，即这些操作无法利用其他操作来实现，而其他操作（除 StrDestroy(&amp;S) 和 StrClear(&amp;S) 外）可以在这个最小操作子集上实现；例如：Index(S,pos,T) 可以利用比较、求串长、求子串的操作来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(String S,<span class="hljs-type">int</span> pos,String T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> n=<span class="hljs-built_in">StrLength</span>(S);<br>        <span class="hljs-type">int</span> m=<span class="hljs-built_in">StrLength</span>(T);<br>        <span class="hljs-type">int</span> i=pos;<br>        <span class="hljs-keyword">while</span> (i&lt;=n-m+<span class="hljs-number">1</span>) &#123;<br>            String sub;<br>            <span class="hljs-built_in">Substring</span>(sub,S,i,m);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">StrCompare</span>(sub,T))<br>                ++i;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>串的逻辑结构与线性表很相似，区别仅在于串的数据对象约束为字符集；但串的基本操作与线性表很不同：线性表通常以“单个元素”作为操作对象，而串通常以“串的整体”作为操作对象</p><h3 id="2-串的表示和实现"><a href="#2-串的表示和实现" class="headerlink" title="2 - 串的表示和实现"></a>2 - 串的表示和实现</h3><p>有时，串只是输入或以供输出的<strong>常量</strong>，此时只需存储此串的串值，即字符序列；但有时，串是需要处理的<strong>变量</strong>，此时需要较好的对其的表示和对其相关操作的实现</p><h4 id="串的顺序存储表示和相关操作的实现"><a href="#串的顺序存储表示和相关操作的实现" class="headerlink" title="串的顺序存储表示和相关操作的实现"></a>串的顺序存储表示和相关操作的实现</h4><h5 id="存储在栈上"><a href="#存储在栈上" class="headerlink" title="存储在栈上"></a>存储在栈上</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSTRLEN 255 <span class="hljs-comment">// 最大串长</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> String[MAXSTRLEN+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 0号单元存放串长</span><br></code></pre></td></tr></table></figure><p><strong>第一个例子</strong>：实现串连接操作 Concat(&amp;T,S1,S2)</p><p>基于串 S1 和串 S2 长度的不同情况，串 T 值的产生可能有以下两种情况：</p><ul><li>若 S1[0] + S2[0] ≤ MAXSTRLEN，则得到完整的串 T</li><li>若 S1[0] + S2[0] &gt; MAXSTRLEN，则将串 S2 的一部分截断，得到的串 T 只包含串 S2 的一个子串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 若得到完整的串T，则返回true，否则返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Concat</span><span class="hljs-params">(String &amp;T,String S1,String S2)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=S1[<span class="hljs-number">0</span>];++i)<br>        T[i]=S1[i];<br>    <span class="hljs-keyword">if</span> (S1[<span class="hljs-number">0</span>]+S2[<span class="hljs-number">0</span>]&lt;=MAXSTRLEN) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=S2[<span class="hljs-number">0</span>];++i)<br>            T[S1[<span class="hljs-number">0</span>]+i]=S2[i];<br>        T[<span class="hljs-number">0</span>]=S1[<span class="hljs-number">0</span>]+S2[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=S1[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;i&lt;=MAXSTRLEN;++i)<br>            T[i]=S2[i-S1[<span class="hljs-number">0</span>]];<br>        T[<span class="hljs-number">0</span>]=MAXSTRLEN;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二个例子</strong>：实现求字串操作 Substring(&amp;Sub,S,pos,len)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 需满足1≤pos≤StrLength(S)且0≤len≤StrLength(S)-pos+1，若满足，则用Sub返回结果，且返回true，否则返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Substring</span><span class="hljs-params">(String &amp;Sub,String S,<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos&lt;<span class="hljs-number">1</span>||pos&gt;S[<span class="hljs-number">0</span>]||len&lt;<span class="hljs-number">0</span>||len&gt;S[<span class="hljs-number">0</span>]-pos+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i)<br>        Sub[i]=S[pos+i<span class="hljs-number">-1</span>];<br>    Sub[<span class="hljs-number">0</span>]=len;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结</strong>：</p><p>存储在栈上的顺序串有固定的最大串长，实现相关操作时，其基本方法为字符序列的<strong>复制</strong>，要注意<strong>截断</strong>超过最大串长的部分</p><p>存储在栈上的顺序串适合实现相关操作时不大可能产生截断（即串长远小于最大串长）的情况</p><p>如果需要完全避免产生截断，需要动态分配内存即存储在堆上的顺序串</p><h5 id="存储在堆上"><a href="#存储在堆上" class="headerlink" title="存储在堆上"></a>存储在堆上</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">char</span>* pstr; <span class="hljs-comment">// 若非空串，则按串长分配内存，否则为NULL</span><br>    <span class="hljs-type">int</span> len;<br>&#125; String;<br></code></pre></td></tr></table></figure><p><strong>第一个例子</strong>：实现串连接操作 Concat(&amp;T,S1,S2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Concat</span><span class="hljs-params">(String &amp;T,String S1,String S2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (T.pstr)<br>        <span class="hljs-built_in">free</span>(T.pstr);<br>    T.pstr=<span class="hljs-literal">NULL</span>;<br>    T.len=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (S1.len+S2.len!=<span class="hljs-number">0</span>) &#123;<br>    T.pstr=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>((S1.len+S2.len)*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>    <span class="hljs-keyword">if</span> (!T.pstr)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;S1.len;++i)<br>        T.pstr[i]=S1.pstr[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;S2.len;++i)<br>        T.pstr[S1.len+i]=S2.pstr[i];<br>    T.len=S1.len+S2.len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二个例子</strong>：实现求字串操作 Substring(&amp;Sub,S,pos,len)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 需满足1≤pos≤StrLength(S)且0≤len≤StrLength(S)-pos+1，若满足，则用Sub返回结果，且返回true，否则返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Substring</span><span class="hljs-params">(String &amp;Sub,String S,<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos&lt;<span class="hljs-number">1</span>||pos&gt;S.len||len&lt;<span class="hljs-number">0</span>||len&gt;S.len-pos+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (Sub.pstr)<br>        <span class="hljs-built_in">free</span>(Sub.pstr);<br>    Sub.pstr=<span class="hljs-literal">NULL</span>;<br>    Sub.len=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (len!=<span class="hljs-number">0</span>) &#123;<br>    Sub.pstr=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(len*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>    <span class="hljs-keyword">if</span> (!Sub.pstr)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        Sub.pstr[i]=S.pstr[pos+i<span class="hljs-number">-1</span>];<br>    Sub.len=len;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三个例子</strong>：实现在串 S 第 pos 个字符之前插入串 T 的操作 StrInsert(&amp;S,pos,T)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 需满足1≤pos≤StrLength(S)+1，若满足，则返回true，否则返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StrInsert</span><span class="hljs-params">(String &amp;S,<span class="hljs-type">int</span> pos,String T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos&lt;<span class="hljs-number">1</span>||pos&gt;S.len+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (T.len!=<span class="hljs-number">0</span>) &#123;<br>        S.pstr=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">realloc</span>(S.pstr,(S.len+T.len)*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>        <span class="hljs-keyword">if</span> (!S.pstr)<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=S.len<span class="hljs-number">-1</span>;i&gt;=pos<span class="hljs-number">-1</span>;--i)<br>            S.pstr[T.len+i]=S.pstr[i]; <span class="hljs-comment">// 后移T.len个位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=pos<span class="hljs-number">-1</span>;i&lt;=pos+T.len<span class="hljs-number">-2</span>;++i)<br>        S.pstr[i]=T.pstr[i-pos+<span class="hljs-number">1</span>];<br>        S.len+=T.len;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结</strong>：</p><p>存储在堆上的顺序串按串长分配内存，实现相关操作时，其基本方法为若新串非空，则先为新串分配内存、再进行字符序列的<strong>复制</strong>，要注意在此之前确保新串旧内存被释放</p><p>由于存储在堆上的顺序串既有一片连续内存，又对串长没有任何限制，因此，常用这一存储结构</p><h4 id="串的链式存储表示"><a href="#串的链式存储表示" class="headerlink" title="串的链式存储表示"></a>串的链式存储表示</h4><p>在链式串中，每个结点可以存放一个字符，也可以存放多个字符；当每个结点存放多个字符时，由于串长不一定是结点可存字符数量的整数倍，因此最后一个结点不一定全被串值占满，此时通常补上“#”或其他非串值字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80 <span class="hljs-comment">// 结点可存字符数量</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span> &#123;<br>    <span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span>* next;<br>&#125; Chunk;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Chunk *head,*tail; <span class="hljs-comment">// 头指针和尾指针</span><br>    <span class="hljs-type">int</span> len; <span class="hljs-comment">// 串长</span><br>&#125; String;<br></code></pre></td></tr></table></figure><p><strong>小结</strong>：串的链式存储结构对于某些操作（如串连接等）有一定方便之处，但不如顺序存储结构灵活，链式串占用存储量大且操作复杂</p><h3 id="3-串的模式匹配算法"><a href="#3-串的模式匹配算法" class="headerlink" title="3 - 串的模式匹配算法"></a>3 - 串的模式匹配算法</h3><p>串的模式匹配就是在主串中定位子串（或称模式串）的 Index 操作，其实际应用就是众多软件的“查找”功能，以下是以在栈上的顺序存储结构表示串时的模式匹配算法：</p><h4 id="第一种算法：暴力算法"><a href="#第一种算法：暴力算法" class="headerlink" title="第一种算法：暴力算法"></a>第一种算法：暴力算法</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><img src="..\img\ep4\image-20230109181008482.png" alt="image-20230109181008482" style="zoom:25%;" /><p>若匹配失败（将模式串<strong>从第一个字符到最后一个字符</strong>与主串对应位置的字符进行比对，出现不同即匹配失败），则回退 i 并将模式串往后移动一格，继续匹配</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>参考“1 - 串的定义和操作”中 Index 操作的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(String S,<span class="hljs-type">int</span> pos,String T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> i=pos,j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i&lt;=S[<span class="hljs-number">0</span>]&amp;&amp;j&lt;=T[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">if</span> (S[i]==T[j]) &#123;<br>                ++i;<br>                ++j;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 将模式串往后移动一格，继续匹配</span><br>                i=i-j+<span class="hljs-number">2</span>;<br>                j=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j&gt;T[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> i-j+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>时间复杂度：O(n*m)，其中 n 为主串长度，m 为模式串长度</p><h4 id="第二种算法：先进行首尾匹配的暴力算法"><a href="#第二种算法：先进行首尾匹配的暴力算法" class="headerlink" title="第二种算法：先进行首尾匹配的暴力算法"></a>第二种算法：先进行首尾匹配的暴力算法</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>与普通的暴力算法相同，只是匹配时先比对模式串的<strong>第一个字符</strong>，再比对模式串的<strong>最后一个字符</strong>，最后将模式串<strong>从第二个字符到倒数第二个字符</strong>与主串对应位置的字符进行比对，出现不同即匹配失败</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(String S,<span class="hljs-type">int</span> pos,String T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> i=pos,j=<span class="hljs-number">1</span>,flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i&lt;=S[<span class="hljs-number">0</span>]&amp;&amp;j&lt;=T[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (flag&amp;&amp;(S[i]!=T[<span class="hljs-number">1</span>]||S[i+T[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>]!=T[T[<span class="hljs-number">0</span>]])) &#123;<br>                ++i;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag) &#123;<br>                ++i;<br>                ++j;<br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (S[i]==T[j]) &#123;<br>                ++i;<br>                ++j;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                i=i-j+<span class="hljs-number">2</span>;<br>                j=<span class="hljs-number">1</span>;<br>                flag=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j==T[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> i-j+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>与普通的暴力算法相比，有了一定优化，但时间复杂度仍为 O(n*m)</p><h4 id="第三种算法：KMP-算法"><a href="#第三种算法：KMP-算法" class="headerlink" title="第三种算法：KMP 算法"></a>第三种算法：KMP 算法</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><ul><li><p><strong>模式串的“预处理”过程</strong>：对模式串的每个前缀求其最长公共前后缀的长度，得到前缀表（或称 Next 数组）</p><ul><li><p><strong>一些规定</strong></p><ol><li><p>前缀：以串”ABCDE”为例，前缀有”A”, “AB”, “ABC”, “ABCD”（不含自身）</p></li><li><p>后缀：以串”ABCDE”为例，后缀有”E”, “DE”, “CDE”, “BCDE”（不含自身）</p></li><li><p>最长公共前后缀：串中长度相等的前缀和后缀所能达到的满足“前后缀相等”条件的最大长度，其对应前后缀就是最长公共前后缀</p><p>例如：串”ABCAB”的最长公共前后缀为”AB”，其长度为 2；串”ABABA”的最长公共前后缀为”ABA”，其长度为 3；串”ABCDE”的最长公共前后缀的长度为 0</p></li></ol></li><li><p>以串”ABABCABAA”为例</p><p><strong>“对模式串的每个前缀求其最长公共前后缀的长度”的过程</strong>：</p><table><thead><tr><th align="center">前缀</th><th align="center">最长公共前后缀长度</th></tr></thead><tbody><tr><td align="center">“A”</td><td align="center">0</td></tr><tr><td align="center">“AB”</td><td align="center">0</td></tr><tr><td align="center">“ABA”</td><td align="center">1</td></tr><tr><td align="center">“ABAB”</td><td align="center">2</td></tr><tr><td align="center">“ABABC”</td><td align="center">0</td></tr><tr><td align="center">“ABABCA”</td><td align="center">1</td></tr><tr><td align="center">“ABABCAB”</td><td align="center">2</td></tr><tr><td align="center">“ABABCABA”</td><td align="center">3</td></tr></tbody></table><p><strong>“得到前缀表”的过程</strong>*：先将上面求得的“最长公共前后缀长度”统一加 1，再在前面添 0，通常将模式串和前缀表写在一起</p><table><thead><tr><th align="center">模式串</th><th align="center">A</th><th align="center">B</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">A</th><th align="center">B</th><th align="center">A</th><th align="center">A</th></tr></thead><tbody><tr><td align="center">前缀表</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td></tr></tbody></table><p>*模式串有下标从 0 起、从 1 起等等约定方式，针对不同约定方式，自行尝试得到求前缀表的方法</p></li></ul></li><li><p><strong>具体原理</strong>：</p><img src="..\img\ep4\image-20230109223308711.png" alt="image-20230109223308711" style="zoom:25%;" /><ul><li><p>若匹配失败，按照暴力算法应该回退 i 并将模式串往后移动一格，继续匹配，如图示 1：</p><p>已知：1 部分 &#x3D; 2 部分（平移），3 部分 &#x3D; 4 部分（比对成功所得信息）</p><p>假设：2 部分 ≠ 3 部分</p><p>那么：1 部分 ≠ 4 部分，因此下一次匹配是无用的</p></li><li><p>将模式串往后移动两格，如图示 2：</p><p>已知：1 部分 &#x3D; 2 部分（平移），3 部分 &#x3D; 4 部分（比对成功所得信息）</p><p>假设：2 部分 &#x3D; 3 部分（即 2 部分和 3 部分为匹配失败处之前的模式串的最长公共前后缀）</p><p>那么：1 部分 &#x3D; 4 部分，因此下一次匹配是有效的，并且因为保证了 1 部分和 4 部分相等，i 无需回退，继续往后移动</p></li><li><p><strong>KMP 算法就是暴力算法的延申</strong>：在匹配失败时，暴力算法将模式串往后移动一格，但很有可能下一次匹配是无用的；匹配失败处之前的模式串已经与主串比对过，KMP 算法利用比对成功所得信息、结合“预处理”所得前缀表，将模式串往后精确地移动若干格，避免了回退 i，降低了时间复杂度</p></li></ul></li></ul><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><ul><li><p><strong>主算法</strong>：</p><ol><li><p>假设指针 i 和 j 分别指示主串 S 和模式串 T 中正待比对的字符，i 初始化为 pos，j 初始化为 1</p></li><li><p>比对过程：</p><ul><li>若 S[i] &#x3D; T[j]，则 i 和 j 分别增 1</li><li>若 S[i] ≠ T[j] 且 Next[j] ≠ 0，则 i 不变，j 变为 Next[j]</li><li>若 S[i] ≠ T[j] 且 Next[j] &#x3D; 0，则 i 增 1，j 变为 1</li></ul><p>重复上述过程，直至 j &gt; T[0]（成功）或 i &gt; S[0]（失败）</p></li></ol></li><li><p><strong>求 Next 数组（即前缀表）算法</strong>：</p><p>求 Next 数组的过程是一个递推过程，分析如下：</p><p>已知：Next[1] &#x3D; 0</p><p>假设：Next[j] &#x3D; k，即在模式串中：”T[1]…T[k-1]” &#x3D; “T[j-k+1]…T[j-1]”</p><ul><li><p>若 T[k] &#x3D; T[j]，即在模式串中：”T[1]…T[k-1]T[k]” &#x3D; “T[j-k+1]…T[j-1]T[j]”，则 Next[j+1] &#x3D; k+1，即 Next[j+1] &#x3D; Next[j]+1</p></li><li><p>若 T[k] ≠ T[j]，即在模式串中：”T[1]…T[k-1]T[k]” ≠ “T[j-k+1]…T[j-1]T[j]”，则令 k &#x3D; Next[k]，若 T[k] ≠ T[j]，循环此步直至 T[k] &#x3D; T[j] 或 k &#x3D; 0，该过程如下图：</p><img src="..\img\ep4\image-20230110120540489.png" alt="image-20230110120540489" style="zoom:25%;" /><ul><li>若因为 T[k] &#x3D; T[j] 退出循环，则 Next[j+1] &#x3D; k+1</li><li>若因为 k &#x3D; 0 退出循环，则 Next[j+1] &#x3D; 1</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(String T,<span class="hljs-type">int</span> Next[])</span> </span>&#123;<br>    Next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (j&lt;T[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">if</span> (T[k]==T[j]||k==<span class="hljs-number">0</span>) &#123;<br>            ++j;<br>            ++k;<br>            Next[j]=k;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            k=Next[k];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(String S,<span class="hljs-type">int</span> pos,String T,<span class="hljs-type">int</span> Next[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> i=pos,j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i&lt;=S[<span class="hljs-number">0</span>]&amp;&amp;j&lt;=T[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">if</span> (S[i]==T[j]) &#123;<br>                ++i;<br>                ++j;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Next[j]!=<span class="hljs-number">0</span>)<br>                j=Next[j];<br>            <span class="hljs-keyword">else</span> &#123;<br>                ++i;<br>                j=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j&gt;T[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> i-j+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><ol><li><p>时间复杂度：O(n+m)</p></li><li><p>Next 数组（即前缀表）还可以改进，在下述的特殊情况下提高效率：</p><p>主串：    “aaabaaabaaabaaabaaab”<br>模式串：”aaaab”<br>前缀表： 01234</p><p>当 i &#x3D; 4, j &#x3D; 4 时，S[i] ≠ T[j]，根据 Next[j] 还需进行 i &#x3D; 4, j &#x3D; 3 以及 i &#x3D; 4, j &#x3D; 2 以及 i &#x3D; 4, j &#x3D; 1 三次比较。实际上，因为在模式串中第 1, 2, 3 个字符和第 4 个字符都相等，所以不需要再三比较，而可以将模式串直接向右滑动 4 个字符进行 i &#x3D; 5, j &#x3D; 1 时的字符比较</p></li></ol><h4 id="第四种算法：BM-算法"><a href="#第四种算法：BM-算法" class="headerlink" title="第四种算法：BM 算法"></a>第四种算法：BM 算法</h4><p><a href="https://www.bilibili.com/video/BV18Y4y187wH/?spm_id_from=333.337.search-card.all.click&vd_source=641340b7f20c3877c40d25f141fb4902">字符串搜索-BM - 哔哩哔哩</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列</title>
    <link href="/2023/03/02/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/03/02/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>数据结构课程笔记 ep3</p><span id="more"></span><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="1-栈的定义与实现（后进先出）"><a href="#1-栈的定义与实现（后进先出）" class="headerlink" title="1 - 栈的定义与实现（后进先出）"></a>1 - 栈的定义与实现（后进先出）</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>栈（Stack）</strong>是限定仅在表尾进行插入和删除操作的线性表。进行插入和删除操作的一端（表尾）为<strong>栈顶（Top）</strong>，另一端（表头）为<strong>栈底（Base）</strong>。当表中没有元素时，称为<strong>空栈</strong>。</p><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ADT Stack &#123;<br>数据对象：<br>D=&#123;a_i<span class="hljs-pattern-match">|a<span class="hljs-constructor">_i</span>∈<span class="hljs-constructor">ElemSet</span>,i=1,2,<span class="hljs-operator">...</span>,n&#125;</span><br><span class="hljs-pattern-match">数据关系：</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">R</span>=&#123;&lt;a<span class="hljs-constructor">_i</span>-1,a<span class="hljs-constructor">_i</span>&gt;|a<span class="hljs-constructor">_i</span>-1,a<span class="hljs-constructor">_i</span>∈<span class="hljs-constructor">D</span>,i=2,<span class="hljs-operator">...</span>,n&#125;</span><br><span class="hljs-pattern-match">(约定a<span class="hljs-constructor">_n</span>为栈顶，a<span class="hljs-constructor">_1</span>为栈底)</span><br><span class="hljs-pattern-match">基本操作：</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">InitStack(&amp;S)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">DestroyStack(&amp;S)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">StackLength(S)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">StackEmpty(S)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">GetTop(S,&amp;<span class="hljs-params">e</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 需判空</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">ClearStack(&amp;S)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">Push(&amp;S,<span class="hljs-params">e</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 需判满</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">Pop(&amp;S,&amp;<span class="hljs-params">e</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 需判空</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">StackTravers(S,<span class="hljs-params">visit</span>()</span>)</span><br><span class="hljs-pattern-match">&#125; <span class="hljs-constructor">ADT</span> <span class="hljs-constructor">Stack</span></span><br></code></pre></td></tr></table></figure><h4 id="用顺序存储结构实现栈"><a href="#用顺序存储结构实现栈" class="headerlink" title="用顺序存储结构实现栈"></a>用顺序存储结构实现栈</h4><p>利用一组地址连续的存贮单元依次存放从栈底到栈顶的若干数据元素。</p><h5 id="第一种实现：定长数组"><a href="#第一种实现：定长数组" class="headerlink" title="第一种实现：定长数组"></a>第一种实现：定长数组</h5><p><strong>规定</strong>：栈顶指针Top指向最后一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ----------Sqstack.h----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SQSTACK_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQSTACK_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100 <span class="hljs-comment">// 栈的最大容量</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T   Stack[MAXSIZE]; <span class="hljs-comment">// 静态分配，相应的动态分配方式为：T* Stack;</span><br>    <span class="hljs-type">int</span> Top; <span class="hljs-comment">// 栈顶元素在数组中的位置</span><br>&#125; SqStack;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S,T &amp;e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S,T e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S,T &amp;e)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ----------Sqstack.cpp----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Sqstack.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span> </span>&#123;<br>    S.Top=<span class="hljs-number">-1</span>; <span class="hljs-comment">// 栈空</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> S.Top+<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> S.Top&lt;<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.Top&lt;<span class="hljs-number">0</span>) <span class="hljs-comment">// 判空</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    e=S.Stack[S.Top];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span> </span>&#123;<br>    S.Top=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S,T e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.Top&gt;=MAXSIZE<span class="hljs-number">-1</span>) <span class="hljs-comment">// 判满</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    S.Stack[++S.Top]=e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.Top&lt;<span class="hljs-number">0</span>) <span class="hljs-comment">// 判空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>e=S.Stack[S.Top--];<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="第二种实现：不定长数组"><a href="#第二种实现：不定长数组" class="headerlink" title="第二种实现：不定长数组"></a>第二种实现：不定长数组</h5><p><strong>规定</strong>：栈顶指针Top指向最后一个元素的下一个位置</p><img src="..\img\ep3\image-20221004212203820.png" alt="image-20221004212203820" style="zoom:25%;" /><p><strong>判满</strong>：S.Top-S.Base&gt;&#x3D;S.Stacksize</p><p><strong>判空</strong>：S.Base&#x3D;&#x3D;S.Top</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ----------Sqstack.h----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SQSTACK_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQSTACK_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_INIT_SIZE 80</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_INCREMENT 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T*  Base;<br>    T*  Top;<br>    <span class="hljs-type">int</span> Stacksize;<br>&#125; SqStack;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S,T &amp;e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S,T e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S,T &amp;e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ----------Sqstack.cpp----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Sqstack.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span> </span>&#123;<br>    S.Base=(T*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE*<span class="hljs-built_in">sizeof</span>(T));<br>    <span class="hljs-keyword">if</span> (!S.Base)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    S.Top=S.Base;<br>    S.Stacksize=STACK_INIT_SIZE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> S.Top-S.Base;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> S.Base==S.Top?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.Base==S.Top) <span class="hljs-comment">// 判空</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    e=*(S.Top<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(S.Base);<br>    S.Base=(T*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE*<span class="hljs-built_in">sizeof</span>(T));<br>    <span class="hljs-keyword">if</span> (!S.Base)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    S.Top=S.Base;<br>    S.Stacksize=STACK_INIT_SIZE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S,T e)</span> </span>&#123;<br>    <span class="hljs-comment">// 判满，追加存储空间</span><br><span class="hljs-keyword">if</span> (S.Top-S.Base&gt;=S.Stacksize) &#123;<br>        S.Base=(T*)<span class="hljs-built_in">realloc</span>(S.Base,<span class="hljs-built_in">sizeof</span>(T)*(S.Stacksize+STACK_INCREMENT));<br>    <span class="hljs-keyword">if</span> (!S.Base)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    S.Top=S.Base+S.Stacksize;<br>        S.Stacksize+=STACK_INCREMENT;<br>    &#125;<br>    *S.Top=e;<br>    S.Top++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.Base==S.Top) <span class="hljs-comment">// 判空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    S.Top--;<br>    e=*S.Top;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(S.Base);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="第三种实现：共享栈"><a href="#第三种实现：共享栈" class="headerlink" title="第三种实现：共享栈"></a>第三种实现：共享栈</h5><p>如果在一个程序中需要使用多个栈，最好能采用多个栈共享空间的方法，即给多个栈分配一个足够大的数组空间，利用栈的动态特性，使其存储空间互相补充。</p><p>一种两个栈共享空间的方法是：将这两个栈的栈底设在数组的两端，让它们的栈顶向数组中间增长。这样当一个栈中元素较多时，就可以越过数组的中点，延伸到另一个栈的部分空间中去。当两个栈的栈顶相遇时，才会发生“上溢”。</p><img src="..\img\ep3\image-20221004235548146.png" alt="image-20221004235548146" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 结构体声明</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T   Stack[MAXSIZE];<br><span class="hljs-type">int</span> Top1,Top2;<br>&#125; DuStack;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 共享栈入栈</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-type">int</span> i,T e)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (S.Top1==S.Top2<span class="hljs-number">-1</span>) <span class="hljs-comment">// 判满</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (i==<span class="hljs-number">1</span>) <span class="hljs-comment">// 对第一个栈进行入栈操作</span><br>        S.Stack[++S.Top1]=e;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 对第二个栈进行入栈操作</span><br>        S.Stack[--S.Top2]=e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 共享栈出栈</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(<span class="hljs-type">int</span> i,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i==<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 对第一个栈进行出栈操作</span><br>        <span class="hljs-keyword">if</span> (S.Top1==<span class="hljs-number">-1</span>) <span class="hljs-comment">// 判空</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> &#123;<br>            e=S.Stack[S.Top1--];<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 对第二个栈进行出栈操作</span><br>        <span class="hljs-keyword">if</span> (S.Top2==MAXSIZE) <span class="hljs-comment">// 判空</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            e=S.Stack[S.Top2++];<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用链式存储结构实现栈"><a href="#用链式存储结构实现栈" class="headerlink" title="用链式存储结构实现栈"></a>用链式存储结构实现栈</h4><img src="..\img\ep3\image-20221006123601271.png" alt="image-20221006123601271" style="zoom:25%;" /><p>上面一种实现 Pop 操作时间复杂度为 O(n)，故使用下面一种实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 结构体声明</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Snode</span> &#123;<br>    T Data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Snode</span>* Next;<br>&#125; *LinkStack;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 链式栈入栈</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack &amp;Top,T e)</span> </span>&#123;<br>    LinkStack t=(LinkStack)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Snode));<br>    <span class="hljs-keyword">if</span> (t==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 内存无可用空间，栈上溢</span><br>t-&gt;Data=e;<br>    t-&gt;Next=Top;<br>    Top=t;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 链式栈出栈</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack &amp;Top,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Top==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 判空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    LinkStack p=Top;<br>    Top=p-&gt;Next;<br>    e=p-&gt;Data;<br>    <span class="hljs-built_in">free</span> (p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于链栈，不会产生单个栈满而其余栈空的情形，只有当系统空间全部用完，malloc 过程无法实现时才会发生上溢，因此多个链栈共享空间也就是自然的事了。</p><h4 id="顺序栈还是链式栈？"><a href="#顺序栈还是链式栈？" class="headerlink" title="顺序栈还是链式栈？"></a>顺序栈还是链式栈？</h4><p>栈广泛应用于程序设计中。当要解决的问题具有先进后出的特点时就可以用栈。</p><p>顺序栈、链栈的基本操作的时间复杂度都是 O(1)。顺序栈需要预先分配空间，链栈动态生成。如果需要访问内部节点，顺序栈更快。当最大需要容量事先不能估计时，采用链式存储结构是有效的方法。</p><h3 id="2-栈的应用举例"><a href="#2-栈的应用举例" class="headerlink" title="2 - 栈的应用举例"></a>2 - 栈的应用举例</h3><h4 id="例一：数制转换"><a href="#例一：数制转换" class="headerlink" title="例一：数制转换"></a>例一：数制转换</h4><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>(1348)10 &#x3D; (2504)8，其运算过程如下：</p><table><thead><tr><th>N</th><th>N&#x2F;8</th><th>N%8</th></tr></thead><tbody><tr><td>1348</td><td>168</td><td>4</td></tr><tr><td>168</td><td>21</td><td>0</td></tr><tr><td>21</td><td>2</td><td>5</td></tr><tr><td>2</td><td>0</td><td>2</td></tr></tbody></table><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>N%8 从上往下得出，从下往上输出，用栈实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> stacksize 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> base[stacksize];<br>    <span class="hljs-type">int</span> top;<br>&#125; <span class="hljs-built_in">stack</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span> &#123;<br>    s-&gt;top=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span> &#123;<br>    <span class="hljs-keyword">return</span> s-&gt;top&lt;<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s,<span class="hljs-type">int</span> e)</span> &#123; <span class="hljs-comment">// C语言风格的写法</span><br>    <span class="hljs-keyword">if</span> (s-&gt;top&gt;=stacksize<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    s-&gt;base[++s-&gt;top]=e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s,<span class="hljs-type">int</span>* e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s-&gt;top&lt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    *e=s-&gt;base[s-&gt;top--];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintConversion</span><span class="hljs-params">(<span class="hljs-type">int</span> format,<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-built_in">stack</span> s;<br>    InitStack(&amp;s);<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        Push(&amp;s,n%format);<br>        n/=format;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!StackEmpty(&amp;s)) &#123;<br>        <span class="hljs-type">int</span> e;<br>        Pop(&amp;s,&amp;e);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,e);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n; <span class="hljs-comment">// n&lt;=10</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    PrintConversion(<span class="hljs-number">8</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例二：括号的匹配检验"><a href="#例二：括号的匹配检验" class="headerlink" title="例二：括号的匹配检验"></a>例二：括号的匹配检验</h4><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>假设在表达式中，<code>[([][])]</code>为正确的格式，<code>[([)[])]</code>或<code>([][])]</code>或<code>[([][])</code>均为不正确的格式。</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>简化实现，假设括号都为圆括号：</p><ol><li>凡出现左括弧：进栈</li><li>凡出现右括弧：首先检查栈空，若栈空，则表明该“右括弧”多余，<strong>表达式不正确</strong>；否则和栈顶元素比较，若匹配，则“左括弧出栈”，否则<strong>表达式不正确</strong></li><li>表达式检验结束时：检查栈空，若栈空，则表达式正确，否则<strong>表达式不正确</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Matching</span><span class="hljs-params">(String &amp;exp)</span> </span>&#123;<br>    Stack s;<br>    <span class="hljs-built_in">InitStack</span>(s);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,state=<span class="hljs-number">1</span>; <span class="hljs-comment">// 表达式正确状态为1，不正确为0</span><br>    <span class="hljs-keyword">while</span> (i&lt;=<span class="hljs-built_in">Length</span>(exp)&amp;&amp;state) &#123;<br>        <span class="hljs-keyword">switch</span> (exp[i]) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;(&quot;</span>:<br>                <span class="hljs-built_in">Push</span>(s,exp[i]);<br>                i++;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;)&quot;</span>:<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">StackEmpty</span>(s)&amp;&amp;<span class="hljs-built_in">GetTop</span>(s)==<span class="hljs-string">&quot;(&quot;</span>)<br>                    <span class="hljs-built_in">Pop</span>(s);<br>                i++;<br>                <span class="hljs-keyword">else</span><br>                    state=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">StackEmpty</span>(s)&amp;&amp;state)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例三：迷宫问题-Maze-Problem"><a href="#例三：迷宫问题-Maze-Problem" class="headerlink" title="例三：迷宫问题 Maze Problem"></a>例三：迷宫问题 Maze Problem</h4><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p><a href="https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc">迷宫问题</a></p><h5 id="实现（栈实现）"><a href="#实现（栈实现）" class="headerlink" title="实现（栈实现）"></a>实现（栈实现）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> maze[N][N];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">int</span> top;<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; s[N*N];<br>&#125; stack;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(stack &amp;st)</span> </span>&#123;<br>st.top=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(stack &amp;st)</span> </span>&#123;<br><span class="hljs-keyword">return</span> st.top&lt;<span class="hljs-number">0</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetTop</span><span class="hljs-params">(stack &amp;st)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(st.s[st.top].first,st.s[st.top].second);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(stack &amp;st,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; l)</span> </span>&#123;<br>++st.top;<br>st.s[st.top].first=l.first;<br>st.s[st.top].second=l.second;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">(stack &amp;st)</span> </span>&#123;<br>--st.top;<br>&#125;<br><br>stack st;<br><br><span class="hljs-type">int</span> d[N][N]; <span class="hljs-comment">// 规定：东0 南1 西2 北3</span><br><span class="hljs-type">int</span> dr[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dc[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>cin &gt;&gt; maze[i][j];<br><span class="hljs-built_in">Init</span>(st);<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> d);<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; l=<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=d[l.first][l.second]+<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">4</span>;i++) &#123;<br><span class="hljs-type">int</span> r=l.first+dr[i];<br><span class="hljs-type">int</span> c=l.second+dc[i];<br><span class="hljs-keyword">if</span> (maze[r][c]==<span class="hljs-number">0</span>&amp;&amp;r&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;n&amp;&amp;c&gt;=<span class="hljs-number">0</span>&amp;&amp;c&lt;m&amp;&amp;(r!=<span class="hljs-built_in">GetTop</span>(st).first||c!=<span class="hljs-built_in">GetTop</span>(st).second))<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">4</span>) &#123;<br><span class="hljs-built_in">Push</span>(st,l);<br>d[l.first][l.second]=i;<br>l.first+=dr[i];<br>l.second+=dc[i];<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (l.first==n<span class="hljs-number">-1</span>&amp;&amp;l.second==m<span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">Push</span>(st,l);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>l.first=<span class="hljs-built_in">GetTop</span>(st).first;<br>l.second=<span class="hljs-built_in">GetTop</span>(st).second;<br><span class="hljs-built_in">Pop</span>(st);<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isEmpty</span>(st));<br>stack st2;<br><span class="hljs-built_in">Init</span>(st2);<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isEmpty</span>(st)) &#123;<br><span class="hljs-built_in">Push</span>(st2,<span class="hljs-built_in">GetTop</span>(st));<br><span class="hljs-built_in">Pop</span>(st);<br>&#125;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isEmpty</span>(st2)) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; <span class="hljs-built_in">GetTop</span>(st2).first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; <span class="hljs-built_in">GetTop</span>(st2).second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">Pop</span>(st2);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例四：表达式求值"><a href="#例四：表达式求值" class="headerlink" title="例四：表达式求值"></a>例四：表达式求值</h4><h5 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h5><p>在计算机中，表达式求值广为使用的是一种简单直观的算法“算符优先法”。它是根据算符优先关系的规定来实现对表达式的<strong>编译或解释</strong>的。它的实现是栈应用的又一个典型例子。</p><p>为了叙述的简洁，仅讨论简单算术表达式求值的问题，这种表达式仅包含加、减、乘、除、左右括号以及约定的结束符“#”六种算符。不难将它推广到更一般的表达式上。</p><p>以下是简单算术表达式中涉及到的算符的优先关系（左边栏算符和上边栏算符是表达式中相继出现的两个算符；左边栏算符&gt;&#x3D;&lt;上边栏算符）：</p><table><thead><tr><th align="center"></th><th align="center">+</th><th align="center">-</th><th align="center">*</th><th align="center">&#x2F;</th><th align="center">(</th><th align="center">)</th><th align="center">#</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&gt;</td><td align="center">&gt;</td></tr><tr><td align="center">-</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&gt;</td><td align="center">&gt;</td></tr><tr><td align="center">*</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">&lt;</td><td align="center">&gt;</td><td align="center">&gt;</td></tr><tr><td align="center">&#x2F;</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">&lt;</td><td align="center">&gt;</td><td align="center">&gt;</td></tr><tr><td align="center">(</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&#x3D;</td><td align="center"></td></tr><tr><td align="center">)</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">&gt;</td><td align="center"></td><td align="center">&gt;</td><td align="center">&gt;</td></tr><tr><td align="center">#</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">&lt;</td><td align="center"></td><td align="center">&#x3D;</td></tr></tbody></table><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p>两个工作栈：</p><ul><li>OPTR 栈：寄存算符</li><li>OPND 栈：寄存操作数或运算结果</li></ul><p>算法基本思想：</p><ol><li>初始化 OPTR 栈和 OPND 栈，将起始符“#” Push 进入 OPTR 栈；</li><li>读入表达式中的每个字符：若是操作数，则进 OPND 栈；若是算符，则和 OPTR 栈的栈顶算符比较优先关系后作<strong>相应操作</strong>，直至整个表达式求值完毕（即 OPTR 栈的栈顶元素和当前读入的字符均为“#”）；</li><li>相应操作为：<ul><li>若后来算符 &gt; 栈顶算符，则后来算符入栈；</li><li>若后来算符 &#x3D; 栈顶算符（括号情况），则 Pop 一个算符，后来算符不入栈（脱括号并接收下一字符）；</li><li>若后来算符 &lt; 栈顶算符，则 Pop 一个算符和两个操作数，将运算结果 Push 进入 OPND 栈，继续比较至后来算符 &gt; 或 &#x3D; 栈顶算符。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 为简化，仅支持0~9的简单算术表达式求值，每步四则运算结果都为0~9</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> top;<br>&#125; Stack;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(Stack &amp;S)</span> </span>&#123;<br>    S.top=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(Stack S)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> S.s[S.top];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(Stack &amp;S,<span class="hljs-type">char</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top&gt;=<span class="hljs-number">99</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    S.s[++S.top]=e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(Stack &amp;S,<span class="hljs-type">char</span> &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top&lt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>e=S.s[S.top--];<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Precede</span><span class="hljs-params">(<span class="hljs-type">char</span> stop,<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (stop) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;=&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<br>        <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;=&#x27;</span>;<br>&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Operate</span><span class="hljs-params">(<span class="hljs-type">char</span> a,<span class="hljs-type">char</span> theta,<span class="hljs-type">char</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (theta==<span class="hljs-string">&#x27;+&#x27;</span>)<br>        <span class="hljs-keyword">return</span> a+b-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta==<span class="hljs-string">&#x27;-&#x27;</span>)<br>        <span class="hljs-keyword">return</span> a-b+<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta==<span class="hljs-string">&#x27;*&#x27;</span>)<br>        <span class="hljs-built_in">return</span> (a-<span class="hljs-string">&#x27;0&#x27;</span>)*(b-<span class="hljs-string">&#x27;0&#x27;</span>)+<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta==<span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-built_in">return</span> (a-<span class="hljs-string">&#x27;0&#x27;</span>)/(b-<span class="hljs-string">&#x27;0&#x27;</span>)+<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">EvaluateExpression</span><span class="hljs-params">()</span> </span>&#123;<br>    Stack OPND,OPTR;<br>    <span class="hljs-built_in">InitStack</span>(OPND);<br>    <span class="hljs-built_in">InitStack</span>(OPTR);<br>    <span class="hljs-built_in">Push</span>(OPTR,<span class="hljs-string">&#x27;#&#x27;</span>);<br>    <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (c!=<span class="hljs-string">&#x27;#&#x27;</span>||<span class="hljs-built_in">GetTop</span>(OPTR)!=<span class="hljs-string">&#x27;#&#x27;</span>) &#123; <span class="hljs-comment">// 退出条件：c==&#x27;#&#x27;&amp;&amp;GetTop(OPTR)==&#x27;#&#x27;</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNumber</span>(c)) &#123;<br>            <span class="hljs-built_in">Push</span>(OPND,c);<br>            c=<span class="hljs-built_in">getchar</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">Precede</span>(<span class="hljs-built_in">GetTop</span>(OPTR),c)) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>                <span class="hljs-built_in">Push</span>(OPTR,c);<br>                c=<span class="hljs-built_in">getchar</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;=&#x27;</span>:<br>            <span class="hljs-type">char</span> x;<br>                <span class="hljs-built_in">Pop</span>(OPTR,x);<br>                c=<span class="hljs-built_in">getchar</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>                <span class="hljs-type">char</span> theta,a,b;<br>                <span class="hljs-built_in">Pop</span>(OPTR,theta);<br>                <span class="hljs-built_in">Pop</span>(OPND,b);<br>                <span class="hljs-built_in">Pop</span>(OPND,a);<br>                <span class="hljs-built_in">Push</span>(OPND,<span class="hljs-built_in">Operate</span>(a,theta,b));<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 继续比较至后来算符&gt;或=栈顶算符</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">GetTop</span>(OPND);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>,<span class="hljs-built_in">EvaluateExpression</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h5><p>二元运算符表达式的另外三种表示方法：（以表达式 a * b + (c - d &#x2F; e) * f 为例）</p><ul><li><strong>前缀表达式</strong>：算符 操作数 1 操作数 2，原表达式转化为 +*ab*-c&#x2F;def</li><li><strong>中缀表达式</strong>：操作数 1 算符 操作数 2，原表达式转化为 a*b+c-d&#x2F;e*f</li><li><strong>后缀表达式</strong>：操作数 1 操作数 2 算符，原表达式转化为 ab*cde&#x2F;-f*+</li></ul><p>结论：</p><ol><li>操作数的相对次序相同</li><li>算符的相对次序不同</li><li>中缀表达式丢失括号信息，导致运算顺序不确定</li><li>前缀表达式运算规则为：连续出现的两个操作数和在它们之前且紧靠它们的算符构成一个最小表达式</li><li>后缀表达式运算规则为：每个算符和在它之前且紧靠它的两个操作数构成一个最小表达式</li></ol><p>所以，<strong>可以利用前缀表达式或后缀表达式实现表达式求值</strong>，以下为利用后缀表达式求值的思路：</p><ol><li><p><strong>将原表达式转化为后缀表达式</strong></p><p>后缀表达式的特点：原表达式中算符的运算顺序由它之后的一个算符决定，而后缀表达式中算符的运算顺序恰为其在表达式中的出现顺序，即优先级高的算符领先于优先级低的算符</p><p>算法描述：</p><ol><li>设置算符栈，栈底置“#”，表达式结束符也为“#”</li><li>读入表达式中的每个字符后判断并进行相关操作至栈空：<ul><li>若当前字符是操作数，则直接发送给后缀表达式</li><li>若当前字符是算符，则和栈顶算符比较优先关系后作相应操作：<ul><li>若当前算符 &gt; 栈顶算符，则当前算符入栈</li><li>若当前算符 &#x3D; 栈顶算符，即左右括号或结束符与栈底的“#”相遇的情况，则“(”或“#”出栈，“)”或“#”不入栈</li><li>若当前算符 &lt; 栈顶算符，则栈顶算符出栈发送给后缀表达式，继续比较直至“&gt;”或“&#x3D;”</li></ul></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Precede</span><span class="hljs-params">(<span class="hljs-type">char</span> stop,<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (stop) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;=&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<br>        <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;=&#x27;</span>;<br>&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Transform</span><span class="hljs-params">(<span class="hljs-type">char</span> suffix[],<span class="hljs-type">char</span> exp[])</span> </span>&#123;<br>    Stack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    <span class="hljs-built_in">Push</span>(S,<span class="hljs-string">&#x27;#&#x27;</span>);<br>    <br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span>* p=exp;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">StackEmpty</span>(S)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNumber</span>(*p)) &#123;<br>            suffix[i++]=*p;<br>            ++p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">Precede</span>(<span class="hljs-built_in">GetTop</span>(S),*p)) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>                <span class="hljs-built_in">Push</span>(S,*p);<br>                ++p;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;=&#x27;</span>:<br>                <span class="hljs-built_in">Pop</span>(S);<br>                ++p;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>                suffix[i++]=<span class="hljs-built_in">Pop</span>(S);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>后缀表达式求值</strong></p><p>算法描述：</p><ol><li>设置操作数栈</li><li>读入表达式中的每个字符后判断并进行相关操作至表达式读入完：<ul><li>若当前字符是操作数，则当前字符入栈</li><li>若当前字符是算符，则从栈中弹出两个数，运算结果入栈</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 为简化，仅支持0~9的简单算术表达式求值，每步四则运算结果都为0~9</span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Operate</span><span class="hljs-params">(<span class="hljs-type">char</span> a,<span class="hljs-type">char</span> theta,<span class="hljs-type">char</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (theta==<span class="hljs-string">&#x27;+&#x27;</span>)<br>        <span class="hljs-keyword">return</span> a+b-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta==<span class="hljs-string">&#x27;-&#x27;</span>)<br>        <span class="hljs-keyword">return</span> a-b+<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta==<span class="hljs-string">&#x27;*&#x27;</span>)<br>        <span class="hljs-built_in">return</span> (a-<span class="hljs-string">&#x27;0&#x27;</span>)*(b-<span class="hljs-string">&#x27;0&#x27;</span>)+<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta==<span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-built_in">return</span> (a-<span class="hljs-string">&#x27;0&#x27;</span>)/(b-<span class="hljs-string">&#x27;0&#x27;</span>)+<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">EvaluateExpression</span><span class="hljs-params">(<span class="hljs-type">char</span> suffix[])</span> </span>&#123;<br>    Stack S;<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    <br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i!=<span class="hljs-built_in">strlen</span>(suffix)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNumber</span>(suffix[i]))<br>            <span class="hljs-built_in">Push</span>(S,suffix[i++]);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span> a=<span class="hljs-built_in">Pop</span>(S),b=<span class="hljs-built_in">Pop</span>(S);<br>            <span class="hljs-built_in">Push</span>(S,<span class="hljs-built_in">Operate</span>(b,suffix[i++],a)); <span class="hljs-comment">// 注意：这里要考虑-和/的情况，后缀表达式中b在a前，所以应该是b-a或b/a</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetTop</span>(S);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="例五：实现递归"><a href="#例五：实现递归" class="headerlink" title="例五：实现递归"></a>例五：实现递归</h4><h5 id="铺垫：多个函数嵌套调用的规则"><a href="#铺垫：多个函数嵌套调用的规则" class="headerlink" title="铺垫：多个函数嵌套调用的规则"></a>铺垫：多个函数嵌套调用的规则</h5><p>当一个函数运行期间调用另一个函数时，在运行被调用函数前，需先完成以下任务：</p><ol><li>将所有实在参数、返回地址等信息传递给被调用函数<strong>保存</strong></li><li>为被调用函数<strong>分配</strong>一个存储区</li><li>将<strong>控制转移</strong>到被调用函数</li></ol><p>在从被调用函数返回调用函数前，需先完成以下任务：</p><ol><li><strong>保存</strong>被调用函数的计算结果</li><li><strong>释放</strong>被调用函数的存储区</li><li>按照被调用函数保存的返回地址将<strong>控制转移</strong>到调用函数</li></ol><p>调用函数与被调用函数间的信息传递和控制转移需要通过<strong>栈</strong>来实现：系统将整个程序运行期间所需要的数据空间安排在一个栈内；每当调用一个函数，就为它在栈顶分配一个存储区；每当从一个函数退出，就从栈顶释放它的存储区；所以当前运行的函数的存储区必在栈顶</p><h5 id="递归实现与栈实现"><a href="#递归实现与栈实现" class="headerlink" title="递归实现与栈实现"></a>递归实现与栈实现</h5><p>递归的过程就是函数不断调用自己，是调用函数与被调用函数为同一函数的函数嵌套调用：每当进入一层递归，就产生一个新的工作记录（包括上一层的实在参数、返回地址等）压入栈顶；每当从一层递归退出，就从栈顶弹出一个工作记录</p><p>以上都是对递归实现的说明，而<strong>栈实现本质上就是对系统运行递归程序过程的模拟</strong>，所有递归实现都可以转化为栈实现；因此，递归实现与栈实现的时间复杂度、空间复杂度相当（“非递归实现的复杂度都优于递归实现”是<strong>第一个误区</strong>，应该说递推实现的总体复杂度优于递归实现）</p><h5 id="递归的形式"><a href="#递归的形式" class="headerlink" title="递归的形式"></a>递归的形式</h5><p>递归的形式有尾递归、头递归、树递归、嵌套递归和间接递归等，大致可以分为线性递归和树形递归：</p><ul><li><p><strong>线性递归</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">func</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="..\img\ep3\image-20221230174944828.png" alt="image-20221230174944828" style="zoom:25%;" /><p>线性递归与递推的时间复杂度相当（“递归实现的时间复杂度都很高”是<strong>第二个误区</strong>）；而因为要利用栈存储，线性递归的空间复杂度远高于递推，数据过大会“爆栈”</p></li><li><p><strong>树形递归</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">func</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">func</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="..\img\ep3\image-20221230180100513.png" alt="image-20221230180100513" style="zoom:25%;" /><p>树形递归的时间复杂度是指数级别；树形递归的空间复杂度也远高于递推</p></li></ul><h5 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h5><p><strong>问题描述</strong>：有三个塔座 X, Y, Z，塔座 X 上插有 n 个大小各不相同且从上到下大小递增的圆盘，按从小到大编号为 1, 2, …, n；要求将塔座 X 上的 n 个圆盘移至塔座 Z 上，并仍按同样顺序叠排；移动圆盘时遵循以下规则：</p><ol><li>一次移动一个圆盘</li><li>圆盘可以插在 X, Y, Z 中的任一塔座上</li><li>任何时刻都不能将一个较大的圆盘压在较小的圆盘之上</li></ol><img src="..\img\ep3\image-20221231151850066.png" alt="image-20221231151850066" style="zoom:25%;" /><p><strong>递归实现</strong>：</p><ul><li>当 n &#x3D; 1 时，将一个圆盘从 X 移至 Z</li><li>当 n &gt; 1 时，将压在圆盘 n 上的 n-1 个圆盘从 X 移至 Y（递归），将圆盘 n 从 X 移至 Z，再将 Y 上的 n-1 个圆盘从 Y 移至 Z（递归）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 借助塔座y，将塔座x最上面的n个圆盘移至塔座z</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">char</span> x,<span class="hljs-type">char</span> y,<span class="hljs-type">char</span> z)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">Move</span>(x,<span class="hljs-number">1</span>,z); <span class="hljs-comment">// 将x上编号为1的圆盘移至z</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">Hanoi</span>(n<span class="hljs-number">-1</span>,x,z,y);<br>        <span class="hljs-built_in">Move</span>(x,n,z); <span class="hljs-comment">// 将x上编号为n的圆盘移至z</span><br>        <span class="hljs-built_in">Hanoi</span>(n<span class="hljs-number">-1</span>,y,x,z);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递归过程栈的情况</strong>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    <span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-constructor">Hanoi(3,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;)</span>;<br>(<span class="hljs-number">0</span>)     return <span class="hljs-number">0</span>;<br>    &#125;<br>    void <span class="hljs-constructor">Hanoi(<span class="hljs-params">int</span> <span class="hljs-params">n</span>,<span class="hljs-params">char</span> <span class="hljs-params">x</span>,<span class="hljs-params">char</span> <span class="hljs-params">y</span>,<span class="hljs-params">char</span> <span class="hljs-params">z</span>)</span> &#123;<br>(<span class="hljs-number">1</span>)     <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>)         <span class="hljs-constructor">Move(<span class="hljs-params">x</span>,1,<span class="hljs-params">z</span>)</span>;<br>(<span class="hljs-number">3</span>)     <span class="hljs-keyword">else</span> &#123;<br>(<span class="hljs-number">4</span>)         <span class="hljs-constructor">Hanoi(<span class="hljs-params">n</span>-1,<span class="hljs-params">x</span>,<span class="hljs-params">z</span>,<span class="hljs-params">y</span>)</span>;<br>(<span class="hljs-number">5</span>)         <span class="hljs-constructor">Move(<span class="hljs-params">x</span>,<span class="hljs-params">n</span>,<span class="hljs-params">z</span>)</span>;<br>(<span class="hljs-number">6</span>)         <span class="hljs-constructor">Hanoi(<span class="hljs-params">n</span>-1,<span class="hljs-params">y</span>,<span class="hljs-params">x</span>,<span class="hljs-params">z</span>)</span>;<br>(<span class="hljs-number">7</span>)     &#125;<br>(<span class="hljs-number">8</span>) &#125;<br></code></pre></td></tr></table></figure><p>返回地址用 (0) 至 (8) 标记，每个工作记录含实在参数和返回地址，则递归过程栈的情况如下：</p><img src="..\img\ep3\image-20221231165641784.png" alt="image-20221231165641784" style="zoom:25%;" /><h5 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h5><p><strong>问题描述</strong>：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问一共有多少种摆法；输出整个 8×8 棋盘，“Q”表示该位置放皇后，“.”表示该位置不放皇后（以下为拓展的 n 皇后问题的代码）</p><p><strong>递归实现</strong>：</p><p>“回溯”的思想：</p><img src="..\img\ep3\image-20221231194329564.png" alt="image-20221231194329564" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">25</span>;<br><br><span class="hljs-type">int</span> n=<span class="hljs-number">8</span>; <span class="hljs-comment">// 皇后数</span><br><span class="hljs-type">char</span> b[N][N]; <span class="hljs-comment">// 棋盘</span><br><span class="hljs-type">bool</span> row[N],col[N],dg[N],udg[N]; <span class="hljs-comment">// 行、列、主对角线和反对角线标记</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queenProblem</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> s)</span> </span>&#123; <span class="hljs-comment">// x表示行，y表示列，s表示已放皇后数</span><br><span class="hljs-keyword">if</span> (y==n) &#123;<br>x++;<br>y=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (x==n) &#123;<br><span class="hljs-keyword">if</span> (s==n) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>cout &lt;&lt; b[i][j];<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span>; <span class="hljs-comment">// 回溯</span><br>&#125;<br><span class="hljs-comment">// 不放</span><br><span class="hljs-built_in">queenProblem</span>(x,y+<span class="hljs-number">1</span>,s);<br><span class="hljs-comment">// 放</span><br><span class="hljs-keyword">if</span> (!row[x]&amp;&amp;!col[y]&amp;&amp;!dg[x-y+n<span class="hljs-number">-1</span>]&amp;&amp;!udg[x+y]) &#123;<br>b[x][y]=<span class="hljs-string">&#x27;Q&#x27;</span>;<br>row[x]=col[y]=dg[x-y+n<span class="hljs-number">-1</span>]=udg[x+y]=<span class="hljs-literal">true</span>;<br><span class="hljs-built_in">queenProblem</span>(x+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,s+<span class="hljs-number">1</span>);<br>b[x][y]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>row[x]=col[y]=dg[x-y+n<span class="hljs-number">-1</span>]=udg[x+y]=<span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>b[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br><span class="hljs-built_in">queenProblem</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>栈实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">25</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> t;<br>&#125; Stack;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(Stack &amp;stack)</span> </span>&#123;<br>stack.t=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(Stack stack)</span> </span>&#123;<br><span class="hljs-keyword">return</span> stack.t+<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(Stack &amp;stack,<span class="hljs-type">int</span> e)</span> </span>&#123;<br>stack.s[++stack.t]=e;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(Stack &amp;stack)</span> </span>&#123;<br><span class="hljs-type">int</span> e=stack.s[stack.t--];<br><span class="hljs-keyword">return</span> e;<br>&#125;<br><br><span class="hljs-type">int</span> n=<span class="hljs-number">8</span>; <span class="hljs-comment">// 皇后数</span><br><span class="hljs-type">bool</span> row[N],dg[N],udg[N]; <span class="hljs-comment">// 行、主对角线和反对角线标记</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queenProblem</span><span class="hljs-params">()</span> </span>&#123;<br>Stack s;<br><span class="hljs-built_in">InitStack</span>(s);<br><br><span class="hljs-type">int</span> pos=<span class="hljs-number">-1</span>; <span class="hljs-comment">// 此时pos相当于一个flag</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">StackLength</span>(s)==n) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br><span class="hljs-keyword">if</span> (i==s.s[j])<br>cout &lt;&lt; <span class="hljs-string">&quot;Q&quot;</span>;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>pos=<span class="hljs-built_in">Pop</span>(s);<br>row[pos]=<span class="hljs-literal">false</span>;<br>dg[pos-<span class="hljs-built_in">StackLength</span>(s)+n<span class="hljs-number">-1</span>]=<span class="hljs-literal">false</span>;<br>udg[pos+<span class="hljs-built_in">StackLength</span>(s)]=<span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-type">int</span> i=(pos==<span class="hljs-number">-1</span>?<span class="hljs-number">0</span>:pos+<span class="hljs-number">1</span>); <span class="hljs-comment">// i=pos会死循环</span><br><span class="hljs-keyword">for</span> (;i&lt;n;i++)<br><span class="hljs-keyword">if</span> (!row[i]&amp;&amp;!dg[i-<span class="hljs-built_in">StackLength</span>(s)+n<span class="hljs-number">-1</span>]&amp;&amp;!udg[i+<span class="hljs-built_in">StackLength</span>(s)]) &#123;<br><span class="hljs-built_in">Push</span>(s,i);<br>row[i]=<span class="hljs-literal">true</span>;<br>dg[i-(<span class="hljs-built_in">StackLength</span>(s)<span class="hljs-number">-1</span>)+n<span class="hljs-number">-1</span>]=<span class="hljs-literal">true</span>;<br>udg[i+<span class="hljs-built_in">StackLength</span>(s)<span class="hljs-number">-1</span>]=<span class="hljs-literal">true</span>;<br>pos=<span class="hljs-number">-1</span>; <span class="hljs-comment">// 此时pos相当于一个flag</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (i==n) &#123;<br>pos=<span class="hljs-built_in">Pop</span>(s);<br>row[pos]=<span class="hljs-literal">false</span>;<br>dg[pos-<span class="hljs-built_in">StackLength</span>(s)+n<span class="hljs-number">-1</span>]=<span class="hljs-literal">false</span>;<br>udg[pos+<span class="hljs-built_in">StackLength</span>(s)]=<span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (pos==n<span class="hljs-number">-1</span>&amp;&amp;<span class="hljs-built_in">StackLength</span>(s)==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;Q&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">queenProblem</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-队列的定义与实现（先进先出）"><a href="#3-队列的定义与实现（先进先出）" class="headerlink" title="3 - 队列的定义与实现（先进先出）"></a>3 - 队列的定义与实现（先进先出）</h3><h4 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>队列（Queue）</strong>是限定仅在表的一端插入元素，在另一端删除元素的线性表。允许插入的一端称为<strong>队尾（Rear）</strong>，允许删除的一端称为<strong>队头（Front）</strong>。当队列中没有元素时，称为<strong>空队列</strong>。</p><h4 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ADT Queue &#123;<br>数据对象：<br>D=&#123;a_i<span class="hljs-pattern-match">|a<span class="hljs-constructor">_i</span>∈<span class="hljs-constructor">ElemSet</span>,i=1,2,<span class="hljs-operator">...</span>,n&#125;</span><br><span class="hljs-pattern-match">数据关系：</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">R</span>=&#123;&lt;a<span class="hljs-constructor">_i</span>-1,a<span class="hljs-constructor">_i</span>&gt;|a<span class="hljs-constructor">_i</span>-1,a<span class="hljs-constructor">_i</span>∈<span class="hljs-constructor">D</span>,i=2,<span class="hljs-operator">...</span>,n&#125;</span><br><span class="hljs-pattern-match">(约定a<span class="hljs-constructor">_1</span>为队列头，a<span class="hljs-constructor">_n</span>为队列尾)</span><br><span class="hljs-pattern-match">基本操作：</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">InitQueue(&amp;Q)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">DestroyQueue(&amp;Q)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">QueueLength(Q)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">QueueEmpty(Q)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">GetHead(Q,&amp;<span class="hljs-params">e</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 需判空</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">ClearQueue(&amp;Q)</span></span><br><span class="hljs-pattern-match"><span class="hljs-constructor">EnQueue(&amp;Q,<span class="hljs-params">e</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 需判满</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">DeQueue(&amp;Q,&amp;<span class="hljs-params">e</span>)</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 需判空</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">QueueTravers(Q,<span class="hljs-params">visit</span>()</span>)</span><br><span class="hljs-pattern-match">&#125; <span class="hljs-constructor">ADT</span> <span class="hljs-constructor">Queue</span></span><br></code></pre></td></tr></table></figure><h4 id="用顺序存储结构实现队列"><a href="#用顺序存储结构实现队列" class="headerlink" title="用顺序存储结构实现队列"></a>用顺序存储结构实现队列</h4><h5 id="第一种实现：定长数组-1"><a href="#第一种实现：定长数组-1" class="headerlink" title="第一种实现：定长数组"></a>第一种实现：定长数组</h5><p><strong>规定</strong>：队头指针 Front 指向队头元素在队列中的当前位置，队尾指针 Rear 指向队尾元素的下一个位置</p><p><strong>判空</strong>：Q.Front&#x3D;&#x3D;Q.Rear</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ----------Sqqueue.h----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SQQUEUE_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQQUEUE_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T   Queue[MAXSIZE]; <span class="hljs-comment">// 静态分配，相应的动态分配方式为：T* Queue;</span><br>    <span class="hljs-type">int</span> Front,Rear;<br>&#125; SqQueue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue Q,T &amp;e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,T e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,T &amp;e)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ----------Sqqueue.cpp----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Sqqueue.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span> </span>&#123;<br>    Q.Front=Q.Rear=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Q.Rear-Q.Front;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueEmpty</span><span class="hljs-params">(SqQueue Q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Q.Front==Q.Rear?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue Q,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.Front==Q.Rear) <span class="hljs-comment">// 判空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    e=Q.Queue[Q.Front];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span> </span>&#123;<br>    Q.Front=Q.Rear=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,T e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.Rear==MAXSIZE) <span class="hljs-comment">// 判满</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    Q.Queue[Q.Rear++]=e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.Front==Q.Rear) <span class="hljs-comment">// 判空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>e=Q.Queue[Q.Front++];<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="第二种实现：循环队列"><a href="#第二种实现：循环队列" class="headerlink" title="第二种实现：循环队列"></a>第二种实现：循环队列</h5><p><strong>问题1</strong>：Rear&#x3D;&#x3D;MAXSIZE 不一定说明队列中有 MAXSIZE 个元素，称“假溢出”。解决“假溢出”的办法一般有两种：</p><ol><li>将整个队列左移，使队列的第一个元素重新位于 Queue[0]（效率低）；</li><li>设想 Queue[0] 接在 Queue[MAXSIZE-1] 之后，使一维数组 Queue 成为一个首尾相接的环。</li></ol><p><strong>问题2</strong>：直接处理成循环队列，队满和队空的条件都为：Q.Front&#x3D;&#x3D;Q.Rear。在循环队列中如何判定队满和队空？两种方法：</p><ol><li>设置一个标志 flag，以区别队列是满还是空。flag 初始化为“delete”；每一次插入操作后，被置为“entry”；每一次删除操作后，被置为“delete”。当出现 Front&#x3D;&#x3D;Rear 时，如果flag此时为“entry”，则可判断队列是满的，否则队列是空的（效率相对较低）；</li><li>少用一个数据元素空间，以队尾指针加 1 等于队头指针来表示队列满。</li></ol><p><strong>判满</strong>：(Q.Rear+1)%MAXSIZE&#x3D;&#x3D;Q.Front</p><p><strong>判空</strong>：Q.Front&#x3D;&#x3D;Q.Rear</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一般队列的入队算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,T e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.Rear==MAXSIZE) <span class="hljs-comment">// 判满</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    Q.Queue[Q.Rear++]=e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 循环队列的入队算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">EnCycque</span><span class="hljs-params">(SqQueue &amp;Q,T e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((Q.Rear+<span class="hljs-number">1</span>)%MAXSIZE==Q.Front) <span class="hljs-comment">// 判满</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    Q.Queue[Q.Rear]=e;<br>    Q.Rear=(Q.Rear+<span class="hljs-number">1</span>)%MAXSIZE;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 一般队列出队算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.Front==Q.Rear) <span class="hljs-comment">// 判空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>e=Q.Queue[Q.Front++];<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 循环队列出队算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DeCycque</span><span class="hljs-params">(SqQueue &amp;Q,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.Front==Q.Rear) <span class="hljs-comment">// 判空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    e=Q.Queue[Q.Front];<br>    Q.Front=(Q.Front+<span class="hljs-number">1</span>)%MAXSIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用链式存储结构实现队列"><a href="#用链式存储结构实现队列" class="headerlink" title="用链式存储结构实现队列"></a>用链式存储结构实现队列</h4><p>一个链队列需要两个分别指示队头和队尾的指针；为了操作方便，给链队列添加一个头结点，头指针指向头结点；所以，队列空的判定条件为头指针与尾指针均指向头结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T;<br><br><span class="hljs-comment">// 结点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Qnode</span> &#123;<br>    T Data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Qnode</span>* Next;<br>&#125; Qnode;<br><br><span class="hljs-comment">// 链队列结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Qnode* Front;<br>    Qnode* Rear;<br>&#125; LinkQueue;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 链队列初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span> </span>&#123;<br>    Q.Front=(Qnode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Qnode));<br>    <span class="hljs-keyword">if</span> (!Q.Front)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    Q.Rear=Q.Front;<br>    Q.Front-&gt;Next=<span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 链队列销毁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (Q.Front) &#123;<br>        Q.Rear=Q.Front-&gt;Next;<br>        <span class="hljs-built_in">free</span>(Q.Front);<br>        Q.Front=Q.Rear;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 链队列入队</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,T e)</span> </span>&#123;<br>    Qnode* p=(Qnode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Qnode));<br>    <span class="hljs-keyword">if</span> (!p)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 内存无可用空间</span><br>    p-&gt;Data=e;<br>    p-&gt;Next=<span class="hljs-literal">NULL</span>;<br>    Q.Rear-&gt;Next=p;<br>    Q.Rear=p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 链队列出队（当链队列长度大于1时，只需修改头结点的Next域，尾指针不用变化；当链队列长度等于1时，除修改头结点的Next域外，还要修改尾指针）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.Front==Q.Rear)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 判空</span><br>    Qnode* p=Q.Front-&gt;Next;<br>    Q.Front-&gt;Next=p-&gt;Next;<br>    e=p-&gt;Data;<br>    <span class="hljs-keyword">if</span> (Q.Rear==p)<br>        Q.Rear=Q.Front;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序队列还是链队列？"><a href="#顺序队列还是链队列？" class="headerlink" title="顺序队列还是链队列？"></a>顺序队列还是链队列？</h4><p>队列广泛应用于程序设计中，是现实世界排队的仿真。当要解决的问题具有先进先出的特点时就可以用队列。</p><p>顺序队列、链队列的基本操作的时间复杂度都是 O(1)。当需要访问中间结点时，顺序队列更宜；对于在使用中数据元素变动较大的情况，用链式存储结构比用顺序存储结构更有利。</p><h3 id="4-队列的应用举例"><a href="#4-队列的应用举例" class="headerlink" title="4 - 队列的应用举例"></a>4 - 队列的应用举例</h3><h4 id="例一：k-阶斐波那契数列"><a href="#例一：k-阶斐波那契数列" class="headerlink" title="例一：k 阶斐波那契数列"></a>例一：k 阶斐波那契数列</h4><h5 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h5><p><strong>k 阶斐波那契数列</strong>：约定 $$f_0$$ &#x3D; 0, $$f_1$$ &#x3D; 0, …, $$f_{k-2}$$ &#x3D; 0, $$f_{k-1}$$ &#x3D; 1，则 $$f_n$$ &#x3D; $$f_{n-1}$$ + $$f_{n-2}$$ + … + $$f_{n-k}$$ (n &#x3D; k, k+1, …)</p><p><strong>问题描述</strong>：编写求 k 阶斐波那契数列前 n + 1 项（$$f_0$$, $$f_1$$, …, $$f_n$$）的算法，要求满足 $$f_n$$ ≤ max 且 $$f_{n+1}$$ &gt; max（max ≥ 0，为某个约定的常数）</p><h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 第一种实现（循环队列容量为k）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fb</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> max,<span class="hljs-type">int</span> f[])</span> </span>&#123; <span class="hljs-comment">// 返回数列最后一项下标n</span><br>    SqQueue cq;<br>    <span class="hljs-built_in">InitQueue</span>(cq);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=k<span class="hljs-number">-2</span>;i++) &#123;<br>        f[i]=<span class="hljs-number">0</span>;<br>        cq.Queue[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    f[k<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br>    cq.Queue[k<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br>    cq.Rear=k<span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-type">int</span> n=k;<br>    <span class="hljs-keyword">while</span> (cq.Queue[cq.Rear]&lt;max) &#123;<br>        f[n]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=k<span class="hljs-number">-1</span>;j++)<br>            f[n]+=cq.Queue[j];<br>        cq.Rear=(cq.Rear+<span class="hljs-number">1</span>)%k; <span class="hljs-comment">// 因为容量恰好为k，所以将队列中所有数相加即可，cq.Front没有意义</span><br>        cq.Queue[cq.Rear]=f[n++];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cq.Queue[cq.Rear]&gt;max)<br>        n-=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span><br>        n-=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (max==<span class="hljs-number">1</span>) &#123;<br>        n=k;<br>        f[k]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * f_i=f_&#123;i-1&#125;+f_&#123;i-2&#125;+...+f_&#123;i-k&#125;</span><br><span class="hljs-comment"> * f_&#123;i+1&#125;=f_i+f_&#123;i-1&#125;+...+f_&#123;i-k+1&#125;</span><br><span class="hljs-comment"> * 两式相减得：f_&#123;i+1&#125;=2f_i-f_&#123;i-k&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 第二种实现（利用f_&#123;i+1&#125;=2f_i-f_&#123;i-k&#125;，循环队列容量为k+1）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fb</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> max,<span class="hljs-type">int</span> f[])</span> </span>&#123; <span class="hljs-comment">// 接口不变</span><br>    SqQueue cq;<br>    <span class="hljs-built_in">InitQueue</span>(cq);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=k<span class="hljs-number">-2</span>;i++) &#123;<br>        f[i]=<span class="hljs-number">0</span>;<br>        cq.Queue[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    f[k]=f[k<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br>    cq.Queue[k]=cq.Queue[k<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br>    cq.Rear=k;<br>    <br>    <span class="hljs-type">int</span> n=k+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (cq.Queue[cq.Rear]&lt;max) &#123;<br>        <span class="hljs-type">int</span> j=(cq.Rear+<span class="hljs-number">1</span>)%(k+<span class="hljs-number">1</span>);<br>        f[n]=cq.Queue[cq.Rear]*<span class="hljs-number">2</span>-cq.Queue[j];<br>        cq.Rear=j;<br>        cq.Queue[cq.Rear]=f[n++];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cq.Queue[cq.Rear]&gt;max)<br>        n-=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span><br>        n-=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (max==<span class="hljs-number">0</span>)<br>        n=k<span class="hljs-number">-2</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例二：划分子集"><a href="#例二：划分子集" class="headerlink" title="例二：划分子集"></a>例二：划分子集</h4><h5 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h5><p>已知集合 A &#x3D; {a1, a2, …, an} 及集合上的关系 R &#x3D; {(ai, aj)|ai, aj∈A, i≠j}，其中 (ai, aj) 表示 ai 与 aj 间存在冲突关系；要求将 A 划分成互不相交的子集 A1, A2, …, Ak (k≤n)，使任何子集中的元素均无冲突关系，同时要求子集个数尽可能少</p><h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><p>算法描述：（将 a1<del>an 映射到 1</del>n）</p><ol><li><p>设置以下数据结构：</p><ul><li>冲突关系矩阵 cf<ul><li>cf[i][j] &#x3D; 1 表示 ai, aj 有冲突</li><li>cf[i][j] &#x3D; 0 表示 ai, aj 无冲突</li></ul></li><li>循环队列 cq</li><li>数组 result</li><li>数组 newr</li></ul></li><li><p>初始化：</p><ul><li>遍历集合 R，初始化 cf，注意 (ai, aj) 表示 cf[i][j] &#x3D; 1 且 cf[j][i] &#x3D; 1（预处理）</li><li>cq 元素从队头到队尾初始化为 1~n</li><li>result 和 newr 元素初始化为 0</li><li>组号 group 初始化为 1</li></ul></li><li><p>cq 第一个元素 1 出队，并将 cf 中第一行的 1 拷入 newr 中对应位置（凡与 cq 第一个元素 1 有冲突的元素在 newr 中对应位置处均为 1）；下一个元素出队：</p><ul><li>若其在 newr 中对应位置处为 1，即有冲突，则重新入队参加下一次分组</li><li>若其在 newr 中对应位置处为 0，即无冲突，则可划归该组，并将 cf 中该元素对应行的 1 拷入 newr 中对应位置</li></ul><p>如此循环操作，直至 cq 所有元素依次出队，由 newr 中为 0 的单元对应的元素构成第 1 组，将 group 值 1 写入 result 中值为 0 的对应单元中</p></li><li><p>group 自增，newr 清零，对 cq 中元素重复上述操作，直至队空</p></li></ol><h5 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SubsetPartition</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> cf[][N],<span class="hljs-type">int</span> result[])</span> </span>&#123;<br>SqQueue cq;<br><span class="hljs-type">int</span> newr[N],group=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<br>cq.Queue[i]=i;<br>result[i]=<span class="hljs-number">0</span>;<br>newr[i]=<span class="hljs-number">0</span>;<br>&#125;<br>cq.Front=<span class="hljs-number">1</span>;<br>cq.Rear=(n+<span class="hljs-number">1</span>)%N;<br><br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">QueueEmpty</span>(cq)) &#123;<br><span class="hljs-type">int</span> len=<span class="hljs-built_in">QueueLength</span>(cq); <span class="hljs-comment">// (cq.Rear+N-cq.Front)%N</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;<br><span class="hljs-type">int</span> t=<span class="hljs-built_in">DeCycque</span>(cq);<br><span class="hljs-keyword">if</span> (newr[t])<br><span class="hljs-built_in">EnCycque</span>(cq,t);<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br><span class="hljs-keyword">if</span> (cf[t][j])<br>newr[j]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br><span class="hljs-keyword">if</span> (!newr[i]&amp;&amp;!result[i]) <span class="hljs-comment">// 将group值写入result中值为0的对应单元中</span><br>result[i]=group;<br>++group;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>newr[i]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-其他运算受限的线性表"><a href="#5-其他运算受限的线性表" class="headerlink" title="5 - 其他运算受限的线性表"></a>5 - 其他运算受限的线性表</h3><ol><li><p>双端队列：允许在队列两端自由地插入和删除</p><img src="..\img\ep3\image-20230104175516366.png" alt="image-20230104175516366" style="zoom:25%;" /></li><li><p>双栈：允许在两端插入和删除，但在哪端插入就在哪端删除（两个底部相连的栈）</p><img src="..\img\ep3\image-20230104175538054.png" alt="image-20230104175538054" style="zoom:25%;" /></li><li><p>超队列：允许在队列两端插入、一端删除</p><img src="..\img\ep3\image-20230104175554562.png" alt="image-20230104175554562" style="zoom:25%;" /></li><li><p>超栈：允许在队列一端插入、两端删除（对栈溢出的一种特殊处理，即当栈溢出时，可将栈中保存最久的元素删除）</p><img src="..\img\ep3\image-20230104175620938.png" alt="image-20230104175620938" style="zoom:25%;" /></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2023/03/02/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2023/03/02/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>数据结构课程笔记 ep2</p><span id="more"></span><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="1-线性表的基本概念"><a href="#1-线性表的基本概念" class="headerlink" title="1 - 线性表的基本概念"></a>1 - 线性表的基本概念</h3><h4 id="线性表的逻辑结构"><a href="#线性表的逻辑结构" class="headerlink" title="线性表的逻辑结构"></a>线性表的逻辑结构</h4><ol><li><strong>线性表（List）</strong>是 n 个<strong>数据元素</strong> a1, a2, …, an 的有限序列（数据元素可以是很复杂的信息）</li><li>序偶关系、前驱、后继、表长、空表、位序</li></ol><h4 id="抽象数据类型线性表的定义"><a href="#抽象数据类型线性表的定义" class="headerlink" title="抽象数据类型线性表的定义"></a>抽象数据类型线性表的定义</h4><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ADT List &#123;<br>数据对象：<br>D=&#123;<span class="hljs-built_in">a_i</span>|<span class="hljs-built_in">a_i</span>∈ElemSet,i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...,n&#125;<br>数据关系：<br>R=&#123;&lt;<span class="hljs-built_in">a_i</span>-<span class="hljs-number">1</span>,<span class="hljs-built_in">a_i</span>&gt;|<span class="hljs-built_in">a_i</span>-<span class="hljs-number">1</span>,<span class="hljs-built_in">a_i</span>∈D,i=<span class="hljs-number">2</span>,...,n&#125;<br>基本操作：<br>初始化操作<br>销毁操作<br>引用型操作<br>加工型操作<br>&#125; ADT List<br></code></pre></td></tr></table></figure><p><strong>初始化操作：</strong><br><code>InitList(&amp;L)</code><br>结果：构造空表 L</p><p><strong>销毁操作：</strong><br><code>DestroyList(&amp;L)</code><br>结果：销毁表 L</p><p><strong>引用型操作：</strong><br>判空：<code>ListEmpty(L)</code><br>结果：空表返回 TRUE，否则返回 FALSE</p><p>求表长：<code>ListLength(L)</code><br>结果：返回表长</p><p>求前驱：<code>PriorElem(L, cur_e, &amp;pre_e)</code><br>结果：若 cur_e 是 L 的数据元素且不是第一个，则用 pre_e 返回它的前驱；否则操作失败，pre_e 无定义</p><p>求后继：<code>NextElem(L, cur_e, &amp;next_e)</code><br>结果：若 cur_e 是 L 的数据元素且不是最后一个，则用 next_e 返回它的后继；否则操作失败，next_e 无定义</p><p>根据位序求元素：<code>GetElem(L, i, &amp;e)</code><br>结果：若 1 ≤ i ≤ ListLength(L)，则用 e 返回第 i 个元素的值</p><p>根据元素求位序：<code>LocateElem(L, e, compare())</code><br>结果：返回 L 中第 1 个与 e 满足关系 compare() 的数据元素的位序；若这样的数据元素不存在，则返回值为0</p><p><strong>加工型操作：</strong><br>置空：<code>ClearList(&amp;L)</code><br>结果：置空</p><p>改变数据元素：<code>PutElem(&amp;L, i, e)</code><br>结果：若 1 ≤ i ≤ ListLength(L)，则 L 中第 i 个元素赋值 e</p><p>插入数据元素：<code>InsertElem(&amp;L, i, e)</code><br>结果：若 1 ≤ i ≤ ListLength(L)+1，则 L 中第 i 个元素<strong>之前</strong>插入 e；<strong>L 的长度增 1</strong></p><p>删除数据元素：<code>DeleteElem(&amp;L, i, &amp;e)</code><br>结果：若 1 ≤ i ≤ ListLength(L)，则删除 L 中第 i 个元素，并用 e 返回其值；<strong>L 的长度减 1</strong></p><h3 id="2-线性表的顺序表示和实现（顺序表）"><a href="#2-线性表的顺序表示和实现（顺序表）" class="headerlink" title="2 - 线性表的顺序表示和实现（顺序表）"></a>2 - 线性表的顺序表示和实现（顺序表）</h3><p>表中相邻的两个元素其物理存储位置也相邻，即以元素在计算机内物理位置上的相邻来表示线性表中数据元素之间相邻的逻辑关系 → 下标索引，无需遍历</p><p>函数返回值表征操作是否成功，非必要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ----------Sqlist.h----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SQLIST_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQLIST_H_</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T; <span class="hljs-comment">// 数据元素类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    T*  elem;     <span class="hljs-comment">// 存储空间基址</span><br>    <span class="hljs-type">int</span> length;   <span class="hljs-comment">// 当前长度</span><br>    <span class="hljs-type">int</span> listsize; <span class="hljs-comment">// 当前分配的存储容量</span><br>&#125; SqList;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 创建顺序表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">SqList <span class="hljs-title">CreateList_Sq</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化顺序表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InitList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 顺序表扩容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ExtendList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 增（L中第i个元素之前插入e）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InsertElem_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,T e)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 删（根据下标删除，并将已删除元素值转给e）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DeleteElem_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,T &amp;e)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 查（查元素直接下标索引，这里是查位序）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem_Sq</span><span class="hljs-params">(SqList L,T e)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 销毁顺序表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ----------Sqlist.cpp----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Sqlist.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 80 <span class="hljs-comment">// 顺序表存储空间的初始分配量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INCREMENT 10 <span class="hljs-comment">// 顺序表存储空间的分配增量</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 创建顺序表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">SqList <span class="hljs-title">CreateList_Sq</span><span class="hljs-params">()</span> </span>&#123;<br>    SqList* list=(SqList*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SqList));<br>    <span class="hljs-keyword">return</span> *list;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化顺序表</span><br><span class="hljs-comment"> * 返回1 表示初始化成功</span><br><span class="hljs-comment"> * 返回0 表示初始化失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InitList_Sq</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123; <span class="hljs-comment">// 只有在C++中才会有引用的存在</span><br>    L.elem=(T*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T)*LIST_INIT_SIZE);<br>    <span class="hljs-keyword">if</span> (!L.elem)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 内存不够，分配失败</span><br>    L.length=<span class="hljs-number">0</span>;<br>    L.listsize=LIST_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 顺序表扩容</span><br><span class="hljs-comment"> * 返回1 表示扩容成功</span><br><span class="hljs-comment"> * 返回0 表示扩容失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ExtendList_Sq</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    T* newbase=(T*)<span class="hljs-built_in">realloc</span>(L.elem,<span class="hljs-built_in">sizeof</span>(T)*(L.listsize+LIST_INCREMENT));<br>    <span class="hljs-keyword">if</span> (!newbase)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    L.elem=newbase;<br>    L.listsize+=LIST_INCREMENT;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 增（L中第i个元素之前插入e）</span><br><span class="hljs-comment"> * 返回1 表示插入成功</span><br><span class="hljs-comment"> * 返回0 表示插入失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InsertElem_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,T e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>) <span class="hljs-comment">// robust</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (L.length&gt;=L.listsize) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ExtendList_Sq</span>(L))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=L.length+<span class="hljs-number">1</span>;p&gt;i;p--)<br>        L.elem[p]=L.elem[p<span class="hljs-number">-1</span>];<br>    L.elem[i]=e;<br>    L.length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 删（根据下标删除，并将已删除元素值转给e）</span><br><span class="hljs-comment"> * 返回1 表示删除成功</span><br><span class="hljs-comment"> * 返回0 表示删除失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DeleteElem_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,T &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span>||i&gt;L.length) <span class="hljs-comment">// robust</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    e=L.elem[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=i;p&lt;L.length;p++) &#123;<br>        L.elem[p]=L.elem[p+<span class="hljs-number">1</span>];<br>    &#125;<br>    L.length--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 查（查元素直接下标索引，这里是查位序）</span><br><span class="hljs-comment"> * 若存在，则返回它的位序，否则返回0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem_Sq</span><span class="hljs-params">(SqList L,T e)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;=L.length;i++) &#123;<br>        <span class="hljs-keyword">if</span> (...) <span class="hljs-comment">// 满足条件</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i==L.length+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 销毁顺序表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList_Sq</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(L.elem);<br><span class="hljs-built_in">free</span>(L);<br>&#125;<br></code></pre></td></tr></table></figure><p>*realloc：</p><ol><li>如果当前连续内存块足够 realloc 的话，只是将 p 所指向的空间扩大，并返回 p 的指针地址，这个时候 q 和 p 指向的地址是一样的</li><li>如果当前连续内存块不够长度，再找一个足够长的地方，分配一块新的内存，并将 p 指向的内容复制到 q，返回 q，并将 p 所指向的内存空间删除</li></ol><h4 id="顺序表的优缺点"><a href="#顺序表的优缺点" class="headerlink" title="顺序表的优缺点"></a>顺序表的优缺点</h4><ol><li><strong>存储密度高</strong>（无需为表示数据元素之间的关系而增加额外存储空间）</li><li><strong>下标索引</strong></li><li>插入和删除运算时，必须<strong>移动大量元素</strong>，效率较低</li><li><strong>必须预先为线性表分配连续空间</strong>（难以准确估计线性表最大长度，估计过小导致溢出，估计过大又会造成存储空间浪费）</li></ol><h3 id="3-线性表的链式表示和实现（链表）"><a href="#3-线性表的链式表示和实现（链表）" class="headerlink" title="3 - 线性表的链式表示和实现（链表）"></a>3 - 线性表的链式表示和实现（链表）</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>为了表示每个元素 a_i 与其后继 a_i+1 之间的逻辑关系，一个结点包括两部分：数据域 data 存放数据元素 a_i，指针域 next 存放指向后继元素 a_i+1 所在结点的一个指针</p><p>单链表可由<strong>头指针</strong>唯一确定（一般有头结点，头结点数据域可存放 length）</p><p>注意画图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ----------Linklist.h----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LINKLIST_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LINKLIST_H_</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T; <span class="hljs-comment">// 数据元素类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> &#123;<br>T data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>* next;<br>&#125; LNode,*LinkList;<br><br><span class="hljs-keyword">extern</span> LinkList head;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InitList_L</span><span class="hljs-params">(LinkList &amp;head)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InsertElem_L</span><span class="hljs-params">(LinkList &amp;head,<span class="hljs-type">int</span> i,T e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DeleteElem_L</span><span class="hljs-params">(LinkList &amp;head,<span class="hljs-type">int</span> i,T &amp;e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList_L</span><span class="hljs-params">(LinkList &amp;head)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem_L</span><span class="hljs-params">(LinkList &amp;head,<span class="hljs-type">int</span> i,T &amp;e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem_L</span><span class="hljs-params">(LinkList head,T e)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_H</span><span class="hljs-params">(LinkList &amp;head,<span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_E</span><span class="hljs-params">(LinkList &amp;head,<span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList_L</span><span class="hljs-params">(LinkList &amp;head)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ----------Linklist.cpp----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Linklist.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 创建链表</span><br><span class="hljs-comment"> */</span><br>LinkList head=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 含头结点</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化链表</span><br><span class="hljs-comment"> * 返回1 表示初始化成功</span><br><span class="hljs-comment"> * 返回0 表示初始化失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitList_L</span><span class="hljs-params">(LinkList &amp;head)</span> &#123;<br>    LinkList tmp=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    <span class="hljs-keyword">if</span> (!tmp)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    tmp-&gt;next=<span class="hljs-literal">NULL</span>;<br>    head=tmp;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 增（L中第i个元素之前插入e）</span><br><span class="hljs-comment"> * 返回1 表示插入成功</span><br><span class="hljs-comment"> * 返回0 表示插入失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InsertElem_L</span><span class="hljs-params">(LinkList &amp;head,<span class="hljs-type">int</span> i,T e)</span> &#123;<br>    LinkList p=head; <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p&amp;&amp;j&lt;i) &#123;<br>        p=p-&gt;next; j++; <span class="hljs-comment">// 画图理解：p指向第i-1个元素</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (!p||j&gt;i) <span class="hljs-comment">// robust，对应i&gt;length+1和i&lt;1两种情况</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    LinkList s=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    <span class="hljs-keyword">if</span> (!s)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    s-&gt;data=e;<br>    s-&gt;next=p-&gt;next;<br>    p-&gt;next=s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 删（根据下标删除，并将已删除元素值转给e）</span><br><span class="hljs-comment"> * 返回1 表示删除成功</span><br><span class="hljs-comment"> * 返回0 表示删除失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">DeleteElem_L</span><span class="hljs-params">(LinkList &amp;head,<span class="hljs-type">int</span> i,T &amp;e)</span> &#123;<br>    LinkList p=head; <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p-&gt;next&amp;&amp;j&lt;i) &#123;<br>        p=p-&gt;next; j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(p-&gt;next)||j&gt;i) <span class="hljs-comment">// robust，对应i&gt;length和i&lt;1两种情况</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    LinkList s=p-&gt;next;<br>    p-&gt;next=s-&gt;next;<br>    e=s-&gt;data;<br>    <span class="hljs-built_in">free</span>(s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 清空链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ClearList_L</span><span class="hljs-params">(LinkList &amp;head)</span> &#123;<br>    <span class="hljs-keyword">while</span> (head-&gt;next) &#123;<br>        LinkList s=head-&gt;next;<br>        head-&gt;next=s-&gt;next;<br>        <span class="hljs-built_in">free</span>(s);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 取第i个数据元素</span><br><span class="hljs-comment"> * 返回1 表示取值成功</span><br><span class="hljs-comment"> * 返回0 表示取值失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetElem_L</span><span class="hljs-params">(LinkList &amp;head,<span class="hljs-type">int</span> i,T &amp;e)</span> &#123;<br>    LinkList p=head; <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p-&gt;next&amp;&amp;j&lt;i) &#123;<br>        p=p-&gt;next; j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(p-&gt;next)||j&gt;i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    e=p-&gt;next-&gt;data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 查</span><br><span class="hljs-comment"> * 若存在，则返回它的位序，否则返回0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem_L</span><span class="hljs-params">(LinkList head,T e)</span> &#123;<br>    LinkList p; <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">for</span> (p=head,j=<span class="hljs-number">1</span>;p-&gt;next;p=p-&gt;next,j++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;next-&gt;data...) <span class="hljs-comment">// 满足条件</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(p-&gt;next))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 逆序输入n个数据元素，建立带头结点的单链表（前插法）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateList_H</span><span class="hljs-params">(LinkList &amp;head,<span class="hljs-type">int</span> n)</span> &#123;<br>    head=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    head-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        LinkList p=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;(p-&gt;data));<br>        p-&gt;next=head-&gt;next;<br>        head-&gt;next=p;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 输入n个数据元素，建立带头结点的单链表（后插法）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateList_E</span><span class="hljs-params">(LinkList &amp;head,<span class="hljs-type">int</span> n)</span> &#123;<br>    head=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    head-&gt;next=<span class="hljs-literal">NULL</span>;<br>    LinkList pend=head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        LinkList p=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;(p-&gt;data));<br>        p-&gt;next=<span class="hljs-literal">NULL</span>;<br>        pend-&gt;next=p;<br>        pend=p;<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 销毁链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DestroyList_L</span><span class="hljs-params">(LinkList &amp;head)</span> &#123;<br>    LinkList p=head;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        LinkList q=p;<br>        p=p-&gt;next;<br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h4><ol><li><p>插入和删除运算时，无须移动表中元素的位置，只需修改有关结点的指针内容</p></li><li><p>不需要一块连续的存储空间，只要能存放一个数据元素的空闲结点就可以被利用</p></li><li><p>表的规模易扩充</p></li><li><p>不能随机访问表中元素，访问时间与元素在表中的位置有关</p></li></ol><h4 id="改进的单链表"><a href="#改进的单链表" class="headerlink" title="改进的单链表"></a>改进的单链表</h4><p>上述定义的单链表中：</p><p><strong>问题</strong></p><ol><li>表长是一个隐含的值</li><li>在单链表的最后一个元素之后插入元素时，需遍历整个链表</li><li>元素的“位序”概念淡化，结点的“位置”概念加强</li></ol><p><strong>改进</strong></p><ol><li>增加表长、表尾指针和当前位置的指针</li><li>将基本操作中的位序 i 改变为指针 p</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ----------Linklist_V2.h----------</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LINKLIST_V2_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LINKLIST_V2_H_</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T; <span class="hljs-comment">// 数据元素类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> &#123;<br>T data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>* next;<br>&#125; LNode,*Link;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>Link head;<br>    Link tail;<br>    Link current;<br>    <span class="hljs-type">int</span> len;<br>&#125; LinkList;<br><br><span class="hljs-keyword">extern</span> LinkList L;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InitList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>;<br><span class="hljs-comment">// 构造一个空的线性链表L，其头指针、尾指针和当前指针均指向头结点，表长为零</span><br><span class="hljs-comment">// O(1)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>;<br><span class="hljs-comment">// 销毁线性链表L，L不再存在</span><br><span class="hljs-comment">// O(n)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListEmpty_L</span><span class="hljs-params">(LinkList L)</span></span>;<br><span class="hljs-comment">// 判表空</span><br><span class="hljs-comment">// O(1)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength_L</span><span class="hljs-params">(LinkList L)</span></span>;<br><span class="hljs-comment">// 求表长</span><br><span class="hljs-comment">// O(1)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Prior_L</span><span class="hljs-params">(LinkList L)</span></span>;<br><span class="hljs-comment">// 改变当前指针指向其前驱</span><br><span class="hljs-comment">// O(n)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Next_L</span><span class="hljs-params">(LinkList L)</span></span>;<br><span class="hljs-comment">// 改变当前指针指向其后继</span><br><span class="hljs-comment">// O(1)</span><br><br><span class="hljs-function">T <span class="hljs-title">GetElem_L</span><span class="hljs-params">(LinkList L)</span></span>;<br><span class="hljs-comment">// 返回当前指针所指数据元素</span><br><span class="hljs-comment">// O(1)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem_L</span><span class="hljs-params">(LinkList L,T e)</span></span>;<br><span class="hljs-comment">// 若存在与e满足函数compare()判定关系的元素，则移动当前指针指向第1个满足条件的元素,返回1，否则返回0</span><br><span class="hljs-comment">// O(n)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocatePos</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-comment">// 改变当前指针指向第i个结点</span><br><span class="hljs-comment">// O(n)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>;<br><span class="hljs-comment">// 重置L为空表</span><br><span class="hljs-comment">// O(n)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutElem_L</span><span class="hljs-params">(LinkList &amp;L,T e)</span></span>;<br><span class="hljs-comment">// 更新当前指针所指数据元素</span><br><span class="hljs-comment">// O(1)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Append</span><span class="hljs-params">(LinkList &amp;L,Link s)</span></span>;<br><span class="hljs-comment">// 在表尾结点之后链接一串结点</span><br><span class="hljs-comment">// O(s)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InsAfter</span><span class="hljs-params">(LinkList &amp;L,T e)</span></span>;<br><span class="hljs-comment">// 将元素e插入在当前指针之后</span><br><span class="hljs-comment">// O(1)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DelAfter</span><span class="hljs-params">(LinkList &amp;L,T &amp;e)</span></span>;<br><span class="hljs-comment">// 删除当前指针之后的结点</span><br><span class="hljs-comment">// O(1)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="其它形式的链表"><a href="#其它形式的链表" class="headerlink" title="其它形式的链表"></a>其它形式的链表</h4><p><strong>(1) 双向链表</strong></p><p>链表中的结点有两个指针域，分别指向后继和前趋</p><ol><li><strong>“查询”与单链表相同</strong>：Length, Get, Locate 操作仅涉及一个方向的指针</li><li><strong>“插入”和“删除”与单链表有区别</strong>：双向链表结点可以直接定位前驱，双向链表中需要同时修改两个方向上的指针（画图）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> &#123;<br>T data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span>* prior;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span>* next;<br>&#125; DuLNode,*DuLinkList;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 前插</span><br><span class="hljs-comment">// s指向待插结点</span><br>s-&gt;prior=p-&gt;prior;<br>p-&gt;prior-&gt;next=s;<br>s-&gt;next=p;<br>p-&gt;prior=s;<br><br><span class="hljs-comment">// 后插</span><br><span class="hljs-comment">// s指向待插结点</span><br>s-&gt;next=p-&gt;next;<br>p-&gt;next=s;<br>s-&gt;next-&gt;prior=s;<br>s-&gt;prior=p;<br><br><span class="hljs-comment">// 前删</span><br><span class="hljs-comment">// s指向待删结点</span><br>s=p-&gt;prior;<br>s-&gt;prior-&gt;next=s-&gt;next;<br>s-&gt;next-&gt;prior=s-&gt;prior;<br><span class="hljs-built_in">free</span>(s);<br><br><span class="hljs-comment">// 后删</span><br><span class="hljs-comment">// s指向待删结点</span><br>s=p-&gt;next;<br>p-&gt;next=s-&gt;next;<br>s-&gt;next-&gt;prior=s-&gt;prior;<br><span class="hljs-built_in">free</span>(s);<br></code></pre></td></tr></table></figure><p><strong>(2) 循环链表</strong></p><p>最后一个结点的指针域的指针又指回第一个结点的链表</p><p>和单链表的差别仅在于：判别链表中最后一个结点的条件不再是“后继是否为空”，而是“后继是否为头结点”</p><p><strong>(3) 双向循环链表</strong></p><p><strong>(4) 静态链表</strong></p><p>数组的一个分量表示一个结点，同时用游标（指示器 cur）代替指针指示结点在数组中的位置</p><p>数组的第 0 个分量可看成头结点，其指针域指示链表的第一个结点，最后一个结点指针域值为 0</p><p>这种存储结构仍需要预先分配一个较大的存储空间，但在作线性表的插入和删除操作时不需移动元素，仅需修改指针，故仍具有链式存储结构的主要优点</p><ol><li><p>在静态链表中，以整型游标 i 代替动态指针 p，类似于<code>p=p-&gt;next</code>，指针后移操作用<code>i=S[i].cur</code>实现</p></li><li><p>静态链表中指针修改的操作和单链表基本相同，所不同的是，需由用户自己实现 malloc 和 free 这两个函数</p><p>如何辨明数组中哪些分量未被使用？解决的办法是：将所有未被使用过的以及被删除的分量用游标链成一个备用的链表，每当进行插入时便可从备用链表上取得第一个结点作为待插入的新结点；反之，在删除时将从链表中删除下来的结点链接到备用链表上</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000 <span class="hljs-comment">// 链表最大长度</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>T   data;<br><span class="hljs-type">int</span> cur; <span class="hljs-comment">// 指示结点在数组中的相对位置</span><br>&#125; SLinkList[MAXSIZE];<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo</span><br><span class="hljs-comment">// 在静态单链表S中查找第1个值为e的元素，若找到，则返回它在S中的位序，否则返回0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem_SL</span><span class="hljs-params">(SLinkList S,T e)</span> </span>&#123;<br><span class="hljs-type">int</span> i=S[<span class="hljs-number">0</span>].cur;<br>    <span class="hljs-keyword">while</span> (i&amp;&amp;S[i].data!=e)<br>        i=S[i].cur;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(5) 有序链表</strong></p><p>有序链表的操作与一般线性链表基本一致，除了以下两个操作有区别：</p><p><code>bool LocateElem_OL(OLinkList L, T e, Position &amp;q, int(*compare)(T, T))</code></p><p>结果：若有序表 L 中存在元素 e，则 q 指示 L 中第一个值为 e 的元素的位置，并返回函数值 TRUE；否则 q 指示<strong>第一个大于 e 的元素的前驱</strong>的位置，并返回函数值 FALSE</p><p><code>void OrderInsert(OLinkList L, T e, int(*compare)(T, T))</code></p><p>结果：按有序判定函数 compare 的约定，将值为 e 的结点插入到有序链表 L 的适当位置</p><h3 id="4-在实际应用中采用哪一种存储结构更合适？"><a href="#4-在实际应用中采用哪一种存储结构更合适？" class="headerlink" title="4 - 在实际应用中采用哪一种存储结构更合适？"></a>4 - 在实际应用中采用哪一种存储结构更合适？</h3><h4 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h4><p>对于存储空间的考虑可以用存储密度的大小来衡量。其中存储密度的大小定义为一个结点数据本身所占用的存储量与结点结构所占用的存储量的比值。一般地，存储密度越大，存储空间的利用率就越高。显然，顺序表的存储密度为 1，而链式存储结构的存储密度则小于 1。</p><p>顺序表要求预先分配存储空间，一般在程序执行之前是难以估计存储空间大小，估计过大会造成浪费，估计过小又会产生空间溢出。而链式存储结构的存储空间是动态分配，只要内存空间有空间，就可动态申请内存空间，不会产生溢出。</p><h4 id="运算时间"><a href="#运算时间" class="headerlink" title="运算时间"></a>运算时间</h4><p>顺序存储结构是一种随机存取的结构，即表中任一元素都可在 O(1) 时间复杂度直接地存取。链式存储结构必须从头指针开始顺着链扫描才能取得，一般情况下其时间复杂度为 O(n)。</p><p>对于那些只进行<strong>查找</strong>运算而很少做插入和删除等的运算，宜采用<strong>顺序存储结构</strong>。对于那些需要频繁地进行元素的<strong>插入和删除</strong>运算的线性表，其存储结构应采用<strong>链式存储结构</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个开始 &amp; 绪论</title>
    <link href="/2023/03/02/%E4%B8%80%E4%B8%AA%E5%BC%80%E5%A7%8B-%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/03/02/%E4%B8%80%E4%B8%AA%E5%BC%80%E5%A7%8B-%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>数据结构课程笔记 ep1</p><span id="more"></span><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ol><li>逻辑结构：集合、线性、树、图</li><li>存储结构：顺序、链式</li><li>时间复杂度</li><li>空间复杂度</li></ol><p>通常需要牺牲空间换取时间、牺牲时间换取空间</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cet6同义替换总结</title>
    <link href="/2023/03/02/cet6%E5%90%8C%E4%B9%89%E6%9B%BF%E6%8D%A2%E6%80%BB%E7%BB%93/"/>
    <url>/2023/03/02/cet6%E5%90%8C%E4%B9%89%E6%9B%BF%E6%8D%A2%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>六级单词复习</p><span id="more"></span><h4 id="减少"><a href="#减少" class="headerlink" title="减少"></a>减少</h4><ol><li>go down &#x2F; fall &#x2F; drop &#x2F; slip</li><li>reduce</li><li>lessen</li><li>decrease</li><li>decline (还可以表示“婉拒”)</li><li>diminish</li><li>shrink</li><li>dwindle 强调“逐渐减少”</li><li>slump 强调“急剧减少”</li><li>plunge 强调“急剧减少”</li><li>slash &#x3D; cut down &#x3D; lower 强调“削减金额”</li></ol><h4 id="退化-恶化"><a href="#退化-恶化" class="headerlink" title="退化 恶化"></a>退化 恶化</h4><ol><li>degrade (还可以表示“降解”)</li><li>decay (还可以表示“”腐烂)</li><li>degenerate</li><li>deteriorate</li><li>aggravate</li><li>worsen</li></ol><h4 id="经济衰退"><a href="#经济衰退" class="headerlink" title="经济衰退"></a>经济衰退</h4><p><strong>都是名词</strong></p><ol><li>economic disruption</li><li>recession</li><li>depression</li></ol><h4 id="物理上的下降"><a href="#物理上的下降" class="headerlink" title="物理上的下降"></a>物理上的下降</h4><p>descend</p><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><ol><li><p>add</p></li><li><p>grow - growth</p><p><em>a growing number of 替换 <del>more and more</del></em></p></li><li><p>increase</p></li><li><p>mount (还可以表示“攀登”)</p></li><li><p>augment 可作v和n</p></li><li><p>rise 可作vi和n</p></li><li><p>raise (还可以表示“筹款；抚养”)</p></li><li><p>rocket &#x3D; skyrocket 强调“急剧增加”</p></li><li><p>soar 强调“急剧增加”(还可以表示“翱翔”)</p></li><li><p>surge 强调“急剧增加”</p></li><li><p>hike 强调“急剧增加，大幅增加”</p></li><li><p>spike n 强调“急剧增加”</p></li></ol><h4 id="促进-提高"><a href="#促进-提高" class="headerlink" title="促进 提高"></a>促进 提高</h4><ol><li>improve</li><li>enhance</li><li>promote (还可以表示“促销”)</li><li>foster (还可以表示“抚养”)</li><li>facilitate</li><li>elevate</li><li>boost</li><li>accelerate (还可以表示“加速” opp: decelerate)</li></ol><h4 id="扩大"><a href="#扩大" class="headerlink" title="扩大"></a>扩大</h4><ol><li>expand</li><li>enlarge</li><li>amplify 常表示“声音上的扩大” - ample</li></ol><h4 id="夸大"><a href="#夸大" class="headerlink" title="夸大"></a>夸大</h4><ol><li><p>magnify (还可以表示“物理上的放大”)</p></li><li><p>exaggerate</p></li><li><p>overstate</p></li></ol><h4 id="经济繁荣"><a href="#经济繁荣" class="headerlink" title="经济繁荣"></a>经济繁荣</h4><p><strong>不及物动词 - 形容词</strong></p><ol><li>boom - booming</li><li>thrive - thriving</li><li>flourish - flourishing</li><li>prosper - prosperous</li></ol><p><strong>名词</strong></p><ol><li>boom</li><li>prosperity</li></ol><h4 id="导致-表因果的词"><a href="#导致-表因果的词" class="headerlink" title="导致(表因果的词)"></a>导致(表因果的词)</h4><ol><li><p>cause v.导致 n.原因</p></li><li><p>incur 导致</p><p>occur 发生 &#x2F; recur 再次发生 &#x2F; concur 同时发生</p></li><li><p>spell 导致</p></li><li><p>lead to 导致</p></li><li><p>result in 导致</p></li><li><p>result from 由……导致</p></li><li><p>bring about 导致</p></li><li><p>contribute to 导致；有助于(褒 &#x3D; be good for) (contributor n.原因)</p></li><li><p>give rise to 导致</p></li><li><p>pave the way to 为……铺平道路</p><p><strong>引申而来的因果意味</strong></p></li><li><p>trigger 触发(某些场景)；引发</p></li><li><p>breed 繁殖(brood 孵化；沉思 ~ about)；导致</p></li><li><p>promote 助长；促进</p></li><li><p>generate 产生；引起</p></li><li><p>produce 产生；引起</p></li><li><p>fuel 加燃料(refuel 补给燃料)；激起</p><p><em>fuel my enthusiasm &#x2F; passion for</em></p><p><em>fuel my interest in</em></p></li><li><p>ignite 点燃；引发</p><p><em>ignite my enthusiasm &#x2F; passion for</em></p><p><em>ignite my interest in</em></p></li></ol><h4 id="谴责"><a href="#谴责" class="headerlink" title="谴责"></a>谴责</h4><ol><li><p>blame 可作v和n</p><p><em>blame…on… 把……归咎于</em></p><p><em>be to blame 应受谴责</em></p></li><li><p>condemn</p></li><li><p>scold 斥责</p></li><li><p>denounce 强调“公开谴责”</p></li><li><p>criticize v.批评</p><p>critic n.批评家</p><p>criticism n.批评</p><p>critical adj.批判的</p></li><li><p>accuse 指控(excuse 原谅)</p><p><em>accuse sb of</em></p></li><li><p>charge 指控</p><p><em>charge sb with</em></p></li><li><p>be under fire 遭到射击；遭到谴责</p></li><li><p>reproach</p></li></ol><h4 id="赞扬"><a href="#赞扬" class="headerlink" title="赞扬"></a>赞扬</h4><ol><li><p>praise</p></li><li><p>compliment 可作v和n(complement v.&#x2F;n.补充)</p><p><em>compliment…on…</em></p></li><li><p>commend 推荐(&#x3D; recommend)；赞扬(强调“公开赞扬”)(command 命令)</p></li><li><p>celebrate 庆祝；颂扬</p></li><li><p>hail</p></li></ol><h4 id="重要的-perform-a-…-role-in"><a href="#重要的-perform-a-…-role-in" class="headerlink" title="重要的 perform a … role in"></a>重要的 perform a … role in</h4><ol><li><p>vital</p></li><li><p>significant</p></li><li><p>crucial</p></li><li><p>key 可作n和adj</p></li><li><p>strategic</p></li><li><p>substantial</p></li><li><p>central</p></li><li><p>considerable (还可以表示“相当大的，相当多的”)</p></li><li><p>irreplaceable 不可替代的</p></li><li><p>matter v</p></li><li><p>imperative</p></li></ol><h4 id="必要的"><a href="#必要的" class="headerlink" title="必要的"></a>必要的</h4><ol><li><p>necessary</p></li><li><p>essential 必要的；本质的</p></li><li><p>indispensable</p></li><li><p>integral</p></li></ol><h4 id="主要的"><a href="#主要的" class="headerlink" title="主要的"></a>主要的</h4><ol><li><p>major adj.主要的 n.专业 vi.主修(major in)</p></li><li><p>chief</p></li><li><p>main</p></li><li><p>principal adj.主要的 n.校长</p></li><li><p>cardinal</p></li><li><p>primary</p></li></ol><h4 id="首要的"><a href="#首要的" class="headerlink" title="首要的"></a>首要的</h4><ol><li><p>dominant &#x2F; predominant</p></li><li><p>prime</p></li><li><p>primary</p></li></ol><h4 id="不重要的"><a href="#不重要的" class="headerlink" title="不重要的"></a>不重要的</h4><ol><li>marginal</li><li>minor</li><li>trivial</li><li>negligible</li></ol><h4 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h4><ol><li><p>alter - alternation - alternative</p></li><li><p>shift 可作v和n(还可以表示“替换；轮班”)</p></li><li><p>modify</p><p><em>genetically modified</em> <em>转基因的</em></p></li><li><p>transform</p></li><li><p>convert 强调“状态上的转变”(还可以表示“皈依”)</p><p><em>convert … into …</em></p></li><li><p>vary v.变化；不同</p><p><em>sth vary from … to …</em></p><p><em>vary from season to season</em></p><p><em>vary from individual to individual</em></p></li><li><p>switch 可作v和n</p></li><li><p>change &#x2F; turn</p></li><li><p>translate (还可以表示“解释”)</p><p><em>translate … into …</em></p></li></ol><h4 id="抑制-阻碍"><a href="#抑制-阻碍" class="headerlink" title="抑制 阻碍"></a>抑制 阻碍</h4><ol><li><p>limit</p></li><li><p>prevent</p></li><li><p>curb 可作v和n</p></li><li><p>stem (还可以表示“源于”)</p></li><li><p>check</p></li><li><p>block</p></li><li><p>impede</p></li><li><p>discourage</p><p><em>discourage sb from doing</em></p></li><li><p>barrier n.障碍</p></li><li><p>deter 强调“震慑住”(deterrent n.阻碍)</p></li><li><p>hinder</p></li><li><p>hamper</p></li><li><p>inhibit</p></li><li><p>prohibit</p></li><li><p>obstacle n.障碍</p></li><li><p>obstruct (obstruction n.阻碍)</p></li><li><p>restrict</p><p><em>restrict sb to do</em></p></li><li><p>refrain vi.</p><p><em>refrain from doing</em></p></li><li><p>restrain</p><p><em>restrain sb from doing</em></p></li><li><p>constrain 强调“限制，约束”(constraint n.)</p></li><li><p>subdue 强调“情绪上的克制”(还可以表示“征服”)</p></li><li><p>suppress</p></li><li><p>hold back (还可以表示“扣留”)</p></li><li><p>get in the way</p></li><li><p>preclude</p></li></ol><h4 id="不利的-不好的"><a href="#不利的-不好的" class="headerlink" title="不利的 不好的"></a>不利的 不好的</h4><ol><li>unfavorable 不利的，不赞同的(favorable adj.有利的，赞同的)</li><li>adverse 不利的，相反的，敌对的</li><li>disadvantageous 不利的</li><li>undesirable 不受欢迎的</li><li>hostile 有敌意的</li><li>inconvenience n.不方便</li><li>disservice n.帮倒忙，伤害</li><li>damage</li><li>injure - injury</li><li>ruin</li></ol><h4 id="有利的-好的"><a href="#有利的-好的" class="headerlink" title="有利的 好的"></a>有利的 好的</h4><ol><li><p>positive</p></li><li><p>optimistic</p></li><li><p>rosy</p></li><li><p>beneficial</p></li><li><p>advantageous</p><p><em>be advantageous to</em></p></li><li><p>favorable</p></li><li><p>rewarding</p></li><li><p>profitable</p></li><li><p>constructive</p><p><em>perform a constructive role in</em></p></li><li><p>hopeful</p></li><li><p>promising</p></li></ol><h4 id="反对"><a href="#反对" class="headerlink" title="反对"></a>反对</h4><ol><li><p>oppose 及物动词(opposition n. &#x2F; opposite adj.)</p></li><li><p>object 不及物动词(objection n.)</p><p><em>object to</em></p></li><li><p>disapprove</p></li><li><p>dispute v.&#x2F;n.争议</p></li><li><p>challenge 挑战，质疑</p></li><li><p>combat 对抗</p></li><li><p>resist 抵制(resistant adj.)</p></li><li><p>contradict (contradiction n.矛盾，反驳)</p></li></ol><h4 id="杰出的-显著的"><a href="#杰出的-显著的" class="headerlink" title="杰出的 显著的"></a>杰出的 显著的</h4><ol><li>prominent</li><li>eminent</li><li>remarkable</li><li>conspicuous</li><li>outstanding</li><li>striking</li><li>pronounced (pronounce v.发音，宣布)</li><li>spectacular (spectacle n.壮丽的景象)</li><li>noted</li><li>notable</li><li>notorious 臭名昭著的</li></ol><h4 id="困难的-费力的"><a href="#困难的-费力的" class="headerlink" title="困难的 费力的"></a>困难的 费力的</h4><ol><li>hard</li><li>difficult</li><li>tough</li><li>harsh (还可以表示“声音刺耳的”)</li><li>challenging</li><li>demanding</li><li>troublesome</li><li>burdensome</li><li>rigorous (rigor n.)</li><li>laborious &#x2F;lə’bɔrɪəs&#x2F;</li></ol><h4 id="证明-解释"><a href="#证明-解释" class="headerlink" title="证明 解释"></a>证明 解释</h4><ol><li>explain</li><li>interpret (interpretation n.解释 &#x2F; misinterpretation n.误解)</li><li>translate (还可以表示“转换”)</li><li>illustrate</li><li>demonstrate</li><li>testify</li><li>justify (just adj.正当的)</li><li>clarify 强调“澄清”</li><li>certify 强调“认证”</li><li>account for (还可以表示“占比”)</li></ol><h4 id="刺激"><a href="#刺激" class="headerlink" title="刺激"></a>刺激</h4><p><strong>名词</strong></p><ol><li>factor</li><li>motive</li><li>stimulus (sting v.刺，叮 &#x2F; stick v.刺，戳)</li><li>incentive</li><li>spur</li><li>urge (urgency n.紧急 &#x2F; urgent adj.紧急的)</li><li>impetus</li></ol><p><strong>动词</strong></p><ol><li>activate</li><li>motivate</li><li>stimulate</li><li>prompt</li><li>propel</li><li>inspire</li><li>trigger</li><li>spur (既可作名词，也可作动词)</li><li>urge (既可作名词，也可作动词)</li><li>arouse v 强调“唤起”</li><li>irritate v 强调“激怒” (irritation n.)</li><li>provoke v 强调“激怒”</li></ol><h4 id="遵守"><a href="#遵守" class="headerlink" title="遵守"></a>遵守</h4><ol><li>obey</li><li>observe</li><li>abide by</li><li>conform to</li><li>comply with</li></ol>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cet6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再看STL标准模板库</title>
    <link href="/2022/08/04/%E5%86%8D%E7%9C%8BSTL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <url>/2022/08/04/%E5%86%8D%E7%9C%8BSTL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>根据 Acwing 算法基础课整理。</p><span id="more"></span><h1 id="再看STL标准模板库"><a href="#再看STL标准模板库" class="headerlink" title="再看STL标准模板库"></a>再看STL标准模板库</h1><p>参考：<a href="https://cplusplus.com/reference">https://cplusplus.com/reference</a></p><h3 id="pre：pair"><a href="#pre：pair" class="headerlink" title="pre：pair"></a>pre：pair</h3><p>定义：<br><code>pair&lt;int,string&gt; p;</code></p><p>初始化：<br>第一种：<code>p=make_pair(10,&quot;abc&quot;);</code><br>第二种：<code>p=&#123;10,&quot;abc&quot;&#125;;</code></p><p>重要字段：<br>第一个元素：<code>p.first</code><br>第二个元素：<code>p.second</code></p><p>其他特性：<br>支持比较运算（以 first 为第一关键字，second 为第二关键字，按字典序）<br>拓展到三个值 <code>pair&lt;int,pair&lt;int,int&gt;&gt;</code></p><h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h3><p>常用函数：<br><code>size()</code> <code>length()</code> 返回字符个数<br><code>empty()</code> 返回是否为空<br><code>clear()</code> 清空<br><code>substr()</code> 返回字串（第一个参数：index；第二个参数：length）<br><code>c_str()</code> 返回字符串对应的字符数组头指针（转换为字符数组）</p><p>其他特性：<br>字符串拼接 +&#x3D;赋值操作</p><h3 id="vector-变长数组"><a href="#vector-变长数组" class="headerlink" title="vector 变长数组"></a>vector 变长数组</h3><p>倍增的思想：<br>系统为 vector 分配空间所需时间，与空间大小无关，与申请次数有关<br>vector 变长后复制<br>故向 vector 插入数据时，申请空间时间复杂度总共 O(logn)，复制时间复杂度平均 O(1)</p><p>定义：<br><code>vector&lt;int&gt; a</code> 变长数组 a<br><code>vector&lt;int&gt; a(10)</code> 长度为10的变长数组 a<br><code>vector&lt;int&gt; a(10,3)</code> 长度为10的变长数组 a，并且所有元素都为 3</p><p>常用函数：<br><code>size()</code> 返回元素个数<br><code>empty()</code> 返回是否为空<br><code>clear()</code> 清空<br><code>begin()</code> 头迭代器<br><code>end()</code> 尾迭代器<br><code>front()</code> 返回第一个数<br><code>back()</code> 返回最后一个数<br><code>push_back()</code> 向尾插入<br><code>pop_back()</code> 从尾弹出</p><p>其他特性：<br>支持 [] 随机寻址<br>支持比较运算（按字典序）</p><p>遍历方法：<br><code>vector&lt;int&gt; a;</code><br>第一种：<code>for (int i=0;i&lt;a.size();i++) cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;</code><br>第二种：<code>for (vector&lt;int&gt;::iterator i=a.begin();i!=a.end();i++) cout &lt;&lt; *i &lt;&lt; &#39; &#39;;</code><br><code>for (auto i=a.begin();i!=a.end();i++) cout &lt;&lt; *i &lt;&lt; &#39; &#39;;</code><br>第三种：<code>for (auto x : a) cout &lt;&lt; x &lt;&lt; &#39; &#39;;</code></p><h3 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h3><p>定义：<br><code>stack&lt;类型&gt; 变量名;</code></p><p>常用函数：<br><code>size()</code> 返回元素个数<br><code>empty()</code> 返回是否为空<br><del>无 clear</del><br><code>top()</code> 返回栈顶元素<br><code>push()</code> 向栈顶插入<br><code>pop()</code> 从栈顶弹出</p><h3 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h3><p>定义：<br><code>queue&lt;类型&gt; 变量名;</code></p><p>常用函数：<br><code>size()</code> 返回元素个数<br><code>empty()</code> 返回是否为空<br><del>无 clear</del> 替代方案：<code>变量名 = queue&lt;int&gt;();</code><br><code>front()</code> 返回队头元素<br><code>back()</code> 返回队尾元素<br><code>push()</code> 向队尾插入<br><code>pop()</code> 从队头弹出</p><p>遍历方法：<br><code>queue&lt;int&gt; myqueue;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;myqueue.<span class="hljs-built_in">size</span>();i++) &#123; <span class="hljs-comment">// myqueue.size()必须是固定值</span><br>cout &lt;&lt; myqueue.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>myqueue.<span class="hljs-built_in">push</span>(myqueue.<span class="hljs-built_in">front</span>());<br>myqueue.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="priority-queue-优先队列（堆）"><a href="#priority-queue-优先队列（堆）" class="headerlink" title="priority_queue 优先队列（堆）"></a>priority_queue 优先队列（堆）</h3><p>定义：<br>默认是大根堆<br>大根堆：<code>priority_queue&lt;类型&gt; 变量名;</code><br>小根堆：<code>priority_queue&lt;类型,vector&lt;类型&gt;,greater&lt;类型&gt;&gt; 变量名</code></p><p>常用函数：<br><code>size()</code> 返回元素个数<br><code>empty()</code> 返回是否为空<br><del>无 clear</del><br><code>top()</code> 返回堆顶元素<br><code>push()</code> 向堆里插入<br><code>pop()</code> 从堆顶弹出</p><h3 id="deque-双端队列（升级版的-vector）"><a href="#deque-双端队列（升级版的-vector）" class="headerlink" title="deque 双端队列（升级版的 vector）"></a>deque 双端队列（升级版的 vector）</h3><p>缺点：较慢</p><p>定义：<br><code>deque&lt;类型&gt; 变量名;</code></p><p>常用函数：<br><code>size()</code> 返回元素个数<br><code>empty()</code> 返回是否为空<br><code>clear()</code> 清空<br><code>begin()</code> 头迭代器<br><code>end()</code> 尾迭代器<br><code>front()</code> 返回第一个数<br><code>back()</code> 返回最后一个数<br><code>push_back()</code> 向尾插入<br><code>pop_back()</code> 从尾弹出<br>-<br><code>push_front()</code> 向头插入<br><code>pop_front()</code> 从头弹出</p><p>其他特性：<br>支持 [] 随机寻址</p><h3 id="set-multiset-map-multimap-基于平衡二叉树（红黑树）"><a href="#set-multiset-map-multimap-基于平衡二叉树（红黑树）" class="headerlink" title="set, multiset, map, multimap 基于平衡二叉树（红黑树）"></a>set, multiset, map, multimap 基于平衡二叉树（红黑树）</h3><p>功能：动态维护有序序列</p><p>定义：<br>set, map 无重复元素，multiset, multimap 可以有重复元素<br><code>set&lt;类型&gt; 变量名;</code><br><code>multiset&lt;类型&gt; 变量名;</code><br><code>map&lt;类型,类型&gt; 变量名;</code><br><code>multimap&lt;类型,类型&gt; 变量名;</code></p><p>常用函数：<br><code>size()</code> 返回元素个数<br><code>empty()</code> 返回是否为空<br><code>clear()</code> 清空<br><code>begin()</code> 头迭代器<br><code>end()</code> 尾迭代器</p><p>-set, multiset-<br><code>insert()</code> 插入一个元素<br><code>count()</code> 返回某个元素出现的次数<br><code>find()</code> 查找一个元素（返回迭代器）<br><code>lower_bound(x)</code> 返回大于等于 x 的最小的数的迭代器<br><code>upper_bound(x)</code> 返回大于 x 的最小的数的迭代器<br><code>erase()</code> (1) 输入是一个数 x，删除所有 x；(2) 输入是迭代器，删除这个迭代器对应的值</p><p>-map, multimap-<br><code>insert()</code> 插入一个元素 - pair<br><code>count()</code> 返回某个元素出现的次数 - key<br><code>find()</code> 查找一个元素 - key（返回迭代器）<br><code>lower_bound(x)</code> 返回大于等于 x 的最小的数的迭代器 - key<br><code>upper_bound(x)</code> 返回大于 x 的最小的数的迭代器 - key<br><code>erase()</code> (1) 输入是 pair，删除所有此键值对；(2) 输入是迭代器，删除这个迭代器对应的值</p><p>其他特性：<br>支持迭代器的 ++ 和 –，返回前驱和后继<br>对于 map 和 multimap，有<code>map[键]=值</code>，时间复杂度O(logn)</p><h3 id="unordered-set-unordered-multiset-unordered-map-unordered-multimap-基于哈希表"><a href="#unordered-set-unordered-multiset-unordered-map-unordered-multimap-基于哈希表" class="headerlink" title="unordered_set, unordered_multiset, unordered_map, unordered_multimap 基于哈希表"></a>unordered_set, unordered_multiset, unordered_map, unordered_multimap 基于哈希表</h3><p>与set, multiset, map, multimap类似，但增删改查的时间复杂度为O(1)<br>因为无序，不支持<code>lower_bound(x)</code> <code>upper_bound(x)</code>和迭代器的 ++ 和 –</p><h3 id="bitset-压位"><a href="#bitset-压位" class="headerlink" title="bitset 压位"></a>bitset 压位</h3><p>bitset 是位操作的对象，值只有 0 或 1</p><p>定义：<br><code>bitset&lt;个数&gt; 变量名</code></p><p>支持：<br>~ 取反，&amp; 逻辑与，| 逻辑或，^ 逻辑异或<br>&lt;&lt; 左移，&gt;&gt; 右移<br>&#x3D;&#x3D;，!&#x3D;<br>[]</p><p>常用函数：<br><code>count()</code> 返回某一个数的个数<br><code>any()</code> 判断是否至少有一个 1<br><code>none()</code> 判断是否全为 0<br><code>set()</code> 把所有位赋为 1<br><code>reset()</code> 把所有位赋为 0<br><code>set(k,v)</code> 把第 k 位赋为 v<br><code>flip()</code> 把所有位取反<br><code>flip(k)</code> 把第 k 位取反</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浙大-陈越、何钦铭-数据结构-0.起步能力自测题</title>
    <link href="/2022/07/05/%E6%B5%99%E5%A4%A7-%E9%99%88%E8%B6%8A%E3%80%81%E4%BD%95%E9%92%A6%E9%93%AD-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-0-%E8%B5%B7%E6%AD%A5%E8%83%BD%E5%8A%9B%E8%87%AA%E6%B5%8B%E9%A2%98/"/>
    <url>/2022/07/05/%E6%B5%99%E5%A4%A7-%E9%99%88%E8%B6%8A%E3%80%81%E4%BD%95%E9%92%A6%E9%93%AD-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-0-%E8%B5%B7%E6%AD%A5%E8%83%BD%E5%8A%9B%E8%87%AA%E6%B5%8B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>这是<strong>浙大-陈越、何钦铭-数据结构</strong>课程的<strong>起步能力自测题</strong>的参考代码，题干见<a href="https://pintia.cn/">https://pintia.cn/</a></p><span id="more"></span><h1 id="浙大-陈越、何钦铭-数据结构-0-起步能力自测题"><a href="#浙大-陈越、何钦铭-数据结构-0-起步能力自测题" class="headerlink" title="浙大-陈越、何钦铭-数据结构-0.起步能力自测题"></a>浙大-陈越、何钦铭-数据结构-0.起步能力自测题</h1><h3 id="1-打印沙漏"><a href="#1-打印沙漏" class="headerlink" title="1.打印沙漏"></a>1.打印沙漏</h3><h4 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h4><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">*****<br> ***<br>  *<br> ***<br>*****<br></code></pre></td></tr></table></figure><p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p><p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p><p><strong>输入格式:</strong></p><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p><p><strong>输出格式:</strong></p><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">19 *<br></code></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs out">*****<br> ***<br>  *<br> ***<br>*****<br>2<br></code></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">char</span> c;<br>cin &gt;&gt; n &gt;&gt; c;<br><span class="hljs-type">int</span> max=<span class="hljs-number">1</span>,sum=<span class="hljs-number">1</span>,count=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (sum&lt;=n) &#123;<br>max=<span class="hljs-number">2</span>*count+<span class="hljs-number">1</span>;<br>sum+=<span class="hljs-number">2</span>*max;<br>count++;<br>&#125;<br>sum-=<span class="hljs-number">2</span>*max;<br>max-=<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> temp=max;<br><span class="hljs-keyword">for</span> (;temp&gt;<span class="hljs-number">0</span>;temp-=<span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(max-temp)/<span class="hljs-number">2</span>;i++)<br>cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp;i++)<br>cout &lt;&lt; c;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">for</span> (temp=<span class="hljs-number">3</span>;temp&lt;=max;temp+=<span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(max-temp)/<span class="hljs-number">2</span>;i++)<br>cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp;i++)<br>cout &lt;&lt; c;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; n-sum &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-素数对猜想"><a href="#2-素数对猜想" class="headerlink" title="2.素数对猜想"></a>2.素数对猜想</h3><h4 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h4><p>让我们定义<em>d**n</em>为：<em>d**n</em>&#x3D;<em>p**n</em>+1−<em>p**n</em>，其中<em>p**i</em>是第<em>i</em>个素数。显然有<em>d</em>1&#x3D;1，且对于<em>n</em>&gt;1有<em>d**n</em>是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p><p>现给定任意正整数<code>N</code>(&lt;105)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p><p><strong>输入格式:</strong></p><p>输入在一行给出正整数<code>N</code>。</p><p><strong>输出格式:</strong></p><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">20<br></code></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">4<br></code></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,count=<span class="hljs-number">0</span>,a[<span class="hljs-number">50000</span>];<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;<br><span class="hljs-keyword">if</span> (i==<span class="hljs-number">2</span>||i==<span class="hljs-number">3</span>) &#123;<br>a[count]=i;<br>count++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> j;<br><span class="hljs-keyword">for</span> (j=<span class="hljs-number">2</span>;j&lt;=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">sqrt</span>(i))+<span class="hljs-number">1</span>;j++) &#123;<br><span class="hljs-keyword">if</span> (i%j==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (j==<span class="hljs-built_in">int</span>(<span class="hljs-built_in">sqrt</span>(i))+<span class="hljs-number">2</span>) &#123;<br>a[count]=i;<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (count==<span class="hljs-number">0</span>||count==<span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (j&lt;count) &#123;<br><span class="hljs-keyword">if</span> (a[j]-a[i]==<span class="hljs-number">2</span>)<br>ans++;<br>i++;<br>j++;<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-数组元素循环右移问题"><a href="#3-数组元素循环右移问题" class="headerlink" title="3.数组元素循环右移问题"></a>3.数组元素循环右移问题</h3><h4 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h4><p>一个数组<em>A</em>中存有<em>N</em>（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移<em>M</em>（≥0）个位置，即将<em>A</em>中的数据由（<em>A</em>0<em>A</em>1⋯<em>A**N</em>−1）变换为（<em>A**N</em>−<em>M</em>⋯<em>A**N</em>−1<em>A</em>0<em>A</em>1⋯<em>A**N</em>−<em>M</em>−1）（最后<em>M</em>个数循环移至最前面的<em>M</em>个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><p><strong>输入格式:</strong></p><p>每个输入包含一个测试用例，第1行输入<em>N</em>（1≤<em>N</em>≤100）和<em>M</em>（≥0）；第2行输入<em>N</em>个整数，之间用空格分隔。</p><p><strong>输出格式:</strong></p><p>在一行中输出循环右移<em>M</em>位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">6 2<br>1 2 3 4 5 6<br></code></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">5 6 1 2 3 4<br></code></pre></td></tr></table></figure><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,m,a[<span class="hljs-number">205</span>];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> m1;<br>cin &gt;&gt; n &gt;&gt; m1;<br>m=m1%n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>cin &gt;&gt; a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>+i;j&gt;=i;j--)<br>a[j+<span class="hljs-number">1</span>]=a[j];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>a[i]=a[n+i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br><span class="hljs-keyword">if</span> (i==n<span class="hljs-number">-1</span>) &#123;<br>cout &lt;&lt; a[i] &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Have-Fun-with-Numbers"><a href="#4-Have-Fun-with-Numbers" class="headerlink" title="4.Have Fun with Numbers"></a>4.Have Fun with Numbers</h3><h4 id="题干-3"><a href="#题干-3" class="headerlink" title="题干"></a>题干</h4><p>Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!</p><p>Now you are suppose to check if there are more numbers with this property. That is, double a given number with <em>k</em> digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.</p><p><strong>Input Specification:</strong></p><p>Each input contains one test case. Each case contains one positive integer with no more than 20 digits.</p><p><strong>Output Specification:</strong></p><p>For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.</p><p><strong>Sample Input:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">1234567899<br></code></pre></td></tr></table></figure><p><strong>Sample Output:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">Yes<br>2469135798<br></code></pre></td></tr></table></figure><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> bucket1[<span class="hljs-number">15</span>],bucket2[<span class="hljs-number">15</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">char</span> s[<span class="hljs-number">25</span>];<br>cin &gt;&gt; s;<br><span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(s),num[<span class="hljs-number">25</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>num[i]=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br><span class="hljs-keyword">if</span> (flag) &#123;<br><span class="hljs-keyword">if</span> (num[i]&lt;=<span class="hljs-number">4</span>) &#123;<br>num[i]=num[i]*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>flag=<span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num[i]=num[i]*<span class="hljs-number">2</span><span class="hljs-number">-9</span>;<br>flag=<span class="hljs-number">1</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (num[i]&lt;=<span class="hljs-number">4</span>) &#123;<br>num[i]=num[i]*<span class="hljs-number">2</span>;<br>flag=<span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num[i]=num[i]*<span class="hljs-number">2</span><span class="hljs-number">-10</span>;<br>flag=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>cout &lt;&lt; num[i];<br>cout &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) &#123;<br>bucket1[s[i]-<span class="hljs-string">&#x27;0&#x27;</span>]++;<br>bucket2[num[i]]++;<br>&#125;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br><span class="hljs-keyword">if</span> (bucket1[i]!=bucket2[i])<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (i==<span class="hljs-number">10</span>)<br>cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)<br>cout &lt;&lt; num[j];<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-Shuffling-Machine"><a href="#5-Shuffling-Machine" class="headerlink" title="5.Shuffling Machine"></a>5.Shuffling Machine</h3><h4 id="题干-4"><a href="#题干-4" class="headerlink" title="题干"></a>题干</h4><p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ <strong>automatic shuffling machines</strong>. Your task is to simulate a shuffling machine.</p><p>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">S1</span></span>, S2, ..., S13, <br><span class="hljs-function"><span class="hljs-title">H1</span></span>, H2, ..., H13, <br><span class="hljs-function"><span class="hljs-title">C1</span></span>, C2, ..., C13, <br><span class="hljs-function"><span class="hljs-title">D1</span></span>, D2, ..., D13, <br>J1, J2<br></code></pre></td></tr></table></figure><p>where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the <em>i</em>-th position is <em>j</em>, it means to move the card from position <em>i</em> to position <em>j</em>. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>K</em> (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p><p><strong>Output Specification:</strong></p><p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p><p><strong>Sample Input:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">2<br>36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47<br></code></pre></td></tr></table></figure><p><strong>Sample Output:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5<br></code></pre></td></tr></table></figure><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">char</span> sign;<br><span class="hljs-type">int</span> num;<br><span class="hljs-type">int</span> order;<br>&#125; Card;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rule</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> Card &amp; a1, <span class="hljs-type">const</span> Card &amp; a2)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> a1.order&lt;a2.order;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Card cards[<span class="hljs-number">54</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">13</span>;i++) &#123;<br>cards[i].sign=<span class="hljs-string">&#x27;S&#x27;</span>;<br>cards[i+<span class="hljs-number">13</span>].sign=<span class="hljs-string">&#x27;H&#x27;</span>;<br>cards[i+<span class="hljs-number">26</span>].sign=<span class="hljs-string">&#x27;C&#x27;</span>;<br>cards[i+<span class="hljs-number">39</span>].sign=<span class="hljs-string">&#x27;D&#x27;</span>;<br>cards[i].num=i+<span class="hljs-number">1</span>;<br>cards[i+<span class="hljs-number">13</span>].num=i+<span class="hljs-number">1</span>;<br>cards[i+<span class="hljs-number">26</span>].num=i+<span class="hljs-number">1</span>;<br>cards[i+<span class="hljs-number">39</span>].num=i+<span class="hljs-number">1</span>;<br>&#125;<br>cards[<span class="hljs-number">52</span>].sign=<span class="hljs-string">&#x27;J&#x27;</span>;<br>cards[<span class="hljs-number">53</span>].sign=<span class="hljs-string">&#x27;J&#x27;</span>;<br>cards[<span class="hljs-number">52</span>].num=<span class="hljs-number">1</span>;<br>cards[<span class="hljs-number">53</span>].num=<span class="hljs-number">2</span>;<br><br><span class="hljs-type">int</span> t,list[<span class="hljs-number">54</span>];<br>cin &gt;&gt; t;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">54</span>;i++)<br>cin &gt;&gt; list[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">54</span>;j++)<br>cards[j].order=list[j];<br><span class="hljs-built_in">sort</span>(cards,cards+<span class="hljs-built_in">sizeof</span>(cards)/<span class="hljs-built_in">sizeof</span>(Card),<span class="hljs-built_in">rule</span>());<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">54</span>;i++) &#123;<br><span class="hljs-keyword">if</span> (i==<span class="hljs-number">53</span>)<br>cout &lt;&lt; cards[i].sign &lt;&lt; cards[i].num &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; cards[i].sign &lt;&lt; cards[i].num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL标准模板库</title>
    <link href="/2022/07/01/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <url>/2022/07/01/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>根据 @北京大学郭炜 程序设计与算法(一)C语言程序设计课程整理。</p><span id="more"></span><h1 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure><h2 id="1-sort排序算法"><a href="#1-sort排序算法" class="headerlink" title="1) sort排序算法"></a>1) sort排序算法</h2><h3 id="从小到大排序"><a href="#从小到大排序" class="headerlink" title="从小到大排序"></a>从小到大排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(数组名+n1, 数组名+n2);<br></code></pre></td></tr></table></figure><p>将数组下标范围为[n1, n2)的元素从小到大排序（如果n1&#x3D;0，则+n1可不写）</p><h3 id="从大到小排序"><a href="#从大到小排序" class="headerlink" title="从大到小排序"></a>从大到小排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(数组名+n1, 数组名+n2, <span class="hljs-built_in">greater</span>&lt;T&gt;());<br><span class="hljs-comment">// T为元素类型</span><br></code></pre></td></tr></table></figure><p>将数组下标范围为[n1, n2)的元素从大到小排序（如果n1&#x3D;0，则+n1可不写）</p><h3 id="按自定义规则排序"><a href="#按自定义规则排序" class="headerlink" title="按自定义规则排序"></a>按自定义规则排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构名<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> T &amp; a1, <span class="hljs-type">const</span> T &amp; a2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ...;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// T为元素类型</span><br><span class="hljs-comment">// 自定义结构名和T</span><br><span class="hljs-built_in">sort</span>(数组名+n1, 数组名+n2, 结构名());<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rule1</span> <span class="hljs-comment">// 从大到小排序</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a1 &gt; a2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rule2</span> <span class="hljs-comment">// 按个位数从小到大排序</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a1%<span class="hljs-number">10</span> &lt; a2%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++)<br>        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">3</span>, <span class="hljs-number">98</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-built_in">sort</span>(a, a+<span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 从小到大排序</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;1) &quot;</span>;<br>    <span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">sort</span>(a, a+<span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), <span class="hljs-built_in">rule1</span>()); <span class="hljs-comment">// 从大到小排序</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;2) &quot;</span>;<br>    <span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">sort</span>(a, a+<span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), <span class="hljs-built_in">rule2</span>()); <span class="hljs-comment">// 按个位数从小到大排序</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;2) &quot;</span>;<br>    <span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果为：</span><br><span class="hljs-comment">1) 3,7,12,21,45,98,</span><br><span class="hljs-comment">2) 98,45,21,12,7,3,</span><br><span class="hljs-comment">3) 21,12,3,45,7,98,</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo2</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">double</span> gpa;<br>&#125;;<br><br>student students[] = &#123;&#123;<span class="hljs-string">&quot;Jack&quot;</span>,<span class="hljs-number">112</span>,<span class="hljs-number">3.4</span>&#125;, &#123;<span class="hljs-string">&quot;Mary&quot;</span>,<span class="hljs-number">102</span>,<span class="hljs-number">3.8</span>&#125;, &#123;<span class="hljs-string">&quot;Mary&quot;</span>,<span class="hljs-number">117</span>,<span class="hljs-number">3.9</span>&#125;, &#123;<span class="hljs-string">&quot;Ala&quot;</span>,<span class="hljs-number">333</span>,<span class="hljs-number">3.5</span>&#125;, &#123;<span class="hljs-string">&quot;Zero&quot;</span>,<span class="hljs-number">101</span>,<span class="hljs-number">4.0</span>&#125;&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rule1</span> <span class="hljs-comment">// 按姓名从小到大排序</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> student &amp; s1, <span class="hljs-type">const</span> student &amp; s2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stricmp</span>(s1.name, s2.name) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rule2</span> <span class="hljs-comment">// 按id从小到大排序</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> student &amp; s1, <span class="hljs-type">const</span> student &amp; s2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s1.id &lt; s2.id;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rule3</span> <span class="hljs-comment">// 按gpa从大到小排序</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> student &amp; s1, <span class="hljs-type">const</span> student &amp; s2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s1.gpa &gt; s2.gpa;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-二分查找算法"><a href="#2-二分查找算法" class="headerlink" title="2) 二分查找算法"></a>2) 二分查找算法</h2><h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><h4 id="对从小到大排好序的基本类型数组进行二分查找"><a href="#对从小到大排好序的基本类型数组进行二分查找" class="headerlink" title="对从小到大排好序的基本类型数组进行二分查找"></a>对从小到大排好序的基本类型数组进行二分查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">binary_search</span>(数组名+n1, 数组名+n2, 值);<br></code></pre></td></tr></table></figure><h4 id="对按自定义规则排好序的基本类型数组进行二分查找"><a href="#对按自定义规则排好序的基本类型数组进行二分查找" class="headerlink" title="对按自定义规则排好序的基本类型数组进行二分查找"></a>对按自定义规则排好序的基本类型数组进行二分查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">binary_search</span>(数组名+n1, 数组名+n2, 值, 结构名());<br></code></pre></td></tr></table></figure><p>[n1, n2)（如果n1&#x3D;0，则+n1可不写）</p><p>查找成功，返回值为true(1)；否则，返回值为false(0)</p><p>“等于”的含义：“a必须在b前面”和“b必须在a前面”都不成立</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo3</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rule</span> <span class="hljs-comment">// 按个位数从小到大排序</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a1%<span class="hljs-number">10</span> &lt; a2%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++)<br>        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">3</span>, <span class="hljs-number">98</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-built_in">sort</span>(a, a+<span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">print</span>(a, <span class="hljs-number">6</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;result: &quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a+<span class="hljs-number">6</span>, <span class="hljs-number">12</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;result: &quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a+<span class="hljs-number">6</span>, <span class="hljs-number">77</span>) &lt;&lt; endl;<br>    <span class="hljs-built_in">sort</span>(a, a+<span class="hljs-number">6</span>, <span class="hljs-built_in">rule</span>());<br>    <span class="hljs-built_in">print</span>(a, <span class="hljs-number">6</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;result: &quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a+<span class="hljs-number">6</span>, <span class="hljs-number">7</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;result: &quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a+<span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-built_in">rule</span>()) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果为：</span><br><span class="hljs-comment">3,7,12,21,45,98,</span><br><span class="hljs-comment">result: 1</span><br><span class="hljs-comment">result: 0</span><br><span class="hljs-comment">21,12,3,45,7,98,</span><br><span class="hljs-comment">result: 0          排序规则和查找规则不一致，故这个结果没有意义</span><br><span class="hljs-comment">result: 1          “等于”的含义：“a必须在b前面”和“b必须在a前面”都不成立</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><h4 id="对从小到大排好序的基本类型数组进行二分查找-1"><a href="#对从小到大排好序的基本类型数组进行二分查找-1" class="headerlink" title="对从小到大排好序的基本类型数组进行二分查找"></a>对从小到大排好序的基本类型数组进行二分查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">lower_bound</span>(数组名+n1, 数组名+n2, 值);<br></code></pre></td></tr></table></figure><p>返回值为元素类型指针T* p：*p是查找区间里下标最小的、<strong>大于等于“值”</strong>的元素；如果找不到，p指向下标为n2的元素</p><h4 id="对按自定义规则排好序的基本类型数组进行二分查找-1"><a href="#对按自定义规则排好序的基本类型数组进行二分查找-1" class="headerlink" title="对按自定义规则排好序的基本类型数组进行二分查找"></a>对按自定义规则排好序的基本类型数组进行二分查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">lower_bound</span>(数组名+n1, 数组名+n2, 值, 结构名());<br></code></pre></td></tr></table></figure><p>返回值为元素类型指针T* p：*p是查找区间里下标最小的、<strong>按自定义规则可以排在“值”后面</strong>的元素；如果找不到，p指向下标为n2的元素</p><h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h3><h4 id="对从小到大排好序的基本类型数组进行二分查找-2"><a href="#对从小到大排好序的基本类型数组进行二分查找-2" class="headerlink" title="对从小到大排好序的基本类型数组进行二分查找"></a>对从小到大排好序的基本类型数组进行二分查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">upper_bound</span>(数组名+n1, 数组名+n2, 值);<br></code></pre></td></tr></table></figure><p>返回值为元素类型指针T* p：*p是查找区间里下标最小的、<strong>大于“值”</strong>的元素；如果找不到，p指向下标为n2的元素</p><h4 id="对按自定义规则排好序的基本类型数组进行二分查找-2"><a href="#对按自定义规则排好序的基本类型数组进行二分查找-2" class="headerlink" title="对按自定义规则排好序的基本类型数组进行二分查找"></a>对按自定义规则排好序的基本类型数组进行二分查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">upper_bound</span>(数组名+n1, 数组名+n2, 值, 结构名());<br></code></pre></td></tr></table></figure><p>返回值为元素类型指针T* p：*p是查找区间里下标最小的、<strong>按自定义规则必须排在“值”后面</strong>的元素；如果找不到，p指向下标为n2的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo4</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rule</span> <span class="hljs-comment">// 按个位数从小到大排序</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a1%<span class="hljs-number">10</span> &lt; a2%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++)<br>        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">98</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>&#125;;<br>    <br>    <span class="hljs-built_in">sort</span>(a, a+<span class="hljs-number">7</span>);<br>    <span class="hljs-built_in">print</span>(a, <span class="hljs-number">7</span>); <span class="hljs-comment">// 3,5,5,7,12,21,98,</span><br>    <span class="hljs-type">int</span> *p = <span class="hljs-built_in">lower_bound</span>(a, a+<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);<br>    cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; p-a &lt;&lt; endl; <span class="hljs-comment">// 5,1</span><br>    p = <span class="hljs-built_in">upper_bound</span>(a, a+<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);<br>    cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; p-a &lt;&lt; endl; <span class="hljs-comment">// 7,3</span><br>    <br>    <span class="hljs-built_in">sort</span>(a, a+<span class="hljs-number">7</span>, <span class="hljs-built_in">rule</span>());<br>    <span class="hljs-built_in">print</span>(a, <span class="hljs-number">7</span>); <span class="hljs-comment">// 21,12,3,5,5,7,98,</span><br>    <span class="hljs-type">int</span> *q = <span class="hljs-built_in">lower_bound</span>(a, a+<span class="hljs-number">7</span>, <span class="hljs-number">16</span>, <span class="hljs-built_in">rule</span>());<br>    cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; q-a &lt;&lt; endl; <span class="hljs-comment">// 7,5</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">upper_bound</span>(a, a+<span class="hljs-number">7</span>, <span class="hljs-number">18</span>, <span class="hljs-built_in">rule</span>()) == a+<span class="hljs-number">7</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;not found&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; q-a &lt;&lt; endl; <span class="hljs-comment">// not found</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-平衡二叉树数据结构"><a href="#3-平衡二叉树数据结构" class="headerlink" title="3) 平衡二叉树数据结构"></a>3) 平衡二叉树数据结构</h2><p>有时我们需要在增删数据的同时进行数据查找，希望增加数据、删除数据和查找数据都能在log(n)复杂度下完成</p><p>“容器” “迭代器”</p><h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">multiset&lt;T&gt; st;<br></code></pre></td></tr></table></figure><p>这里定义一个multiset变量st，st里面存放数据类型为T的数据，并且能够自动排序</p><p>开始时st为空，可用st.insert添加元素，st.erase删除元素，st.find查找元素（复杂度都是log(n)）</p><p>排序规则：若表达式”a &lt; b”为true，则a排在b前面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo5</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span> <span class="hljs-comment">// 使用multiset和set需要此头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    multiset&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">14</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">7</span>, <span class="hljs-number">13</span>, <span class="hljs-number">21</span>, <span class="hljs-number">19</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        st.<span class="hljs-built_in">insert</span>(a[i]);<br>    multiset&lt;<span class="hljs-type">int</span>&gt;::iterator i;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    迭代器，相当于指针，指向multiset中的元素，访问multiset中的元素要通过迭代器</span><br><span class="hljs-comment">    multiset, set, multimap, map上的迭代器可++、--、用!=和==比较，但不可比大小、加减整数、相减（与指针的区别）</span><br><span class="hljs-comment">    st.begin()返回值类型为multiset&lt;int&gt;::iterator，是指向st的第一个元素的迭代器</span><br><span class="hljs-comment">    st.end()返回值类型为multiset&lt;int&gt;::iterator，是指向st的最后一个元素后面的迭代器</span><br><span class="hljs-comment">    对迭代器++，其指向下一个元素；对迭代器--，其指向上一个元素</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span> (i = st.<span class="hljs-built_in">begin</span>(); i != st.<span class="hljs-built_in">end</span>(); i++)<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>; <span class="hljs-comment">// 输出结果为：1, 7, 8, 8, 12, 13, 13, 14, 19, 21,</span><br>    cout &lt;&lt; endl;<br>    <br>    i = st.<span class="hljs-built_in">find</span>(<span class="hljs-number">22</span>); <span class="hljs-comment">// 若找到22，则返回指向该元素的迭代器；否则返回st.end()</span><br>    <span class="hljs-keyword">if</span> (i == st.<span class="hljs-built_in">end</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;not found&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出结果为：not found</span><br>    st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">22</span>);<br>    i = st.<span class="hljs-built_in">find</span>(<span class="hljs-number">22</span>);<br>    <span class="hljs-keyword">if</span> (i == st.<span class="hljs-built_in">end</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;not found&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;found:&quot;</span> &lt;&lt; *i &lt;&lt; endl; <span class="hljs-comment">// 输出结果为：found:22</span><br>    i = st.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">13</span>); <span class="hljs-comment">// 返回迭代器p，使得[st.begin(), p)中的元素都在13前面</span><br>    cout &lt;&lt; *i &lt;&lt; endl; <span class="hljs-comment">// 输出结果为：13</span><br>    i = st.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">8</span>); <span class="hljs-comment">// 返回迭代器p，使得[p, st.end())中的元素都在8后面</span><br>    cout &lt;&lt; *i &lt;&lt; endl; <span class="hljs-comment">// 输出结果为：12</span><br>    st.<span class="hljs-built_in">erase</span>(i); <span class="hljs-comment">// 注意这里的参数为迭代器</span><br>    <span class="hljs-keyword">for</span> (i = st.<span class="hljs-built_in">begin</span>(); i != st.<span class="hljs-built_in">end</span>(); i++)<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>; <span class="hljs-comment">// 输出结果为：1, 7, 8, 8, 13, 13, 14, 19, 21, 22,</span><br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo6</span><br><span class="hljs-comment">// 自定义排序规则的multiset用法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rule</span> <span class="hljs-comment">// 按个位数从小到大排序</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a1%<span class="hljs-number">10</span> &lt; a2%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    multiset&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt; &gt; st; <span class="hljs-comment">// 从大到小排序</span><br>    <span class="hljs-comment">// &quot;&gt;&gt;&quot;报错：[Error] &#x27;&gt;&gt;&#x27; should be &#x27;&gt; &gt;&#x27; within a nested template argument list</span><br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">14</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">7</span>, <span class="hljs-number">13</span>, <span class="hljs-number">21</span>, <span class="hljs-number">19</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        st.<span class="hljs-built_in">insert</span>(a[i]);<br>    multiset&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt; &gt;::iterator i;<br>    <span class="hljs-keyword">for</span> (i = st.<span class="hljs-built_in">begin</span>(); i != st.<span class="hljs-built_in">end</span>(); i++)<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>; <span class="hljs-comment">// 输出结果为：21,19,14,13,13,12,8,8,7,1,</span><br>    cout &lt;&lt; endl;<br>    <br>    multiset&lt;<span class="hljs-type">int</span>, rule&gt; st2; <span class="hljs-comment">// 按个位数从小到大排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        st2.<span class="hljs-built_in">insert</span>(a[i]);<br>    multiset&lt;<span class="hljs-type">int</span>, rule&gt;::iterator p;<br>    <span class="hljs-keyword">for</span> (p = st2.<span class="hljs-built_in">begin</span>(); p != st2.<span class="hljs-built_in">end</span>(); p++)<br>        cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>; <span class="hljs-comment">// 输出结果为：1,21,12,13,13,14,7,8,8,19,</span><br>    <span class="hljs-comment">// 个位数相同、值不同的数的顺序不确定</span><br>    cout &lt;&lt; endl;<br>    <br>    p = st2.<span class="hljs-built_in">find</span>(<span class="hljs-number">133</span>);<br>    cout &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">// 输出结果为：13</span><br>    <span class="hljs-comment">// “等于”的含义：“a必须在b前面”和“b必须在a前面”都不成立</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo7</span><br><span class="hljs-comment">// 自定义排序规则的multiset用法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> score;<br>&#125;;<br><br>student students[] = &#123;&#123;<span class="hljs-string">&quot;Jack&quot;</span>,<span class="hljs-number">112</span>,<span class="hljs-number">78</span>&#125;, &#123;<span class="hljs-string">&quot;Mary&quot;</span>,<span class="hljs-number">102</span>,<span class="hljs-number">85</span>&#125;, &#123;<span class="hljs-string">&quot;Ala&quot;</span>,<span class="hljs-number">333</span>,<span class="hljs-number">92</span>&#125;, &#123;<span class="hljs-string">&quot;Zero&quot;</span>,<span class="hljs-number">101</span>,<span class="hljs-number">70</span>&#125;, &#123;<span class="hljs-string">&quot;Cindy&quot;</span>,<span class="hljs-number">102</span>,<span class="hljs-number">78</span>&#125;&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rule</span> <span class="hljs-comment">// 按分数从大到小排序；若分数相等，则按姓名从小到大排序</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> student &amp; s1, <span class="hljs-type">const</span> student &amp; s2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s1.score != s2.score)<br>            <span class="hljs-keyword">return</span> s1.score &gt; s2.score;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(s1.name, s2.name) &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    multiset&lt;student, rule&gt; st;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        st.<span class="hljs-built_in">insert</span>(students[i]);<br>    multiset&lt;student, rule&gt;::iterator p;<br>    <span class="hljs-keyword">for</span> (p = st.<span class="hljs-built_in">begin</span>(); p != st.<span class="hljs-built_in">end</span>(); p++)<br>        cout &lt;&lt; p-&gt;score &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p-&gt;id &lt;&lt; endl;<br>    <br>    student s = &#123;<span class="hljs-string">&quot;Mary&quot;</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">85</span>&#125;;<br>    p = st.<span class="hljs-built_in">find</span>(s);<br>    <span class="hljs-keyword">if</span> (p != st.<span class="hljs-built_in">end</span>())<br>        cout &lt;&lt; p-&gt;score &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p-&gt;id &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果为：</span><br><span class="hljs-comment">92 Ala 333</span><br><span class="hljs-comment">85 Mary 102</span><br><span class="hljs-comment">78 Cindy 102</span><br><span class="hljs-comment">78 Jack 112</span><br><span class="hljs-comment">70 Zero 101</span><br><span class="hljs-comment">85 Mary 102</span><br><span class="hljs-comment">“等于”的含义：“a必须在b前面”和“b必须在a前面”都不成立</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;T&gt; st;<br></code></pre></td></tr></table></figure><p>set和multiset的区别在于容器里不能有相同元素（“等于”的含义：“a必须在b前面”和“b必须在a前面”都不成立）</p><p>所以，set添加元素可能不成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo8</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        st.<span class="hljs-built_in">insert</span>(a[i]);<br>    cout &lt;&lt; st.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出结果为：8</span><br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator i;<br>    <span class="hljs-keyword">for</span> (i = st.<span class="hljs-built_in">begin</span>(); i != st.<span class="hljs-built_in">end</span>(); i++)<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>; <span class="hljs-comment">// 输出结果为：1,2,3,5,6,7,8,12,</span><br>    cout &lt;&lt; endl;<br>    <br>    pair&lt;set&lt;<span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">bool</span>&gt; result = st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    pair&lt;T1, T2&gt;数据类型等价于：</span><br><span class="hljs-comment">    struct &#123;</span><br><span class="hljs-comment">    T1 first;</span><br><span class="hljs-comment">    T2 second;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (! result.second) <span class="hljs-comment">// 条件成立说明插入不成功</span><br>        cout &lt;&lt; *result.first &lt;&lt; <span class="hljs-string">&quot; already exists.&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 若插入不成功，则返回指向容器中已存在的相同元素的迭代器</span><br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; *result.first &lt;&lt; <span class="hljs-string">&quot; inserted.&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 若插入成功，则返回指向该元素的迭代器</span><br>    <span class="hljs-comment">// 输出结果为：2 already exists.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">multimap&lt;T1, T2&gt; mp;<br><span class="hljs-comment">// mp里的元素都是如下类型：</span><br><span class="hljs-keyword">struct</span> &#123;<br>    T1 first; <span class="hljs-comment">// 关键字</span><br>    T2 second; <span class="hljs-comment">// 值</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>multimap里的元素按照first从小到大或自定义规则排序，按照first查找</p><h5 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h5><p>一个学生成绩录入和查询系统，接受以下两种输入：<br>Add name id score<br>Query score</p><p>name是个不超过16字符的字符串，中间没有空格，代表学生姓名；id是个整数，代表学号；score是个整数，表示分数。学号不会重复，分数和姓名都可能重复。</p><p>两种输入交替出现。第一种输入表示要添加一个学生的信息，碰到这种输入，就记下学生的姓名、id和分数；第二种输入表示要查询，碰到这种输入，就输出已有记录中分数比score低的最高分获得者的姓名、学号和分数。如果有多个学生都满足条件，就输出学号最大的那个学生的信息。如果找不到满足条件的学生，则输出”Nobody”。</p><p>输入样例：<br>Add Jack 12 78<br>Query 78<br>Query 81<br>Add Percy 9 81<br>Add Marry 8 81<br>Query 82<br>Add Tom 11 79<br>Query 80<br>Query 81</p><p>输出样例：<br>Nobody<br>Jack 12 78<br>Percy 9 81<br>Tom 11 79<br>Tom 11 79</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo9</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span> <span class="hljs-comment">// 使用multimap和map需要此头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StudentInfo</span><br>&#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br>    <span class="hljs-type">int</span> score;<br>    StudentInfo info;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> multimap&lt;<span class="hljs-type">int</span>, StudentInfo&gt; MAP_STD;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MAP_STD mp;<br>    Student st;<br>    <span class="hljs-type">char</span> cmd[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; cmd) &#123;<br>        <span class="hljs-keyword">if</span> (cmd[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>            cin &gt;&gt; st.info.name &gt;&gt; st.info.id &gt;&gt; st.score;<br>            mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(st.score, st.info));<br>        &#125; <span class="hljs-comment">// make_pair类似函数，生成一个pair&lt;int, StudentInfo&gt;变量，其first等于st.score，second等于st.info</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmd[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> score;<br>            cin &gt;&gt; score;<br>            MAP_STD::iterator p = mp.<span class="hljs-built_in">lower_bound</span>(score);<br>            <span class="hljs-keyword">if</span> (p != mp.<span class="hljs-built_in">begin</span>()) &#123;<br>                p--;<br>                score = p-&gt;first; <span class="hljs-comment">// 为什么是-&gt;first而不是-&gt;score，思考“容器”和“迭代器”的关系</span><br>                MAP_STD::iterator maxp = p;<br>                <span class="hljs-type">int</span> maxid = p-&gt;second.id;<br>                <span class="hljs-keyword">for</span> (; p != mp.<span class="hljs-built_in">begin</span>() &amp;&amp; p-&gt;first == score; p--) &#123;<br>                    <span class="hljs-keyword">if</span> (p -&gt; second.id &gt; maxid) &#123;<br>                        maxp = p;<br>                        maxid = p-&gt;second.id;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 如果上面循环是因为p == mp.begin()而终止，则p指向的元素还要处理</span><br>                <span class="hljs-keyword">if</span> (p-&gt;first == score) &#123;<br>                    <span class="hljs-keyword">if</span> (p-&gt;second.id &gt; maxid) &#123;<br>                        maxp = p;<br>                        maxid = p-&gt;second.id;<br>                    &#125;<br>                &#125;<br>                cout &lt;&lt; maxp-&gt;second.name &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>                     &lt;&lt; maxp-&gt;second.id &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>                     &lt;&lt; maxp-&gt;first &lt;&lt; endl;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; <span class="hljs-string">&quot;Nobody&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果lower_bound的结果就是mp.begin()，说明没人分数比查询分数低</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map和multimap的区别在于容器里不能有关键字重复的元素（“等于”的含义：“a必须在b前面”和“b必须在a前面”都不成立）</p><p>所以，map添加元素可能不成功</p><p>可以使用[ ]，下标为关键字，返回值为first和关键字相同的元素的second</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo10</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br>    string name;<br>    <span class="hljs-type">int</span> score;<br>&#125;;<br><br>Student students[<span class="hljs-number">5</span>] = &#123;&#123;<span class="hljs-string">&quot;Jack&quot;</span>,<span class="hljs-number">89</span>&#125;, &#123;<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">74</span>&#125;, &#123;<span class="hljs-string">&quot;Cindy&quot;</span>,<span class="hljs-number">87</span>&#125;, &#123;<span class="hljs-string">&quot;Alysa&quot;</span>,<span class="hljs-number">87</span>&#125;, &#123;<span class="hljs-string">&quot;Micheal&quot;</span>,<span class="hljs-number">98</span>&#125;&#125;;<br><br><span class="hljs-keyword">typedef</span> map&lt;string, <span class="hljs-type">int</span>&gt; MP;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MP mp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(students[i].name, students[i].score));<br>    cout &lt;&lt; mp[<span class="hljs-string">&quot;Jack&quot;</span>] &lt;&lt; endl; <span class="hljs-comment">// 输出结果为：89</span><br>    mp[<span class="hljs-string">&quot;Jack&quot;</span>] = <span class="hljs-number">60</span>;<br>    <span class="hljs-keyword">for</span> (MP::iterator i = mp.<span class="hljs-built_in">begin</span>(); i != mp.<span class="hljs-built_in">end</span>(); i++)<br>        cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="hljs-string">&quot;) &quot;</span>; <span class="hljs-comment">// 输出结果为：(Alysa,87) (Cindy,87) (Jack,60) (Micheal,98) (Tom,74) </span><br>    cout &lt;&lt; endl;<br>    Student st;<br>    st.name = <span class="hljs-string">&quot;Jack&quot;</span>;<br>    st.score = <span class="hljs-number">99</span>;<br>    pair&lt;MP::iterator, <span class="hljs-type">bool</span>&gt; p = mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(st.name, st.score));<br>    <span class="hljs-keyword">if</span> (p.second)<br>        cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.first-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; p.first-&gt;second &lt;&lt; <span class="hljs-string">&quot;) inserted&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;insertion failed&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 输出结果为：insertion failed</span><br>    mp[<span class="hljs-string">&quot;Harry&quot;</span>] = <span class="hljs-number">78</span>; <span class="hljs-comment">// 插入一元素，其first为&quot;Harry&quot;，然后将其second改为78</span><br>    MP::iterator q = mp.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Harry&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; q-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; q-&gt;second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出结果为：(Harry,78)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h5><p>输入大量单词，每个单词一行，不超过20字符，没有空格。按出现次数从多到少输出这些单词及其出现次数。出现次数相同的，字典序靠前的在前面。</p><p>输入样例：<br>this<br>is<br>ok<br>this<br>plus<br>that<br>is<br>plus<br>plus</p><p>输出样例：<br>plus 3<br>is 2<br>this 2<br>ok 1<br>that 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo11</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Word</span><br>&#123;<br>    <span class="hljs-type">int</span> times;<br>    string wd;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rule</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> Word &amp; w1, <span class="hljs-type">const</span> Word &amp; w2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (w1.times != w2.times)<br>            <span class="hljs-keyword">return</span> w1.times &gt; w2.times;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> w1.wd &lt; w2.wd; <span class="hljs-comment">// 有#include &lt;string&gt;的头文件，可以直接比较</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    set&lt;Word, Rule&gt; st;<br>    map&lt;string, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s)<br>        mp[s]++; <span class="hljs-comment">// 当map元素值为int类型或者常量时候，默认值为0</span><br>    <span class="hljs-keyword">for</span> (map&lt;string, <span class="hljs-type">int</span>&gt;::iterator i = mp.<span class="hljs-built_in">begin</span>(); i != mp.<span class="hljs-built_in">end</span>(); i++) &#123;<br>        Word tmp;<br>        tmp.wd = i-&gt;first;<br>        tmp.times = i-&gt;second;<br>        st.<span class="hljs-built_in">insert</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (set&lt;Word, Rule&gt;::iterator i = st.<span class="hljs-built_in">begin</span>(); i != st.<span class="hljs-built_in">end</span>(); i++)<br>        cout &lt;&lt; i-&gt;wd &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i-&gt;times &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
